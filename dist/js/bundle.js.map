{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/SoundButton.js","webpack:///./js/FullScreenButton.js","webpack:///./js/StorageItemsManager.js","webpack:///./js/BonusWheelItem.js","webpack:///./js/AnimationHolder.js","webpack:///./js/BonusWheel.js","webpack:///./js/OpenCloseButton.js","webpack:///./js/Menu.js","webpack:///./js/main.js","webpack:///./js/ScrollContainer.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","CONFIG","x","y","FullScreenButton_CONFIG","StorageManager","[object Object]","window","localStorage","setItem","JSON","stringify","count","min","max","Math","floor","random","list","parse","getItem","forEach","item","push","itemName","amount","updatedList","map","index","itemIdx","items","total","probabilities","itemsList","sum","totalItemsSum","this","countTotalItemsSum","itemsProbabilities","countItemsProbabilities","probabilityArray","idx","randomInt","every","randomIndex","getRandomItemAccordingToProbability","randomItem","console","error","warn","findSectorToStopOn","BonusWheelItem","PIXI","Sprite","config","super","texture","parent","addChild","anchor","set","scale","updatePositionAndRotation","totalSectorsNum","sectorIndex","centerOffset","angle","PI","cos","sin","position","rotation","visible","AnimationHolder_AnimationHolder","me","defaultProp","id","undefined","target","prop","animation","keyFrames","step","complete","running","playbackSpeed","loop","readyToLoop","onStart","onEnd","onUpdate","children","localTime","delay","startTimeOffset","addToAnimationLoop","Sys","applyProperties","parseConfig","animationBuffer","obj","properties","timeSort","a","b","time","iterate","isObj","frameValue","parseInt","isDefined","length","sort","isArray","tempChildrenContainer","child","timeObj","timeStep","doAnimation","run","restoreOnLoop","restore","currentStepTime","performAction","root","isRoot","handleItems","runParent","restoreAnimation","play","callback","callbackCompleted","animate","type","selection","setParent","byKey","searchChildren","result","subResult","numKeyFrames","currentTime","increaseAnimationTime","currentKeyFrame","nextKeyFrame","handleCallback","progressKeyFrame","calculate","toIndex","goTo","doGoTo","keyFrame","currentStep","nextStep","calculateTime","from","to","Animation","utils","getInterpolationValue","ease","fireImmediately","isString","func","scope","fireEvent","args","isFunc","apply","Game","stage","view","animationManager","callbackContainer","totalTime","updateOperation","CIRCLE_DEG","MIN_DIFF","START_BOUNCE","maxSpeed","timeFraction","WHEEL_ITEMS_CENTER_OFFSET","WHEEL_ITEM_CONFIG","width","height","OpenCloseButton_CONFIG","OFFSET","TOP_OFFSET","__webpack_exports__","app","Application","innerWidth","innerHeight","backgroundColor","document","body","appendChild","ambientSound","Audio","winSound","soundButton","interactive","buttonMode","on","onButtonClick","soundOn","soundOff","currentState","setOnTexture","setOffTexture","Texture","volume","fullScreenButton","enterFullscreenMode","exitFullscreenMode","documentElement","webkitRequestFullscreen","webkitExitFullscreen","scrollContainer","Container","itemHeight","po","mask","Graphics","beginFill","drawRect","endFill","mousedown","lastPos","lastDiff","scrollTween","mousemove","e","onmousemove","onmousedown","mouseup","onmouseup","mouseupoutside","touchmove","touchstart","touchend","touchendoutside","originalEvent","data","clientY","touches","kill","goY","Quad","easeOut","abs","Back","Elastic","TweenMax","startIndex","endIndex","prerenderCallbacks","holder","lastTimeStepOccured","now","Date","diff","updateTime","initStorage","wheel","onStartBounceCompleteCallback","sectorItemsList","background","_initBackground","_initBgSpine","minSpeed","sprite","_initWheelSprite","wheelItems","_initWheelItems","highlightSprite","image","_initSprite","BLEND_MODES","ADD","_initEmptySprite","sectorsAngles","_mapSectorsAgles","sectors","animations","_initAnimations","pick","_initPickSprite","gift","_initGiftSprite","reset","refresh","container","imageName","fromImage","spineName","glow","loader","add","load","res","spine","Spine","spineData","skeleton","setToSetupPose","update","autoUpdate","state","setAnimation","ticker","bgAnimation","sizedContainer","bonusWheelItem","whellItems","NORMAL","200","1500","5000","5500","animSprite","wheelItem","show","blendMode","EMPTY","sectorsNames","sectorsNumber","degreesPerSector","sectorName","accelerationTicker","_initAccelerationTicker","accelerationDuration","uniformRotationTicker","_initUnformRotationTicker","decelerationTicker","_initDecelerationTicker","accelerationTime","_updateSpriteAngle","startUniformRotation","powerTwoOut","powerTwoIn","decelerateRotation","onWheelStartCallback","currentSpeed","currentAngle","RAD_TO_DEG","timePassedFromStart","finalAngle","stoppingDistance","newRotation","currentRotation","timeScale","getTimeScale","newRawRotation","prevFrameSpeed","stop","onWheelStopped","DEG_TO_RAD","prev","lastTick","prevWheelStoppingDistance","_updateStoppingDistance","minDistanceToTarget","getStoppingAngle","revolutionsBeforeStop","getRevolutionsBeforeStop","revsBeforeStop","targetDistance","currentValue","minimumSpinsBeforeStop","itemToStopOn","targetAngles","targetAnglesCount","randomAngleIndex","stopAngle","onEndCallback","currentItemIndex","round","currentWheelItem","hide","_onWinAnimationComplete","Infinity","Promise","resolve","startDeceleration","itemIndex","spineSlot","highlightSlot","getSectorItemsList","log","screen","addEventListener","renderer","resize","delta","cb","hideOffscreenElements","openCloseButton","openCallback","closeCallback","setClosedTexture","setOpenedTexture","menu","showMenu","hideMenu","onItemImgChange","onCountChange","input","createElement","accept","onchange","updateImageLocally","itemsListContainer","itemGroups","createItemsListInterface","countText","text","parentContainer","itemGroup","createItemContainer","itemContainer","button","addButton","addTxt","buttons","addPlusMinusButtons","addItemsListBg","graphics","lineStyle","addChildAt","itemImage","onItemClick","style","TextStyle","fill","fontSize","fontFamily","txt","Text","plusButton","initIncrementButton","onPlusButtonClick","minusButton","onMinusButtonClick","newCount","updateCountText","currentCount","targetSprite","getElementById","click","file","files","reader","FileReader","onload","setTexture","readAsDataURL","changeTexture","setItemCount","spacePressHandler","event","keyCode","sectorToStopOn","itemsLeft","isNoMoreItems","onStorageUpdated","onForseClosed","start","removeEventListener","setStoppingAngle","startStopping","then","playGiftAnimation","tapHandler","clickHandler"],"mappings":"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","file":"./js/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const CONFIG = {\n    x: 50,\n    y: 10\n};\n\nexport class SoundButton extends PIXI.Sprite {\n    constructor (config) {\n        super();\n\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.soundOn = config.soundOn;\n        this.soundOff = config.soundOff;\n\n        this.currentState = \"on\";\n        this.setOnTexture();\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"off\"){\n            this.currentState = \"on\";\n            this.setOnTexture();\n            this.soundOn();\n        } else if (this.currentState === \"on\"){\n            this.currentState = \"off\";\n            this.setOffTexture();\n            this.soundOff();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n\n    setOffTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/soundOff.png\")\n    }\n\n    setOnTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/soundOn.png\")\n    }\n}","const CONFIG = {\n    x: 100,\n    y: 10\n};\n\nexport class FullScreenButton extends PIXI.Sprite {\n    constructor (config) {\n        super();\n\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/fullscreen.png\");\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.enterFullscreenMode = config.enterFullscreenMode;\n        this.exitFullscreenMode = config.exitFullscreenMode;\n\n        this.currentState = \"off\";\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"off\"){\n            this.currentState = \"on\";\n            this.enterFullscreenMode();\n        } else if (this.currentState === \"on\"){\n            this.currentState = \"off\";\n            this.exitFullscreenMode();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n}","export class StorageManager{\n    static initStorage () {\n        window.localStorage.setItem(\"itemsList\", JSON.stringify([\n                {name: \"SYM0\", count: 2},\n                {name: \"SYM1\", count: 1},\n                {name: \"SYM2\", count: 4},\n                {name: \"SYM3\", count: 3},\n                {name: \"SYM4\", count: 5},\n                {name: \"SYM5\", count: 1},\n                {name: \"SYM6\", count: 3},\n                {name: \"SYM7\", count: 3},\n                {name: \"SYM8\", count: 2},\n                {name: \"SYM9\", count: 2},\n                {name: \"SYM10\", count: 3},\n                {name: \"SYM11\", count: 1}\n            ])\n        );\n    }\n\n    static randomInt (min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    static getSectorItemsList () {\n        var list = [];\n\n        JSON.parse(window.localStorage.getItem(\"itemsList\")).forEach(function (item) {\n            list.push(item.name);\n        });\n\n        return list;\n    }\n\n    static addItems (itemName, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item) {\n                if (itemName === item.name) {\n                    item.count += amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static removeItems (itemName, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item) {\n                if (itemName === item.name) {\n                    if (item.count - amount > 0) {\n                        item.count -= amount;\n                    } else {\n                        item.count = 0;\n                    }\n                }\n                return item\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static addItem (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    item.count += amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n\n    static removeItem (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    if (item.count - amount > 0) {\n                        item.count -= amount;\n                    } else {\n                        item.count = 0;\n                    }\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static setItemCount (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    item.count = amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static countItemsProbabilities (items, total) {\n        var probabilities = [];\n\n        items.forEach(function (item) {\n            probabilities.push(Math.floor(item.count * 100 / total));\n        });\n\n        return probabilities;\n    }\n\n    static countTotalItemsSum (itemsList) {\n        var sum = 0;\n\n        itemsList.forEach(function (item) {\n            sum += item.count;\n        });\n\n        return sum;\n    }\n\n    static getRandomItemAccordingToProbability () {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            totalItemsSum = this.countTotalItemsSum(itemsList),\n            itemsProbabilities = this.countItemsProbabilities(itemsList, totalItemsSum),\n            probabilityArray = [],\n            random;\n\n        itemsList.forEach(function (item, idx) {\n            for (var i = 0; i < itemsProbabilities[idx]; i++) {\n                probabilityArray.push(idx);\n            }\n        });\n\n        random = this.randomInt(0, 100);\n\n        return probabilityArray[random];\n    }\n\n    static isNoMoreItems () {\n        return JSON.parse(window.localStorage.getItem(\"itemsList\")).every(item => item.count === 0);\n    }\n\n    static findSectorToStopOn () {\n        var me = this,\n            randomIndex = me.getRandomItemAccordingToProbability(),\n            itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            randomItem = itemsList[randomIndex];\n\n        console.error(randomItem);\n\n        if (randomItem.count > 0) {\n            randomItem.count--;\n            window.localStorage.setItem(\"itemsList\", JSON.stringify(itemsList));\n\n            return randomIndex;\n        } else {\n            console.warn(\"no more \", randomItem.name);\n            debugger;\n            return me.findSectorToStopOn();\n        }\n    }\n}\n\n\n","export class BonusWheelItem extends PIXI.Sprite {\n    /**\n     *\n     * @param {object} config - wheelItem config\n     * @param {PIXI.Container|PIXI.Sprite} config.parent - Display object, the wheelItem will be added to\n     * @param {PIXI.Texture} config.texture - wheelItem texture\n     * @param {number} config.sectorIndex - sector the item is added to\n     * @param {number} config.centerOffset - distance from wheel center to wheelItem center\n     * @param {number} config.totalSectorsNum - total number of sectors on the parent wheel\n     */\n    constructor (config) {\n        super(config.texture);\n        config.parent.addChild(this);\n\n        this.anchor.set(0.5);\n        this.scale.set(config.scale);\n        this.updatePositionAndRotation(config.totalSectorsNum, config.sectorIndex, config.centerOffset);\n    }\n\n    /**\n     * Positions the item to the proper sector and rotates in a way that item's bottom is directed\n     * to the wheel center;\n     *\n     * @param {number} totalSectorsNum - total number of sectors on the parent wheel\n     * @param {number} sectorIndex - sector the item is added to\n     * @param {number} centerOffset - distance from wheel center to wheelItem center\n     */\n    updatePositionAndRotation(totalSectorsNum, sectorIndex, centerOffset){\n        var me = this,\n            angle = (2 * Math.PI / totalSectorsNum) * sectorIndex,\n            y = - centerOffset * Math.cos(angle),\n            x = - centerOffset * Math.sin(angle);\n\n        me.position.set(x, y);\n        me.rotation = -angle;\n    }\n\n    hide(){\n        this.visible = false;\n    }\n\n    show(){\n        this.visible = true;\n    }\n}","import {animationBuffer} from \"./main\"\n\nexport class AnimationHolder {\n    /**\n     * @property {String} [id=\"\"] The identifier for this animation, if you don't specify one we will try to use\n     * parent.id + \":\" + prop + \"Animation\"\n     */\n    /**\n     * @property {Object} [target=undefined] The target object we want to animate, if you don't specify one we will\n     * try to use the parent.target\n     */\n    /**\n     * @property {String} [prop=undefined] The name of the properties on the target we want to change\n     */\n    /**\n     * @property {Boolean} [running=false] If the animation is active\n     */\n    /**\n     * @property {Number} [playbackSpeed=undefined] If we want to play the animation faster (>1) or slower (<1)\n     */\n    /**\n     * @property {Boolean} [loop=false] Will repeat the whole animation. If it have separate operations with different\n     * time the shorter ones will wait at the end key frame until the longest is done. onStart & onEnd will not be\n     * called every loop (if that is needed, set callbacks on key frames instead). Will also wait for all it's\n     * children to complete.\n     */\n    /**\n     * @property {Boolean} [readyToLoop=false] Since we sometime need to wait for our children we use this to know\n     * when we can loop back to the start.\n     */\n    /**\n     * @property {Function} [onStart=undefined] Callback function before the animation starts\n     */\n    /**\n     * @property {Function} [onEnd=undefined] Callback function when the animation is complete\n     */\n    /**\n     * @property {Function} [onUpdate=undefined] Callback function on every frame before the operation run. Will be\n     * called regardless if the holder have operation, target etc or not, as long as it is running (and it's parents) the\n     * function will be called.\n     */\n    /**\n     * @property {Array} [children=[]] So we can nestle animation\n     */\n    /**\n     * @property {Animation.Holder} [parent=undefined] A reference to the holders parent\n     */\n    /**\n     * @property {Number} [localTime=0] Local time counter\n     */\n    /**\n     * @property {Number} [delay=0] Time before the operations start after the animation starts\n     */\n    /**\n     * @property {Number} [startTimeOffset=0] If we want the animation to start at a specific time (TODO: currently if the offset is beyond the first keyframe it will start at that keyframe instead)\n     */\n    /**\n     * @property {Object} [operations={}] The operations the holder preforms\n     */\n    /**\n     * @property {Object} [operationSteps={}] The current key frame for every operation\n     */\n    /**\n     * @property {Object} [operationEnded={}] If all the operations are done\n     */\n\n\n    /**\n     * Constructor\n     *\n     * @param {Object} config The config object\n     */\n    constructor (config) {\n        var me = this,\n            defaultProp = {\n                id                  : undefined,    // the identifier for this animation\n                target              : undefined,    // the target object we want to animate\n                prop                : undefined,    // the name of the properties on the target we want to change.\n                animation           : {             // object that will hold keyFrames etc.\n                    keyFrames : [],\n                    step : 0,                       // the current keyFrame we're on\n                    complete : false                // if the animation is done\n                },\n                running             : false,        // if the animation is active.\n                playbackSpeed       : undefined,    // if we want to play the animation faster (>1) or slower (<1)\n                loop                : false,        // will repeat the whole animation. If it have separate operations\n                                                    // with different time the shorter ones will wait at the end key frame\n                                                    // until the longest is done. onStart & onEnd will not be called every\n                                                    // loop (if that is needed, set callbacks on key frames instead).\n                                                    // Will also wait for all it's children to complete.\n                readyToLoop         : false,        // since we sometime need to wait for our children we use this to know\n                                                    // when we can loop back to the start.\n                onStart             : undefined,    // callback before the animation starts\n                onEnd               : undefined,    // callback when the animation is complete\n                onUpdate            : undefined,    // callback on every frame before the operation run. Will be\n                                                    // called regardless if the holder have operation, target etc or not\n                children            : [],           // so we can nestle animation\n                parent              : undefined,    // a reference to the holders parent\n                localTime           : 0,            // local time counter\n                delay               : 0,            // time before the operations start after the animation starts\n                startTimeOffset     : undefined,    // if we want the animation to start at a specific time\n                //operations          : {},           // the operations the holder preforms\n                //operationSteps      : {},           // the current key frame for every operation\n                //operationsEnded     : false,        // if all the operations are done\n                addToAnimationLoop  : false         // adding the holder to the animation loop on creation\n            };\n\n        config = Sys.applyProperties(defaultProp, config);\n\n        // Parse the config, this allows us to use several config syntax\n        config = me.parseConfig(config);\n\n        me = Sys.applyProperties(me, config);\n\n        //// Set the default parameters needed by the operations\n        //me.setOperationDefaultProperties();\n\n        if ( config.addToAnimationLoop ){\n            animationBuffer.push(me);\n        }\n\n    }\n\n    /**\n     * Parse the config so that it matches the actual object properties.\n     *\n     * @param config\n     * @return {Object} The parsed properties\n     */\n    parseConfig  (config) {\n        var properties = {\n                animation : {\n                    keyFrames : [],\n                    step : 0,\n                    complete : false\n                }\n            },\n            //operations = Object.keys(Animation.Operations),\n            timeSort = function (a, b) {\n                return (a.time - b.time);\n            },\n            obj;\n\n        // Process all keys on the config object\n        Sys.iterate(config, function(key, value){\n\n            // If we have an animation, parse it\n            if (key === \"animate\" ) {\n\n                /*DEBUG_START*/\n                if ( key !== \"animate\" ){\n                    // TODO: right now we only support the \"animate\" operation, when we need more we have to make them.\n                    console.warn(\"You are trying to use a \" + key + \" operation on a Animation.Holder, for now only 'animate' is supported\");\n                }\n                /*DEBUG_END*/\n\n                // if the operation is an array or object\n                if ( Sys.isObj(value) ){\n\n                    Sys.iterate(value, function(time, frameValue){\n                        // Define the frame object with the time value\n                        obj = { time : parseInt(time, 10) };\n\n                        // If the frame is an object with a defined value then we have non value properties mixed in\n                        if (Sys.isObj(frameValue) ) {\n                            if ( Sys.isDefined(frameValue.value) ){\n                                obj = Sys.applyProperties(obj, frameValue);\n                            }\n                            else {\n                                obj.value = frameValue;\n                            }\n                        }\n                        // Otherwise it is just a plain value\n                        else {\n                            obj.value = frameValue;\n                            /*DEBUG_START*/\n                            if ( !Sys.isDefined(config.prop) && config.length > 1 ){\n                                console.warn(\"If we only specify a number value the property 'prop' must exist\");\n                            }\n                            /*DEBUG_END*/\n                        }\n\n                        // Push the key frame\n                        properties.animation.keyFrames.push(obj);\n                    });\n\n                    properties.animation.keyFrames.sort(timeSort);\n                }\n                else if ( Sys.isArray(value) ){\n                    // the operation is already in the right format, add it to the operations object\n                    properties.animation.keyFrames = value;\n                }\n                else {\n                    // error\n                    console.warn(\"Operation is in wrong format\");\n                }\n            }\n            // Else assign the value\n            else {\n                properties[key] = value;\n            }\n        });\n\n        // if target is undefined use the parents target (if it exist)\n        if ( !Sys.isDefined(properties.target) && Sys.isDefined(properties.parent) && Sys.isDefined(properties.parent.target) ){\n            properties.target = properties.parent.target;\n        }\n\n        /*DEBUG_START*/\n        if ( Sys.isDefined(properties.target) && !Sys.isObj(properties.target) ){\n            console.warn(\"The target of a Animation.Holder must be a Object\");\n        }\n        /*DEBUG_END*/\n\n        // if the id is undefined use the targets id (if it exist) and the operation type\n        if ( !Sys.isDefined(properties.id) && Sys.isDefined(properties.target) && Sys.isDefined(properties.target.id) ){\n            var prop = Sys.isDefined(properties.prop) ? properties.prop : \"\";\n\n            properties.id = properties.target.id + \":\" + prop + \"Animation\";\n        }\n\n        // if we already have children in the config, create them and add them\n        if ( Sys.isDefined(properties.children) && properties.children.length > 0 ){\n            var tempChildrenContainer = [],\n                parent = this;\n\n            properties.children.forEach(function(child){\n                var animation;\n\n                if ( Sys.isDefined(child.localTime) ){\n                    // the child is already a AnimationHolder\n                    animation = child;\n                }\n                else {\n                    child.parent = {target : config.target};\n                    animation = new AnimationHolder(child);\n                }\n                animation.parent = parent;\n                tempChildrenContainer.push( animation );\n            });\n\n            properties.children = tempChildrenContainer;\n        }\n\n        return properties;\n    }\n\n    /**\n     * Run the holder and it's children\n     *\n     * @param {Object} timeObj The object containing the time\n     */\n    run (timeObj) {\n        var me = this,\n            timeStep = timeObj.timeStep;\n\n        if (me.localTime === 0 && Sys.isDefined(me.startTimeOffset) ){\n            // if this is the first frame of the animation and we have a start offset\n            timeStep += me.startTimeOffset;\n        }\n\n        if ( Sys.isDefined(me.playbackSpeed) ){\n            // adjust the time step based on playback speed\n            timeStep *= me.playbackSpeed;\n        }\n\n        me.localTime += timeStep; // increase the local timer\n\n        if(me.localTime >= me.delay) {\n\n            // Time step is used to keep track of internal timers on the operation level\n            me.doAnimation(timeStep);\n\n            me.children.forEach(function(child){\n                if ( child.running ){\n                    child.run({timeStep : timeStep, time : timeObj.time});\n\n                    // if the child is still running\n                    if ( child.running ){\n                        // we should also be running\n                        me.running = true;\n\n                        if ( !child.loop && !child.readyToLoop ){\n                            // if it's time for us to loop, wait until the children are done\n                            // but don't wait on looping children\n                            me.readyToLoop = false;\n                        }\n                    }\n                }\n            });\n\n            if ( Sys.isDefined(me.onUpdate) ){\n                me.onUpdate(timeStep);\n            }\n        }\n\n        if ( me.loop && me.readyToLoop ){\n            // meaning I'm done and all my children are done (ignoring children that are looping)\n            me.restoreOnLoop();\n        }\n        else if ( !me.running ){\n            // this animation is done\n            if ( Sys.isDefined(me.onEnd) ){\n                me.onEnd();\n            }\n\n            // restore the animation on completion so we can start it from the beginning on the next play()\n            me.restore();\n        }\n    }\n\n    /**\n     * Runs each animation operation that is set for the holder\n     *\n     * @private\n     * @param {Number} currentStepTime the current time step\n     */\n    doAnimation (currentStepTime) {\n        var me = this,\n            numKeyFrames = me.animation.keyFrames.length;\n\n        // If we don't have any keyFrames or target just return\n        if (numKeyFrames < 2 || !Sys.isDefined(me.target) ) {\n            me.readyToLoop = true;\n            me.running = false;\n            return;\n        }\n\n        // Check if the animation have finished\n        var running = me.performAction(currentStepTime);\n\n        if (!running) {\n            // all the operations are done\n            me.running = false;\n            me.readyToLoop = true;\n        }\n    }\n\n    /**\n     * Play the animation\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to play. If none is\n     * specified (or true) we play all the children. If you send in an empty array [] we'll only play the current.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    play (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.running = true;\n\n        me.handleItems(\"play\", children);\n\n        if (me.localTime === 0 && Sys.isDefined(me.onStart)){\n            // if we start the game from the beginning do the onStart callback\n            me.onStart();\n        }\n\n        // make sure the parents are running\n        if (isRoot){\n            me.runParent();\n        }\n    }\n\n    runParent (){\n        var me = this;\n\n        if ( Sys.isDefined(me.parent) ){\n            me.parent.running = true;\n\n            me.parent.runParent();\n        }\n    }\n\n    /**\n     * Pause the animation\n     *\n     * @param {Array} [children] An array with children that we want to pause. If none is\n     * specified we pause all the children. If you send in an empty array [] we'll only pause the current holder.\n     */\n    pause (children) {\n        this.running = false;\n\n        this.handleItems(\"pause\", children);\n    }\n\n    /**\n     * Stop the animation and reset it to the beginning. Will do it for all the children as well\n     *\n     * @param {Array} [children] An array with children that we want to stop. If none is\n     * specified we stop all the children. If you send in an empty array [] we'll only stop the current.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    stop (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.running = false;\n\n        me.handleItems(\"stop\", children);\n\n        if ( isRoot ){\n            me.restore(children, true);\n        }\n    }\n\n    /**\n     * Restores the basic properties of the holder in order to run it again.\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to restore. If none is\n     * specified (or true) we restore all the children. If you send in an empty array [] we'll only restore the current holder.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    restore (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.localTime = 0;\n        me.readyToLoop = false;\n\n        me.restoreAnimation();\n\n        me.handleItems(\"restore\", children);\n\n        // if we are already running and are the root object we play()\n        if ( me.running && isRoot ){\n            me.play(children, true);\n        }\n    }\n\n    /**\n     * Restores the basic properties of the holder in order to run it again.\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to restore. If none is\n     * specified (or true) we restore all the children. If you send in an empty array [] we'll only restore the current holder.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    restoreOnLoop (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        if ( isRoot || !me.loop ){\n            me.running = true;\n            //me.localTime = 0;\n            me.readyToLoop = false;\n\n            me.restoreAnimation();\n\n            me.handleItems(\"restoreOnLoop\");\n        }\n    }\n\n    restoreAnimation (){\n        this.animation.time = 0;\n        this.animation.step = 0;\n\n        this.animation.keyFrames.forEach(function(key){\n            if (Sys.isDefined(key.callback)) {\n                key.callbackCompleted = false;\n            }\n\n            // add more stuff\n        });\n    }\n\n    /**\n     * @private\n     * Update the holder with the operation configuration\n     *\n     * @param {Object} config The configuration\n     */\n    updateOperation (config) {\n        var me = this,\n            obj = {};\n\n        //me.applyDefaultValuesToItem(me);\n\n        obj.animate = config;\n\n        obj = me.parseConfig(obj);\n\n        me.animation = obj.animation;\n        //me.applyDefaultValuesToOperation(me);\n\n        me.restore();\n    }\n\n    /**\n     * @private\n     * Call the specified function on all the items\n     *\n     * @param {String} type The function to call on the items\n     * @param {Array} [selection] The optional array of items to handle\n     */\n    handleItems (type, selection){\n        var items = (Sys.isDefined(selection) && Sys.isArray(selection)) ? selection : this.children;\n\n        items.forEach(function(child){\n            child[type](true, false);\n        });\n    }\n\n    setParent (parent){\n        this.parent = parent;\n        parent.children.push(this);\n\n        // if you don't have a target, use the parents\n        if ( !Sys.isDefined(this.target) ){\n            this.target = parent.target;\n        }\n    }\n\n    addChild (children){\n        var me = this;\n\n        if (Sys.isArray(children) ){\n            children.forEach(function(child){\n                child.setParent(me);\n            });\n        }\n        else if (Sys.isObj(children)){\n            children.setParent(me);\n        }\n    }\n\n    /**\n     * Will search children (and grandchildren) for a Holder that mach the key and value provide.\n     *\n     * NOTE: if there is more than one match you will get the first one.\n     *\n     * @param {String} value The value that should match\n     * @param {String} [byKey] Which property key we should check against, default \"id\"\n     *\n     * @return {object|boolean} the items that match our search criteria, or false if it didn't find anything\n     */\n    findChild (value, byKey){\n        var key = Sys.isDefined(byKey) ? byKey : \"id\",\n            item = false,\n            searchChildren = function(items) {\n                var result = false,\n                    subResult = false;\n\n                items.forEach(function(item){\n                    if ( Sys.isDefined(item[key]) && item[key] === value ){\n                        result = item;\n                    }\n\n                    if ( Sys.isDefined(item.children) ){\n                        subResult = searchChildren(item.children);\n\n                        if ( Sys.isObj(subResult) ){\n                            result = subResult;\n                        }\n                    }\n                });\n\n                return result;\n            };\n\n        // start with the main Holder\n        if ( this[key] === value ){\n            return this;\n        }\n\n        if ( Sys.isDefined(this.children) ){\n            item = searchChildren(this.children );\n        }\n\n        return item;\n    }\n\n    /**\n     * Performs the specified action on a given object.\n     *\n     * @param {Number} currentStepTime The time since the last render (ms)\n     */\n    performAction (currentStepTime) {\n        var me = this,\n            animation = me.animation,\n            keyFrames = animation.keyFrames,\n            numKeyFrames = keyFrames.length,\n            currentTime = me.increaseAnimationTime(currentStepTime),\n            currentKeyFrame = keyFrames[animation.step],\n            nextKeyFrame = keyFrames[animation.step + 1],\n            running = true;\n\n        /*DEBUG_START*/\n        if ( numKeyFrames < 2 ){\n            console.warn(\"The Holder \" + item + \" have an animation with less than two keyFrames, the operation needs a minimum of two keyFrames to be able to animate.\");\n            return 0;\n        }\n        /*DEBUG_END*/\n\n        me.handleCallback(currentKeyFrame); // added an extra callback check here to make sure callbacks on keyFrame 0 are fired\n\n        // step through keyFrames, from oldKeyFrameIndex, until we are on the current one\n        // loop if necessary\n        // fire events and callbacks on every new keyFrame we pass\n        // goTo keyFrames\n\n        // check if we have passed the next keyFrame\n        if ( nextKeyFrame.time <= currentTime){\n            me.progressKeyFrame();\n\n            currentKeyFrame = keyFrames[animation.step];\n\n            // are we at the last keyFrame, ie we're not looping and the animation is complete\n            if ( animation.step === numKeyFrames - 1 ){\n                nextKeyFrame = currentKeyFrame;\n                running = false;\n            }\n            else {\n                nextKeyFrame = keyFrames[animation.step + 1];\n            }\n        }\n\n        // when we have the current keyFrame, interpolate between that and the next keyFrame\n        me.calculate(animation.time, currentKeyFrame, nextKeyFrame);\n\n        return running;\n    }\n\n    progressKeyFrame (toIndex){\n        var me = this,\n            animation = me.animation,\n            keyFrames = animation.keyFrames,\n            currentKeyFrame;\n\n        // step to next keyFrame\n        animation.step = Sys.isDefined(toIndex) ? toIndex : animation.step + 1;\n\n        // do events and callbacks\n        currentKeyFrame = keyFrames[animation.step];\n        me.handleCallback(currentKeyFrame);\n\n        // check for goTo\n        if ( Sys.isDefined(currentKeyFrame.goTo) ) {\n            me.doGoTo(currentKeyFrame);\n        }\n\n        // if we haven't reached the last keyFrame\n        if ( animation.step !== keyFrames.length - 1 ){\n            // check if we should move one more\n            if ( animation.time >= keyFrames[animation.step + 1].time){\n                me.progressKeyFrame();\n            }\n        }\n        else if ( me.loop  ){ // at the last keyFrame and we're looping\n            animation.time -= keyFrames[animation.step].time;\n            me.progressKeyFrame(0);\n        }\n\n    }\n\n    doGoTo (keyFrame){\n        var me = this;\n\n        me.animation.time = me.animation.keyFrames[keyFrame.goTo].time;\n        me.animation.step = keyFrame.goTo;\n\n        /*DEBUG_START*/\n        console.warn(\"Warning: goTo functionality not completed, use at own risk.\");\n        // TODO: fix goTo, callback resets when going back and callback firing when going forward etc.\n        /*DEBUG_END*/\n    }\n\n    /**\n     * Calculates the time steps and sets the values that should be interpolated.\n     *\n     * @protected\n     * @param {Number} currentTime The current time step\n     * @param {Object} currentStep The current frame\n     * @param {Object} nextStep The next frame\n     */\n    calculate (currentTime, currentStep, nextStep) {\n        var me = this,\n            time = me.calculateTime(currentTime, currentStep, nextStep),\n            from = currentStep.value,\n            to = nextStep.value,\n            target;\n\n        if ( Sys.isObj(from) ){\n            Sys.iterate(from, function(key, value){\n                target = Sys.isDefined(me.prop) ? me.target[me.prop] : me.target;\n\n                target[key] = Animation.utils.getInterpolationValue(value, to[key], time, currentStep.ease, key);\n            });\n        }\n        else { // we only animate one number\n            me.target[me.prop] = Animation.utils.getInterpolationValue(from, to, time, currentStep.ease);\n        }\n    }\n\n    /**\n     * @private\n     * @param {Object} currentKeyFrame The object holding the current key frame information\n     */\n    handleCallback (currentKeyFrame) {\n        var callback = currentKeyFrame.callback,\n            container;\n\n        if(Sys.isDefined(callback) && !currentKeyFrame.callbackCompleted) {\n\n            if ( callback.fireImmediately ){\n                if ( Sys.isString(callback.func) ){\n                    // an event\n                    callback.scope.fireEvent(callback.func, callback.args);\n                }\n                else if ( Sys.isFunc(callback.func) ){\n                    // a function\n                    callback.func.apply(callback.scope, callback.args);\n                }\n            }\n            else {\n                container = Game.stage.view.animationManager.callbackContainer;\n                container.push(callback);\n            }\n\n            currentKeyFrame.callbackCompleted = true;\n        }\n    }\n\n    /**\n     * Calculates the time vars.\n     *\n     * @private\n     * @param {Number} currentTime The current time step\n     * @param {Object} currentStep The current frame\n     * @param {Object} nextStep The next frame\n     */\n    calculateTime (currentTime, currentStep, nextStep) {\n        var timeStep = currentTime - currentStep.time,\n            totalTime = nextStep.time - currentStep.time;\n\n        //If timeStep equals 0 and totalTime equals 0. The result will be NaN\n        return totalTime !== 0 ? timeStep / totalTime : 1;\n    }\n\n\n    /**\n     * Increase the timeBuffer\n     *\n     * @param {Number} time The time the time buffer should be increased\n     */\n    increaseAnimationTime  (time) {\n        if (!Sys.isDefined(this.animation.time)) {\n            this.animation.time = time;\n        }\n        else {\n            this.animation.time += time;\n        }\n\n        return this.animation.time;\n    }\n\n    animate (config, play) {\n        this.updateOperation(config);\n        if ( play ){\n            this.play();\n        }\n    }\n\n}","import {BonusWheelItem} from \"./BonusWheelItem\";\nimport {AnimationHolder} from \"./AnimationHolder\";\n\nconst CIRCLE_DEG = 360;\n    //the minimum difference (angle) between current wheel stop and previous wheel stop:\nconst MIN_DIFF = 270;\nconst START_BOUNCE = {\n    //negative value, since the wheel moves backwards\n    maxSpeed: -0.5,\n        //time fraction of the whole acceleration time\n        timeFraction: 1/500\n};\n\nconst WHEEL_ITEMS_CENTER_OFFSET = 300;\nconst WHEEL_ITEM_CONFIG = {\n    width: 100,\n    height: 100\n};\n\nexport class BonusWheel extends PIXI.Container {\n    \n    constructor (config, onStartBounceCompleteCallback, app) {\n        super();\n        var me = this;\n\n        me.sectorItemsList = config.sectorItemsList;\n\n        me.background = me._initBackground(me, \"wheel_bg\");\n\n        me._initBgSpine(me, \"glow\", app);\n\n        me.background.anchor.set(0.5,0.5);\n\n        //degrees per frame\n        me.maxSpeed = config.maxSpeed;\n        me.minSpeed = config.minSpeed;\n\n        me.sprite = me._initWheelSprite(me, \"wheelWin\");\n        me.wheelItems = me._initWheelItems(me.sprite);\n\n        //will be added to a separate spine slot:\n        me.highlightSprite = typeof config.image !== \"undefined\" ? me._initSprite(config.image, PIXI.BLEND_MODES.ADD) : me._initEmptySprite();\n        me.sectorsAngles = me._mapSectorsAgles(config.sectors);\n        me.animations = me._initAnimations(config);\n        me.onStartBounceCompleteCallback = onStartBounceCompleteCallback;\n        me.config = config;\n\n        me.pick = me._initPickSprite(me);\n        me.gift = me._initGiftSprite(me, \"SYM0\");\n\n        me.reset();\n        me.refresh();\n    }\n\n    _initBackground (container, imageName) {\n        return container.addChild(new PIXI.Sprite.fromImage(\"assets/images/\"+imageName+\".jpg\"))\n    }\n\n    _initBgSpine (container, spineName, app) {\n        var me = this,\n            glow;\n\n        PIXI.loader\n            .add('glow', 'assets/spine/glow.json')\n            .load(onAssetsLoaded);\n\n        function onAssetsLoaded(loader,res) {\n            // instantiate the spine animation\n            glow = new PIXI.spine.Spine(res.glow.spineData);\n            glow.skeleton.setToSetupPose();\n            glow.update(0);\n            glow.autoUpdate = false;\n\n            me.background.addChild(glow);\n\n            // once position and scaled, set the animation to play\n            glow.state.setAnimation(0, 'spin', true);\n            app.ticker.add(function() {\n                glow.update(0.02);\n            });\n\n            glow.visible = false;\n            me.bgAnimation = glow;\n        }\n\n    }\n\n    _initWheelSprite (container, imageName) {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/\"+imageName+\".png\");\n        sprite.anchor.set(0.5, 0.5);\n        container.addChild(sprite);\n\n        return sprite;\n    }\n\n    /**\n     * Adds wheel items - sprites that rotate together with the wheel\n     *\n     * @param {PIXI.Container|PIXI.Sprite} parent - wheelItems will be added here\n     * @returns {Array<S.BonusWheelItem>}\n     * @private\n     */\n    _initWheelItems(parent){\n        var me = this,\n            sizedContainer,\n            bonusWheelItem,\n            whellItems = [];\n\n        me.sectorItemsList.forEach(function (item, index) {\n            sizedContainer = new PIXI.Container();\n\n            bonusWheelItem = new BonusWheelItem({\n                parent: sizedContainer,\n                texture: new PIXI.Texture.fromImage(\"assets/images/prizes/\" + item + \".png\"),\n                sectorIndex: index,\n                centerOffset: WHEEL_ITEMS_CENTER_OFFSET,\n                totalSectorsNum: me.sectorItemsList.length\n            });\n\n            bonusWheelItem.width = WHEEL_ITEM_CONFIG.width;\n            bonusWheelItem.height = WHEEL_ITEM_CONFIG.height;\n\n            parent.addChild(sizedContainer);\n            whellItems.push(bonusWheelItem);\n        });\n\n        return whellItems;\n    }\n\n    _initPickSprite (container) {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/pick.png\");\n        sprite.anchor.set(0.5, 0.5);\n        container.addChild(sprite);\n        sprite.position.y = -460;\n\n        return sprite;\n    }\n\n    _initGiftSprite (container, imageName) {\n        var sprite = this._initSprite(imageName, PIXI.BLEND_MODES.NORMAL);\n\n        container.addChild(sprite);\n        sprite.width = 100;\n        sprite.height = 100;\n        sprite.position.y = -250;\n        sprite.visible = false;\n        sprite.animation = new AnimationHolder({\n            addToAnimationLoop: true,\n            target: sprite,\n            children: [\n                {\n                    prop: \"position\",\n                    animate: {\n                        200: {y: -(WHEEL_ITEMS_CENTER_OFFSET)},\n                        1500: {y: 0},\n                        5000: {y: 0},\n                        5500: {y: -(WHEEL_ITEMS_CENTER_OFFSET)},\n                    }\n                },\n                {\n                    prop: \"width\",\n                    animate: {\n                        200: WHEEL_ITEM_CONFIG.width,\n                        1500: WHEEL_ITEM_CONFIG.width * 3,\n                        5000: WHEEL_ITEM_CONFIG.width * 3,\n                        5500: WHEEL_ITEM_CONFIG.width\n                    }\n                },\n                {\n                    prop: \"height\",\n                    animate: {\n                        200: WHEEL_ITEM_CONFIG.height,\n                        1500: WHEEL_ITEM_CONFIG.height * 3,\n                        5000: WHEEL_ITEM_CONFIG.height * 3,\n                        5500: WHEEL_ITEM_CONFIG.height\n                    }\n                }\n            ]\n        });\n\n        return sprite;\n    }\n\n    /**\n     *\n     * @param animSprite - win presentation sprite\n     * @private\n     */\n    _onWinAnimationComplete(animSprite){\n        animSprite.visible = false;\n        this.wheelItems.forEach(function(wheelItem){\n            wheelItem.show();\n        });\n        this.bgAnimation.visible = false;\n    }\n\n    _initSprite (imageName, blendMode) {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/prizes/\"+imageName+\".png\");\n\n        sprite.anchor.set(0.5, 0.5);\n        sprite.blendMode = blendMode;\n\n        return sprite;\n    }\n\n    _initEmptySprite () {\n        return new PIXI.Sprite(PIXI.Texture.EMPTY);\n    }\n\n    /**\n     * @param {Array} sectorsNames - list of sectors names on the wheel\n     * @returns {Object} sectorsAngles - config with all the sectors mapped to angles of wheel rotation\n     */\n    _mapSectorsAgles (sectorsNames) {\n        var sectorsNumber = sectorsNames.length,\n            degreesPerSector = CIRCLE_DEG / sectorsNumber,\n            sectorsAngles = {};\n\n        sectorsNames.forEach(function (sectorName, index) {\n            //forced to use array of angles, since we might have multiple sectors for one value\n            //for instance, the key wheel has 6 sectors with 0 and 2 sectors with 1\n            if(!sectorsAngles[sectorName]){\n                sectorsAngles[sectorName] = [];\n            }\n            sectorsAngles[sectorName].push(degreesPerSector * index);\n        });\n\n        return sectorsAngles\n    }\n\n    /**\n     * These are not \"animations\" in common understanding of the Animation.Holder, they are rather tickers,\n     * that perform certain update functions on every frame\n     *\n     * @param {Object} config - wheel config\n     * @returns {Object} list of all available animations\n     */\n    _initAnimations (config) {\n        return {\n            \"accelerationTicker\": this._initAccelerationTicker(config.accelerationDuration),\n            \"uniformRotationTicker\": this._initUnformRotationTicker(),\n            \"decelerationTicker\": this._initDecelerationTicker()\n        }\n    }\n\n    /**\n     * @param {number} accelerationTime - time it will take to accelerate from 0 to maximum speed\n     * @returns {Object} animation holder that gradually(with easing) increases currentSpeed\n     * that will be used in _updateSpriteAngle on each frame for smooth wheel start\n     */\n    _initAccelerationTicker (accelerationTime) {\n        var me = this;\n\n        return new AnimationHolder({\n            target: me,\n            prop: \"currentSpeed\",\n            onUpdate: me._updateSpriteAngle.bind(me),\n            onEnd: me.startUniformRotation.bind(me),\n            animate: [\n                {\n                    time: 0,\n                    value: 0,\n                    ease: Animation.utils.powerTwoOut\n                },\n                //the wheel bounce back on start:\n                {\n                    time: accelerationTime * START_BOUNCE.timeFraction,\n                    value: START_BOUNCE.maxSpeed,\n                    ease: Animation.utils.powerTwoIn\n                },\n                {\n                    time: accelerationTime,\n                    value: me.maxSpeed\n                }\n            ],\n            addToAnimationLoop: true\n        });\n    }\n\n    /**\n     * @returns {Object} animation holder that calls _updateSpriteAngle on every frame\n     * by this moment, the speed reaches maximum value, so this spins the wheel uniformly\n     */\n    _initUnformRotationTicker () {\n        var me = this;\n\n        return new AnimationHolder({\n            onUpdate: me._updateSpriteAngle.bind(me),\n            addToAnimationLoop: true,\n            loop: true\n        });\n    }\n\n    /**\n     * @returns {Object} animation holder that calls decelerateRotation on every frame and smoothly stops the wheel\n     */\n    _initDecelerationTicker () {\n        var me = this;\n\n        return new AnimationHolder({\n            addToAnimationLoop: true,\n            onUpdate: me.decelerateRotation.bind(me),\n            loop: true\n        });\n    }\n\n    startUniformRotation () {\n        var me = this;\n        //resolving promise (there's no callback on restore):\n        me.onWheelStartCallback && me.onWheelStartCallback();\n        //in regular case it would've reached maxSpeed naturally by this moment, but on restores we're forced to set it manually:\n        me.currentSpeed = me.maxSpeed;\n        me.animations.uniformRotationTicker.play();\n    }\n\n    /**\n     *  decreases currentSpeed depending on currentAngle relative to finalAngle\n     *  the closer we are to the finalAngle the slower we go\n     *  calls _updateSpriteAngle to apply new speed\n     */\n    decelerateRotation () {\n        var me = this,\n            currentAngle = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            distanceLeft = me.finalAngle - currentAngle,\n            maxSpeedFraction = distanceLeft / me.stoppingDistance,\n            timePassedFromStart = 1 - maxSpeedFraction;\n\n        me.currentSpeed = Animation.utils.powerTwoIn(me.maxSpeed, 0, timePassedFromStart);\n\n        //proceed with uniform rotation if the speed might become too low:\n        if (me.currentSpeed < me.minSpeed) {\n            me.currentSpeed = me.minSpeed;\n        }\n\n        me._updateSpriteAngle();\n    }\n\n    /**\n     *  Changes the sprite angle by adding currentSpeed to it, stops the deceleration ticker if reached final angle\n     */\n    _updateSpriteAngle () {\n        var me = this,\n            currentRotation = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            timeScale = me.getTimeScale(),\n            newRawRotation = currentRotation + me.currentSpeed * timeScale,\n            newRotation;\n\n        //startBounce completion condition:\n        if(me.prevFrameSpeed < 0 && me.currentSpeed > 0){\n            me.onStartBounceCompleteCallback(me.config.name);\n        }\n\n        if (newRawRotation >= me.finalAngle) {\n            newRotation = me.finalAngle;\n            me.currentSpeed = 0;\n            me.animations.decelerationTicker.stop();\n\n            //resolving promise:\n            me.onWheelStopped();\n        } else {\n            newRotation = newRawRotation;\n        }\n\n        me.sprite.rotation = newRotation * PIXI.DEG_TO_RAD;\n        me.highlightSprite.rotation = me.sprite.rotation;\n        me.prevFrameSpeed = me.currentSpeed;\n    }\n\n    /**\n     *  Returns timescale coefficient to adjust the animation duration on low FPS\n     *\n     *  @returns {number} - deltaTime correction coefficient\n     */\n    getTimeScale () {\n        var me = this,\n            //todo: remove before release:\n            timeScale = 1.5,\n            oneFrameDuration = 1000/60,\n            now = Date.now(),\n            prev = me.lastTick ? me.lastTick : now - oneFrameDuration;\n\n        me.lastTick = now;\n\n        //todo: remove before release:\n        return (now - prev) * timeScale/oneFrameDuration;\n    }\n\n    start (callback) {\n        this.onWheelStartCallback = callback;\n        this.animations.accelerationTicker.play();\n\n\n    }\n\n    startDeceleration (prevWheelStoppingDistance, onWheelStopped) {\n        var me = this;\n\n        me.onWheelStopped = onWheelStopped;\n        me.animations.uniformRotationTicker.stop();\n        me._updateStoppingDistance(prevWheelStoppingDistance);\n        me.animations.decelerationTicker.play();\n\n        this.bgAnimation.visible = true;\n        this.bgAnimation.state.setAnimation(0, 'spin', true);\n    }\n\n    /**\n     *  updates distance to the destination point and final sprite angle at the moment of stopping\n     *  depending on currentAngle, stopAngle and prevWheelStoppingDistance\n     *\n     *  @param {number} prevWheelStoppingDistance - distance, the previous wheel has to cover before full stop\n     */\n    _updateStoppingDistance (prevWheelStoppingDistance) {\n\n        var me = this,\n            currentAngle = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            //using % me.CIRCLE_DEG here to simply calculations:\n            currentAngleReduced = currentAngle % CIRCLE_DEG,\n            angleToFullCircleLeft = CIRCLE_DEG - currentAngleReduced,\n            stopAngle = me.getStoppingAngle(),\n            minDistanceToTarget = angleToFullCircleLeft + stopAngle,\n            //number of 360 degrees wheel revolutions before stop\n            revolutionsBeforeStop = me.getRevolutionsBeforeStop(minDistanceToTarget, prevWheelStoppingDistance);\n\n        me.stoppingDistance = minDistanceToTarget + revolutionsBeforeStop * CIRCLE_DEG;\n        me.finalAngle = currentAngle + me.stoppingDistance;\n    }\n\n    /**\n     * Calculates the number of extra revolutions to make depending on previous wheel stopping distance\n     * (current wheel distance should always be greater than the previous one)\n     *\n     * @param {number} minDistanceToTarget - minimum possible distance between current and final angles\n     * @param {number} prevWheelStoppingDistance - distance the previous wheel will cover before full stop\n     * @returns {number} spinsBeforeStop - number of extra revolutions before full stop\n     */\n    getRevolutionsBeforeStop (minDistanceToTarget, prevWheelStoppingDistance) {\n        var me = this,\n            revsBeforeStop = 0,\n            targetDistance = prevWheelStoppingDistance + MIN_DIFF,\n            currentValue = minDistanceToTarget;\n        \n        while(currentValue < targetDistance){\n            revsBeforeStop++;\n            currentValue = minDistanceToTarget + CIRCLE_DEG * revsBeforeStop;\n        }\n\n        revsBeforeStop = Math.max(revsBeforeStop, me.config.minimumSpinsBeforeStop);\n\n        return revsBeforeStop;\n    }\n\n    /**\n     * Randomly selects from all available sectors angles for itemToStopOn\n     * (for instance, out of 6 options for 0 level on level wheel) and sets it as stopAngle\n     *\n     * @param {number | string} itemToStopOn - value on the sector whe wheel should stop on\n     * @returns {void}\n     */\n    setStoppingAngle (itemToStopOn) {\n        var me = this,\n            targetAngles = me.sectorsAngles[itemToStopOn],\n            targetAnglesCount = targetAngles.length,\n            randomAngleIndex = Math.floor(Math.random() * targetAnglesCount);\n\n        me.stopAngle = targetAngles[randomAngleIndex];\n    }\n\n    getStoppingAngle () {\n        return this.stopAngle;\n    }\n\n    getCurrentStoppingDistance () {\n        return this.stoppingDistance;\n    }\n\n    playGiftAnimation (name, onEndCallback) {\n        var me = this,\n            gift = me.gift,\n            totalSectorsNum = me.sectorItemsList.length,\n            currentItemIndex = Math.round( totalSectorsNum / CIRCLE_DEG * me.stopAngle),\n            currentWheelItem = me.wheelItems[currentItemIndex];\n\n        currentWheelItem.hide();\n\n        gift.texture = currentWheelItem.texture;\n        gift.visible = true;\n\n        gift.animation.onEnd = function () {\n            me._onWinAnimationComplete(gift);\n            onEndCallback();\n        };\n\n        gift.animation.play();\n\n        me.bgAnimation.state.setAnimation(0, 'win', true);\n    }\n\n    reset () {\n        var me = this;\n\n        me.stoppingDistance = Infinity;\n        me.finalAngle = Infinity;\n        me.sprite.rotation = 0;\n        me.currentSpeed = 0;\n        me.lastTick = 0;\n    }\n\n    startStopping () {\n        var me = this;\n\n        return new Promise(function (resolve) {\n            me.startDeceleration(0, function () {\n                resolve();\n            })\n        })\n    }\n\n    changeTexture (itemIndex, texture) {\n        this.wheelItems[itemIndex].texture = texture;\n    }\n\n    refresh () {\n        this.scale.set(window.innerHeight / 1080);\n    }\n\n}","const CONFIG = {\n    x: 10,\n    y: 10\n};\n\nexport class OpenCloseButton extends PIXI.Sprite{\n\n    constructor (config) {\n        super();\n\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.openCallback = config.openCallback;\n        this.closeCallback = config.closeCallback;\n\n        this.currentState = \"closed\";\n        this.setClosedTexture();\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"closed\"){\n            this.currentState = \"opened\";\n            this.setOpenedTexture();\n            this.openCallback();\n        } else if (this.currentState === \"opened\"){\n            this.currentState = \"closed\";\n            this.setClosedTexture();\n            this.closeCallback();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n\n    setClosedTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/settings.png\")\n    }\n\n    setOpenedTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/error.png\")\n    }\n\n    onForseClosed () {\n        this.currentState = \"closed\";\n        this.setClosedTexture();\n        this.closeCallback();\n    }\n}","const OFFSET = 10;\nconst TOP_OFFSET = 80;\n\nexport class Menu extends PIXI.Container{\n    constructor (config) {\n        super();\n\n        this.onItemImgChange = config.onItemImgChange;\n        this.onCountChange = config.onCountChange;\n\n        const input = document.createElement('input');\n        input.accept = \"image/*\";\n        input.id = \"inpt\";\n        input.type = \"file\";\n        input.onchange = this.updateImageLocally.bind(this);\n\n        document.body.appendChild(input);\n\n        const itemsListContainer = new PIXI.Container();\n        itemsListContainer.position.y = TOP_OFFSET;\n\n        const itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\"));\n        this.itemGroups = this.createItemsListInterface(itemsList, itemsListContainer);\n        this.addChild(itemsListContainer);\n\n        this.hideMenu();\n    }\n\n    onStorageUpdated () {\n        console.log(\"updating the storage\");\n        const itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\"));\n        this.itemGroups.forEach(function (item, index) {\n            item.countText.text = itemsList[index].count;\n        });\n\n    }\n\n    showMenu () {\n        this.visible = true;\n    }\n\n    hideMenu () {\n        this.visible = false;\n    }\n\n    createItemsListInterface (itemsList, parentContainer) {\n        var me = this,\n            itemGroup, itemGroups = [];\n\n        PIXI.loader\n            .load(\n                itemsList.forEach(function (item, itemIndex) {\n                    itemGroup = me.createItemContainer(parentContainer, item, itemIndex);\n                    itemGroups[itemIndex] = itemGroup;\n                })\n            );\n\n        return itemGroups;\n    }\n\n    createItemContainer (parentContainer, item, itemIndex) {\n        const itemContainer = new PIXI.Container();\n        let itemGroup = {};\n\n        itemGroup.button = this.addButton(itemContainer, item.name, itemIndex);\n        itemGroup.countText = this.addTxt(itemContainer, item.count);\n        itemGroup.buttons = this.addPlusMinusButtons(itemContainer, itemIndex, item.count);\n        itemContainer.position.set(OFFSET, (OFFSET * itemIndex) + (itemIndex * itemContainer.height));\n\n        this.addItemsListBg(itemContainer);\n\n        parentContainer.addChild(itemContainer);\n        return itemGroup;\n    }\n\n    addItemsListBg (container) {\n        var graphics = new PIXI.Graphics();\n\n        graphics.beginFill(0x3d5c5c);\n        graphics.lineStyle(2, 0xDE3249, 1);\n        graphics.drawRect(0, 0, container.width, container.height);\n        graphics.endFill();\n        graphics.blendMode = 2;\n\n        container.addChildAt(graphics, 0);\n    }\n\n    addButton (parentContainer, name, itemIndex) {\n        const me = this;\n        const texture = new PIXI.Texture.from(\"assets/images/prizes/\" + name + \".png\");\n        const itemImage = new PIXI.Sprite(texture);\n\n        itemImage.height = 50;\n        itemImage.width = 50;\n\n        itemImage.interactive = true;\n        itemImage.buttonMode = true;\n        itemImage.on('pointerdown', me.onItemClick.bind(me, itemImage, itemIndex));\n\n        parentContainer.addChild(itemImage);\n    }\n\n    addTxt (parentContainer, count) {\n        const style = new PIXI.TextStyle({\n                fill: '#d8df75',\n                fontSize: 15,\n                fontFamily: 'Arial'\n            }),\n            txt = new PIXI.Text(count, style);\n\n        txt.anchor.set(0.5);\n        txt.position.set(100, parentContainer.width / 2);\n\n        parentContainer.addChild(txt);\n        return txt;\n    }\n\n    addPlusMinusButtons (parentContainer, itemIndex) {\n        const me = this;\n        let buttons = {};\n\n        buttons.plusButton = me.initIncrementButton(\n            {\n                x: 160,\n                y: 0,\n                width: 20,\n                height: 20,\n                texture: new PIXI.Texture.from(\"assets/images/buttons/plus.png\"),\n                callback: me.onPlusButtonClick.bind(me, itemIndex),\n                parentContainer: parentContainer\n            });\n\n        buttons.minusButton = me.initIncrementButton(\n            {\n                x: 160,\n                y: 30,\n                width: 20,\n                height: 20,\n                texture: new PIXI.Texture.from(\"assets/images/buttons/minus.png\"),\n                callback: me.onMinusButtonClick.bind(me, itemIndex),\n                parentContainer: parentContainer\n            });\n\n        return buttons;\n    }\n\n    initIncrementButton (config) {\n        let button = new PIXI.Sprite(config.texture);\n\n        button.position.set(config.x, config.y);\n        button.interactive = true;\n        button.buttonMode = true;\n        button.width = config.width;\n        button.height = config.height;\n        button.on(\"pointerdown\", config.callback);\n        config.parentContainer.addChild(button);\n\n        return button;\n    }\n\n    onPlusButtonClick (itemIndex) {\n        let newCount = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count + 1;\n\n        this.onCountChange(itemIndex, newCount);\n        this.updateCountText(itemIndex, newCount);\n    }\n\n    onMinusButtonClick (itemIndex) {\n        const currentCount = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count;\n        let newCount;\n\n        if((currentCount - 1) <= 0){\n            newCount = 0;\n        } else {\n            newCount = currentCount - 1 ;\n        }\n\n        this.onCountChange(itemIndex, newCount);\n        this.updateCountText(itemIndex, newCount);\n    }\n\n    updateCountText (itemIndex, newCount) {\n        if(!newCount){\n            this.itemGroups[itemIndex].countText.text = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count;\n            return;\n        }\n        this.itemGroups[itemIndex].countText.text = newCount;\n    }\n\n    onItemClick (targetSprite, itemIndex) {\n        document.getElementById(\"inpt\").click();\n        this.targetSprite = targetSprite;\n        this.itemIndex = itemIndex;\n    }\n\n    updateImageLocally () {\n        var me = this,\n            file = document.getElementById(\"inpt\").files[0],\n            reader = new FileReader();\n\n        reader.onload = function () {\n            me.targetSprite.setTexture(new PIXI.Texture.from(reader.result));\n            me.onItemImgChange(me.itemIndex, new PIXI.Texture.from(reader.result));\n        };\n\n        if (file) {\n            reader.readAsDataURL(file);\n        }\n\n    }\n\n\n}","import {SoundButton} from \"./SoundButton\";\nimport {FullScreenButton} from \"./FullScreenButton\";\nimport {ScrollContainer} from \"./ScrollContainer\";\nimport {StorageManager} from \"./StorageItemsManager\";\nimport {BonusWheel} from \"./BonusWheel\";\nimport {OpenCloseButton} from \"./OpenCloseButton\";\nimport {Menu} from \"./Menu\";\n\nexport const animationBuffer = [];\n\nvar app = new PIXI.Application(window.innerWidth, window.innerHeight, {backgroundColor : 0x000000});\ndocument.body.appendChild(app.view);\n\nvar ambientSound = new Audio(\"assets/sounds/ambient.mp3\");\nvar winSound = new Audio(\"assets/sounds/AUTOMOBILE.mp3\");\n\nconst soundButton = new SoundButton({\n    soundOn: function () {\n        ambientSound.volume = 0.5;\n        winSound.volume = 1;\n    },\n    soundOff: function () {\n        ambientSound.volume = 0;\n        winSound.volume = 0;\n    }\n});\n\nconst fullScreenButton = new FullScreenButton({\n    enterFullscreenMode: function () {\n        document.documentElement.webkitRequestFullscreen();\n    },\n    exitFullscreenMode: function () {\n        document.webkitExitFullscreen();\n    }\n});\n\nvar scrollContainer = new ScrollContainer(0, 0, 500, 1000, 1500);\n\nvar prerenderCallbacks = [animate],\n    lastTimeStepOccured = 0,\n    currentStepTime = 0,\n    currentTime = 0;\n\nlastTimeStepOccured = updateTime();\n\nif(!window.localStorage.getItem(\"itemsList\")){\n    StorageManager.initStorage();\n}\n\nvar wheel = new BonusWheel({\n    name: \"freespins\",\n    spineSlot: \"1st_back\",\n    highlightSlot: \"1st_back2\",\n    sectors: [0,1,2,3,4,5,6,7,8,9,10,11],\n    maxSpeed: 16,\n    minSpeed: 0.15,\n    accelerationDuration: 1800,\n    minimumSpinsBeforeStop: 3,\n    sectorItemsList: StorageManager.getSectorItemsList(),\n    image: \"SYM0\"\n}, function () {\n    console.log(\"onStartBounceCompleteCallback\");\n}, app);\n\n// move the sprite to the center of the screen\nwheel.position.set(app.screen.width / 2, app.screen.height / 2);\n\nwindow.addEventListener(\"resize\", function() {\n    app.renderer.resize(window.innerWidth, window.innerHeight);\n    wheel.position.set(window.innerWidth / 2, window.innerHeight / 2);\n});\n\n// Listen for animate update\napp.ticker.add(function(delta) {\n    prerenderCallbacks.forEach(function(cb) {\n        cb();\n    });\n    scrollContainer.hideOffscreenElements();\n});\n\nfunction animate(){\n    animationBuffer.forEach(function(holder){\n        if ( holder.running ){\n            holder.run({\n                timeStep: currentStepTime,\n                time: currentTime\n            });\n        }\n    });\n}\n\nfunction updateTime() {\n    var now = Date.now(),\n        diff = now - lastTimeStepOccured;\n\n    // Check if more time than allowed has passed since the last frame\n    if (diff > 250) {\n        diff = 1000 / 60;\n    }\n\n    currentStepTime = diff | 0;\n    currentTime += currentStepTime;\n\n    return now;\n}\n\napp.stage.addChild(wheel);\n\nvar openCloseButton = new OpenCloseButton({\n    openCallback: function () {\n        menu.showMenu();\n    },\n    closeCallback: function () {\n        menu.hideMenu();\n    }\n});\n\nvar menu = new Menu({\n    onItemImgChange: function (index, texture) {\n        wheel.changeTexture(index, texture);\n    },\n    onCountChange: function (index, count) {\n        StorageManager.setItemCount(index, count);\n    }\n});\n\n//app.stage.addChild(menu);\nscrollContainer.addChild(menu);\napp.stage.addChild(scrollContainer);\napp.stage.addChild(soundButton);\napp.stage.addChild(fullScreenButton);\napp.stage.addChild(openCloseButton);\n\ndocument.documentElement.webkitRequestFullscreen();\n\n\nwindow.addEventListener(\"resize\", refreshAll);\nfunction refreshAll() {\n    wheel.refresh();\n}\n\nfunction spacePressHandler(event) {\n    console.warn(\"spacePressHandler\");\n    if(event.keyCode === 32){\n        var itemsLeft = !StorageManager.isNoMoreItems(),\n            itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            sectorToStopOn;\n\n        if(!itemsLeft){\n            console.error(\"no more items at all\");\n        } else {\n            winSound.play();\n            sectorToStopOn = StorageManager.findSectorToStopOn();\n            menu.onStorageUpdated();\n            console.warn(\"stopping at: \", sectorToStopOn);\n\n            openCloseButton.onForseClosed();\n            wheel.start();\n            document.removeEventListener(\"keypress\", spacePressHandler);\n            wheel.setStoppingAngle(sectorToStopOn);\n            wheel.startStopping().then(function () {\n                wheel.playGiftAnimation(itemsList[sectorToStopOn].name, function () {\n                    document.addEventListener(\"keypress\", spacePressHandler);\n                });\n            });\n        }\n    }\n}\n\nfunction clickHandler() {\n    console.warn(\"clickHandler\");\n    var itemsLeft = !StorageManager.isNoMoreItems(),\n        itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n        sectorToStopOn;\n\n    if(!itemsLeft){\n        console.error(\"no more items at all\");\n    } else {\n        winSound.play();\n        sectorToStopOn = StorageManager.findSectorToStopOn();\n        menu.onStorageUpdated();\n        console.warn(\"stopping at: \", sectorToStopOn);\n\n        openCloseButton.onForseClosed();\n        wheel.start();\n        document.removeEventListener(\"click\", clickHandler);\n        wheel.setStoppingAngle(sectorToStopOn);\n        wheel.startStopping().then(function () {\n            wheel.playGiftAnimation(itemsList[sectorToStopOn].name, function () {\n                document.addEventListener(\"click\", clickHandler);\n            });\n        });\n    }\n}\n\nfunction tapHandler() {\n    console.error(\"touchstart\");\n    var itemsLeft = !StorageManager.isNoMoreItems(),\n        itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n        sectorToStopOn;\n\n    if(!itemsLeft){\n        console.error(\"no more items at all\");\n    } else {\n        winSound.play();\n        sectorToStopOn = StorageManager.findSectorToStopOn();\n        menu.onStorageUpdated();\n        console.warn(\"stopping at: \", sectorToStopOn);\n\n        openCloseButton.onForseClosed();\n        wheel.start();\n        document.removeEventListener(\"touchstart\", tapHandler);\n        wheel.setStoppingAngle(sectorToStopOn);\n        wheel.startStopping().then(function () {\n            wheel.playGiftAnimation(itemsList[sectorToStopOn].name, function () {\n                document.addEventListener(\"touchstart\", tapHandler);\n            });\n        });\n    }\n}\n\ndocument.addEventListener(\"keypress\", spacePressHandler);\ndocument.addEventListener(\"touchstart\", tapHandler);\ndocument.addEventListener(\"click\", clickHandler);\n","export class ScrollContainer extends PIXI.Container{\n    constructor(x, y, width, height, itemHeight) {\n        super();\n\n        this.po = new PIXI.Container();\n        this.scrollContainer = new PIXI.Container();\n        this.po.addChild(this.scrollContainer);\n        this.items = [];\n        this.x = x;\n        this.y = y;\n\n        this.scrollContainer.x = x;\n        this.scrollContainer.y = y;\n        this.height = height;\n        this.itemHeight = itemHeight;\n\n        this.mask = new PIXI.Graphics();\n        this.mask\n            .beginFill(0xFFFFFF)\n            .drawRect(x, y, width, height)\n            .endFill();\n\n        this.po.addChild(this.mask);\n        this.scrollContainer.mask = this.mask;\n\n        this.mousedown = false;\n        this.lastPos = null;\n        this.lastDiff = null;\n        this.scrollTween = null;\n\n        this.po.interactive = true;\n        this.po.mousemove = e => this.onmousemove(e);\n        this.po.mousedown = e => this.onmousedown(e);\n        this.po.mouseup = e => this.onmouseup(e);\n        this.po.mouseupoutside = e => this.onmouseup(e);\n        this.po.touchmove = e => this.onmousemove(e);\n        this.po.touchstart = e => this.onmousedown(e);\n        this.po.touchend = e => this.onmouseup(e);\n        this.po.touchendoutside = e => this.onmouseup(e);\n    }\n\n    onmousemove(e) {\n        const { originalEvent } = e.data;\n        var clientY = !originalEvent.touches ? originalEvent.clientY : originalEvent.touches[0].clientY;\n\n        if (this.mousedown) {\n            this.lastDiff = clientY - this.lastPos.y;\n            this.lastPos.y = clientY;\n\n            if (-this.scrollContainer.y < 0) {\n                this.scrollContainer.y += this.lastDiff / 2;\n            } else {\n                this.scrollContainer.y += this.lastDiff;\n            }\n        }\n    }\n\n    onmousedown(e) {\n        const { originalEvent } = e.data;\n        const clientY = !originalEvent.touches ? originalEvent.clientY : originalEvent.touches[0].clientY;\n        this.mousedown = true;\n        if (this.scrollTween) {\n            this.scrollTween.kill();\n        }\n        this.lastPos = {\n            y: clientY\n        };\n    }\n\n    onmouseup() {\n        if (this.lastDiff) {\n            let goY = this.scrollContainer.y + this.lastDiff * 10;\n            let ease = Quad.easeOut;\n            let time = Math.abs(this.lastDiff / 150);\n            if (goY < -this.items.length * this.itemHeight + this.height + this.y) {\n                goY = -this.items.length * this.itemHeight + this.height + this.y;\n                ease = Back.easeOut;\n                time = 0.1 + Math.abs(this.lastDiff / 150);\n            }\n            if (goY > this.y) {\n                goY = this.y;\n                ease = Back.easeOut;\n                time = 0.1 + Math.abs(this.lastDiff / 150);\n            }\n\n            if (this.scrollContainer.y > 0) {\n                time = 1 + this.scrollContainer.y / 500;\n                ease = Elastic.easeOut;\n            }\n            if (this.scrollContainer.y < -this.items.length * this.itemHeight + this.height) {\n                time = 1 + (this.items.length * this.itemHeight + this.height + this.scrollContainer.y) / 500;\n                ease = Elastic.easeOut;\n            }\n\n            this.scrollTween = TweenMax.to(this.scrollContainer, time, {\n                y: goY,\n                ease\n            });\n        }\n\n        this.mousedown = false;\n        this.lastPos = null;\n        this.lastDiff = null;\n    }\n\n    // This should be called every tick. Use only for scrolling containers with lots of elements for performance.\n    hideOffscreenElements() {\n        const startIndex = Math.floor(-(this.scrollContainer.y - this.y) / this.itemHeight);\n        const endIndex = Math.floor(startIndex + (this.height / this.itemHeight));\n        for (let i = 0; i < this.items.length; i++) {\n            const item = this.items[i];\n            item.visible = false;\n            if (i >= startIndex && i <= endIndex + 1) {\n                item.visible = true;\n            }\n        }\n    }\n\n    addItem(item) {\n        this.scrollContainer.addChild(item);\n        this.items.push(item);\n        item.y = (this.items.length - 1) * this.itemHeight;\n    }\n}"],"sourceRoot":""}