{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/AnimationHolder.js","webpack:///./js/BonusWheel.js","webpack:///./js/BonusWheelItem.js","webpack:///./js/FullScreenButton.js","webpack:///./js/Menu.js","webpack:///./js/OpenCloseButton.js","webpack:///./js/ScrollContainer.js","webpack:///./js/SoundButton.js","webpack:///./js/StorageItemsManager.js","webpack:///./js/main.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAsC;;AAE/B;AACP;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,kBAAkB,OAAO,eAAe;AACxC;AACA;AACA,kBAAkB,OAAO,mBAAmB;AAC5C;AACA;AACA,kBAAkB,OAAO,mBAAmB;AAC5C;;;AAGA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,YAAY,qDAAe;AAC3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,yCAAyC;;AAExE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;AC1vBA;AAAA;AAAA;AAAA;AAAgD;AACE;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,8DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D,+BAA+B,KAAK;AACpC,+BAA+B,KAAK;AACpC,+BAA+B,gCAAgC;AAC/D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA,mBAAmB,gEAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA,mBAAmB,gEAAe;AAClC;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA,mBAAmB,gEAAe;AAClC;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,C;;;;;;;;;;;;AC9gBA;AAAA;AAAO;AACP;AACA;AACA,eAAe,OAAO;AACtB,eAAe,2BAA2B;AAC1C,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC5CA;AAAA;AAAA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,C;;;;;;;;;;;;AC/BA;AAAA;AAAA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA,C;;;;;;;;;;;;ACpNA;AAAA;AAAA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AChDA;AAAA;AAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,gBAAgB;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC3HA;AAAA;AAAA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzCA;AAAA;AAAO;AACP;AACA;AACA,iBAAiB,uBAAuB;AACxC,iBAAiB,uBAAuB;AACxC,iBAAiB,uBAAuB;AACxC,iBAAiB,uBAAuB;AACxC,iBAAiB,uBAAuB;AACxC,iBAAiB,uBAAuB;AACxC,iBAAiB,uBAAuB;AACxC,iBAAiB,uBAAuB;AACxC,iBAAiB,uBAAuB;AACxC,iBAAiB,uBAAuB;AACxC,iBAAiB,wBAAwB;AACzC,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACU;AACF;AACG;AACb;AACU;AACtB;;AAErB;;AAEP,uEAAuE,2BAA2B;AAClG;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED,wBAAwB,wDAAW;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED,6BAA6B,kEAAgB;AAC7C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED,0BAA0B,gEAAe;;AAEzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI,mEAAc;AAClB;;AAEA,gBAAgB,sDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAc;AACnC;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,0BAA0B,gEAAe;AACzC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED,eAAe,0CAAI;AACnB;AACA;AACA,KAAK;AACL;AACA,QAAQ,mEAAc;AACtB;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,mEAAc;AACvC;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,6BAA6B,mEAAc;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;;AAEA","file":"./js/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import {animationBuffer} from \"./main\"\n\nexport class AnimationHolder {\n    /**\n     * @property {String} [id=\"\"] The identifier for this animation, if you don't specify one we will try to use\n     * parent.id + \":\" + prop + \"Animation\"\n     */\n    /**\n     * @property {Object} [target=undefined] The target object we want to animate, if you don't specify one we will\n     * try to use the parent.target\n     */\n    /**\n     * @property {String} [prop=undefined] The name of the properties on the target we want to change\n     */\n    /**\n     * @property {Boolean} [running=false] If the animation is active\n     */\n    /**\n     * @property {Number} [playbackSpeed=undefined] If we want to play the animation faster (>1) or slower (<1)\n     */\n    /**\n     * @property {Boolean} [loop=false] Will repeat the whole animation. If it have separate operations with different\n     * time the shorter ones will wait at the end key frame until the longest is done. onStart & onEnd will not be\n     * called every loop (if that is needed, set callbacks on key frames instead). Will also wait for all it's\n     * children to complete.\n     */\n    /**\n     * @property {Boolean} [readyToLoop=false] Since we sometime need to wait for our children we use this to know\n     * when we can loop back to the start.\n     */\n    /**\n     * @property {Function} [onStart=undefined] Callback function before the animation starts\n     */\n    /**\n     * @property {Function} [onEnd=undefined] Callback function when the animation is complete\n     */\n    /**\n     * @property {Function} [onUpdate=undefined] Callback function on every frame before the operation run. Will be\n     * called regardless if the holder have operation, target etc or not, as long as it is running (and it's parents) the\n     * function will be called.\n     */\n    /**\n     * @property {Array} [children=[]] So we can nestle animation\n     */\n    /**\n     * @property {Animation.Holder} [parent=undefined] A reference to the holders parent\n     */\n    /**\n     * @property {Number} [localTime=0] Local time counter\n     */\n    /**\n     * @property {Number} [delay=0] Time before the operations start after the animation starts\n     */\n    /**\n     * @property {Number} [startTimeOffset=0] If we want the animation to start at a specific time (TODO: currently if the offset is beyond the first keyframe it will start at that keyframe instead)\n     */\n    /**\n     * @property {Object} [operations={}] The operations the holder preforms\n     */\n    /**\n     * @property {Object} [operationSteps={}] The current key frame for every operation\n     */\n    /**\n     * @property {Object} [operationEnded={}] If all the operations are done\n     */\n\n\n    /**\n     * Constructor\n     *\n     * @param {Object} config The config object\n     */\n    constructor (config) {\n        var me = this,\n            defaultProp = {\n                id                  : undefined,    // the identifier for this animation\n                target              : undefined,    // the target object we want to animate\n                prop                : undefined,    // the name of the properties on the target we want to change.\n                animation           : {             // object that will hold keyFrames etc.\n                    keyFrames : [],\n                    step : 0,                       // the current keyFrame we're on\n                    complete : false                // if the animation is done\n                },\n                running             : false,        // if the animation is active.\n                playbackSpeed       : undefined,    // if we want to play the animation faster (>1) or slower (<1)\n                loop                : false,        // will repeat the whole animation. If it have separate operations\n                                                    // with different time the shorter ones will wait at the end key frame\n                                                    // until the longest is done. onStart & onEnd will not be called every\n                                                    // loop (if that is needed, set callbacks on key frames instead).\n                                                    // Will also wait for all it's children to complete.\n                readyToLoop         : false,        // since we sometime need to wait for our children we use this to know\n                                                    // when we can loop back to the start.\n                onStart             : undefined,    // callback before the animation starts\n                onEnd               : undefined,    // callback when the animation is complete\n                onUpdate            : undefined,    // callback on every frame before the operation run. Will be\n                                                    // called regardless if the holder have operation, target etc or not\n                children            : [],           // so we can nestle animation\n                parent              : undefined,    // a reference to the holders parent\n                localTime           : 0,            // local time counter\n                delay               : 0,            // time before the operations start after the animation starts\n                startTimeOffset     : undefined,    // if we want the animation to start at a specific time\n                //operations          : {},           // the operations the holder preforms\n                //operationSteps      : {},           // the current key frame for every operation\n                //operationsEnded     : false,        // if all the operations are done\n                addToAnimationLoop  : false         // adding the holder to the animation loop on creation\n            };\n\n        config = Sys.applyProperties(defaultProp, config);\n\n        // Parse the config, this allows us to use several config syntax\n        config = me.parseConfig(config);\n\n        me = Sys.applyProperties(me, config);\n\n        //// Set the default parameters needed by the operations\n        //me.setOperationDefaultProperties();\n\n        if ( config.addToAnimationLoop ){\n            animationBuffer.push(me);\n        }\n\n    }\n\n    /**\n     * Parse the config so that it matches the actual object properties.\n     *\n     * @param config\n     * @return {Object} The parsed properties\n     */\n    parseConfig  (config) {\n        var properties = {\n                animation : {\n                    keyFrames : [],\n                    step : 0,\n                    complete : false\n                }\n            },\n            //operations = Object.keys(Animation.Operations),\n            timeSort = function (a, b) {\n                return (a.time - b.time);\n            },\n            obj;\n\n        // Process all keys on the config object\n        Sys.iterate(config, function(key, value){\n\n            // If we have an animation, parse it\n            if (key === \"animate\" ) {\n\n                /*DEBUG_START*/\n                if ( key !== \"animate\" ){\n                    // TODO: right now we only support the \"animate\" operation, when we need more we have to make them.\n                    console.warn(\"You are trying to use a \" + key + \" operation on a Animation.Holder, for now only 'animate' is supported\");\n                }\n                /*DEBUG_END*/\n\n                // if the operation is an array or object\n                if ( Sys.isObj(value) ){\n\n                    Sys.iterate(value, function(time, frameValue){\n                        // Define the frame object with the time value\n                        obj = { time : parseInt(time, 10) };\n\n                        // If the frame is an object with a defined value then we have non value properties mixed in\n                        if (Sys.isObj(frameValue) ) {\n                            if ( Sys.isDefined(frameValue.value) ){\n                                obj = Sys.applyProperties(obj, frameValue);\n                            }\n                            else {\n                                obj.value = frameValue;\n                            }\n                        }\n                        // Otherwise it is just a plain value\n                        else {\n                            obj.value = frameValue;\n                            /*DEBUG_START*/\n                            if ( !Sys.isDefined(config.prop) && config.length > 1 ){\n                                console.warn(\"If we only specify a number value the property 'prop' must exist\");\n                            }\n                            /*DEBUG_END*/\n                        }\n\n                        // Push the key frame\n                        properties.animation.keyFrames.push(obj);\n                    });\n\n                    properties.animation.keyFrames.sort(timeSort);\n                }\n                else if ( Sys.isArray(value) ){\n                    // the operation is already in the right format, add it to the operations object\n                    properties.animation.keyFrames = value;\n                }\n                else {\n                    // error\n                    console.warn(\"Operation is in wrong format\");\n                }\n            }\n            // Else assign the value\n            else {\n                properties[key] = value;\n            }\n        });\n\n        // if target is undefined use the parents target (if it exist)\n        if ( !Sys.isDefined(properties.target) && Sys.isDefined(properties.parent) && Sys.isDefined(properties.parent.target) ){\n            properties.target = properties.parent.target;\n        }\n\n        /*DEBUG_START*/\n        if ( Sys.isDefined(properties.target) && !Sys.isObj(properties.target) ){\n            console.warn(\"The target of a Animation.Holder must be a Object\");\n        }\n        /*DEBUG_END*/\n\n        // if the id is undefined use the targets id (if it exist) and the operation type\n        if ( !Sys.isDefined(properties.id) && Sys.isDefined(properties.target) && Sys.isDefined(properties.target.id) ){\n            var prop = Sys.isDefined(properties.prop) ? properties.prop : \"\";\n\n            properties.id = properties.target.id + \":\" + prop + \"Animation\";\n        }\n\n        // if we already have children in the config, create them and add them\n        if ( Sys.isDefined(properties.children) && properties.children.length > 0 ){\n            var tempChildrenContainer = [],\n                parent = this;\n\n            properties.children.forEach(function(child){\n                var animation;\n\n                if ( Sys.isDefined(child.localTime) ){\n                    // the child is already a AnimationHolder\n                    animation = child;\n                }\n                else {\n                    child.parent = {target : config.target};\n                    animation = new AnimationHolder(child);\n                }\n                animation.parent = parent;\n                tempChildrenContainer.push( animation );\n            });\n\n            properties.children = tempChildrenContainer;\n        }\n\n        return properties;\n    }\n\n    /**\n     * Run the holder and it's children\n     *\n     * @param {Object} timeObj The object containing the time\n     */\n    run (timeObj) {\n        var me = this,\n            timeStep = timeObj.timeStep;\n\n        if (me.localTime === 0 && Sys.isDefined(me.startTimeOffset) ){\n            // if this is the first frame of the animation and we have a start offset\n            timeStep += me.startTimeOffset;\n        }\n\n        if ( Sys.isDefined(me.playbackSpeed) ){\n            // adjust the time step based on playback speed\n            timeStep *= me.playbackSpeed;\n        }\n\n        me.localTime += timeStep; // increase the local timer\n\n        if(me.localTime >= me.delay) {\n\n            // Time step is used to keep track of internal timers on the operation level\n            me.doAnimation(timeStep);\n\n            me.children.forEach(function(child){\n                if ( child.running ){\n                    child.run({timeStep : timeStep, time : timeObj.time});\n\n                    // if the child is still running\n                    if ( child.running ){\n                        // we should also be running\n                        me.running = true;\n\n                        if ( !child.loop && !child.readyToLoop ){\n                            // if it's time for us to loop, wait until the children are done\n                            // but don't wait on looping children\n                            me.readyToLoop = false;\n                        }\n                    }\n                }\n            });\n\n            if ( Sys.isDefined(me.onUpdate) ){\n                me.onUpdate(timeStep);\n            }\n        }\n\n        if ( me.loop && me.readyToLoop ){\n            // meaning I'm done and all my children are done (ignoring children that are looping)\n            me.restoreOnLoop();\n        }\n        else if ( !me.running ){\n            // this animation is done\n            if ( Sys.isDefined(me.onEnd) ){\n                me.onEnd();\n            }\n\n            // restore the animation on completion so we can start it from the beginning on the next play()\n            me.restore();\n        }\n    }\n\n    /**\n     * Runs each animation operation that is set for the holder\n     *\n     * @private\n     * @param {Number} currentStepTime the current time step\n     */\n    doAnimation (currentStepTime) {\n        var me = this,\n            numKeyFrames = me.animation.keyFrames.length;\n\n        // If we don't have any keyFrames or target just return\n        if (numKeyFrames < 2 || !Sys.isDefined(me.target) ) {\n            me.readyToLoop = true;\n            me.running = false;\n            return;\n        }\n\n        // Check if the animation have finished\n        var running = me.performAction(currentStepTime);\n\n        if (!running) {\n            // all the operations are done\n            me.running = false;\n            me.readyToLoop = true;\n        }\n    }\n\n    /**\n     * Play the animation\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to play. If none is\n     * specified (or true) we play all the children. If you send in an empty array [] we'll only play the current.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    play (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.running = true;\n\n        me.handleItems(\"play\", children);\n\n        if (me.localTime === 0 && Sys.isDefined(me.onStart)){\n            // if we start the game from the beginning do the onStart callback\n            me.onStart();\n        }\n\n        // make sure the parents are running\n        if (isRoot){\n            me.runParent();\n        }\n    }\n\n    runParent (){\n        var me = this;\n\n        if ( Sys.isDefined(me.parent) ){\n            me.parent.running = true;\n\n            me.parent.runParent();\n        }\n    }\n\n    /**\n     * Pause the animation\n     *\n     * @param {Array} [children] An array with children that we want to pause. If none is\n     * specified we pause all the children. If you send in an empty array [] we'll only pause the current holder.\n     */\n    pause (children) {\n        this.running = false;\n\n        this.handleItems(\"pause\", children);\n    }\n\n    /**\n     * Stop the animation and reset it to the beginning. Will do it for all the children as well\n     *\n     * @param {Array} [children] An array with children that we want to stop. If none is\n     * specified we stop all the children. If you send in an empty array [] we'll only stop the current.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    stop (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.running = false;\n\n        me.handleItems(\"stop\", children);\n\n        if ( isRoot ){\n            me.restore(children, true);\n        }\n    }\n\n    /**\n     * Restores the basic properties of the holder in order to run it again.\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to restore. If none is\n     * specified (or true) we restore all the children. If you send in an empty array [] we'll only restore the current holder.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    restore (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.localTime = 0;\n        me.readyToLoop = false;\n\n        me.restoreAnimation();\n\n        me.handleItems(\"restore\", children);\n\n        // if we are already running and are the root object we play()\n        if ( me.running && isRoot ){\n            me.play(children, true);\n        }\n    }\n\n    /**\n     * Restores the basic properties of the holder in order to run it again.\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to restore. If none is\n     * specified (or true) we restore all the children. If you send in an empty array [] we'll only restore the current holder.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    restoreOnLoop (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        if ( isRoot || !me.loop ){\n            me.running = true;\n            //me.localTime = 0;\n            me.readyToLoop = false;\n\n            me.restoreAnimation();\n\n            me.handleItems(\"restoreOnLoop\");\n        }\n    }\n\n    restoreAnimation (){\n        this.animation.time = 0;\n        this.animation.step = 0;\n\n        this.animation.keyFrames.forEach(function(key){\n            if (Sys.isDefined(key.callback)) {\n                key.callbackCompleted = false;\n            }\n\n            // add more stuff\n        });\n    }\n\n    /**\n     * @private\n     * Update the holder with the operation configuration\n     *\n     * @param {Object} config The configuration\n     */\n    updateOperation (config) {\n        var me = this,\n            obj = {};\n\n        //me.applyDefaultValuesToItem(me);\n\n        obj.animate = config;\n\n        obj = me.parseConfig(obj);\n\n        me.animation = obj.animation;\n        //me.applyDefaultValuesToOperation(me);\n\n        me.restore();\n    }\n\n    /**\n     * @private\n     * Call the specified function on all the items\n     *\n     * @param {String} type The function to call on the items\n     * @param {Array} [selection] The optional array of items to handle\n     */\n    handleItems (type, selection){\n        var items = (Sys.isDefined(selection) && Sys.isArray(selection)) ? selection : this.children;\n\n        items.forEach(function(child){\n            child[type](true, false);\n        });\n    }\n\n    setParent (parent){\n        this.parent = parent;\n        parent.children.push(this);\n\n        // if you don't have a target, use the parents\n        if ( !Sys.isDefined(this.target) ){\n            this.target = parent.target;\n        }\n    }\n\n    addChild (children){\n        var me = this;\n\n        if (Sys.isArray(children) ){\n            children.forEach(function(child){\n                child.setParent(me);\n            });\n        }\n        else if (Sys.isObj(children)){\n            children.setParent(me);\n        }\n    }\n\n    /**\n     * Will search children (and grandchildren) for a Holder that mach the key and value provide.\n     *\n     * NOTE: if there is more than one match you will get the first one.\n     *\n     * @param {String} value The value that should match\n     * @param {String} [byKey] Which property key we should check against, default \"id\"\n     *\n     * @return {object|boolean} the items that match our search criteria, or false if it didn't find anything\n     */\n    findChild (value, byKey){\n        var key = Sys.isDefined(byKey) ? byKey : \"id\",\n            item = false,\n            searchChildren = function(items) {\n                var result = false,\n                    subResult = false;\n\n                items.forEach(function(item){\n                    if ( Sys.isDefined(item[key]) && item[key] === value ){\n                        result = item;\n                    }\n\n                    if ( Sys.isDefined(item.children) ){\n                        subResult = searchChildren(item.children);\n\n                        if ( Sys.isObj(subResult) ){\n                            result = subResult;\n                        }\n                    }\n                });\n\n                return result;\n            };\n\n        // start with the main Holder\n        if ( this[key] === value ){\n            return this;\n        }\n\n        if ( Sys.isDefined(this.children) ){\n            item = searchChildren(this.children );\n        }\n\n        return item;\n    }\n\n    /**\n     * Performs the specified action on a given object.\n     *\n     * @param {Number} currentStepTime The time since the last render (ms)\n     */\n    performAction (currentStepTime) {\n        var me = this,\n            animation = me.animation,\n            keyFrames = animation.keyFrames,\n            numKeyFrames = keyFrames.length,\n            currentTime = me.increaseAnimationTime(currentStepTime),\n            currentKeyFrame = keyFrames[animation.step],\n            nextKeyFrame = keyFrames[animation.step + 1],\n            running = true;\n\n        /*DEBUG_START*/\n        if ( numKeyFrames < 2 ){\n            console.warn(\"The Holder \" + item + \" have an animation with less than two keyFrames, the operation needs a minimum of two keyFrames to be able to animate.\");\n            return 0;\n        }\n        /*DEBUG_END*/\n\n        me.handleCallback(currentKeyFrame); // added an extra callback check here to make sure callbacks on keyFrame 0 are fired\n\n        // step through keyFrames, from oldKeyFrameIndex, until we are on the current one\n        // loop if necessary\n        // fire events and callbacks on every new keyFrame we pass\n        // goTo keyFrames\n\n        // check if we have passed the next keyFrame\n        if ( nextKeyFrame.time <= currentTime){\n            me.progressKeyFrame();\n\n            currentKeyFrame = keyFrames[animation.step];\n\n            // are we at the last keyFrame, ie we're not looping and the animation is complete\n            if ( animation.step === numKeyFrames - 1 ){\n                nextKeyFrame = currentKeyFrame;\n                running = false;\n            }\n            else {\n                nextKeyFrame = keyFrames[animation.step + 1];\n            }\n        }\n\n        // when we have the current keyFrame, interpolate between that and the next keyFrame\n        me.calculate(animation.time, currentKeyFrame, nextKeyFrame);\n\n        return running;\n    }\n\n    progressKeyFrame (toIndex){\n        var me = this,\n            animation = me.animation,\n            keyFrames = animation.keyFrames,\n            currentKeyFrame;\n\n        // step to next keyFrame\n        animation.step = Sys.isDefined(toIndex) ? toIndex : animation.step + 1;\n\n        // do events and callbacks\n        currentKeyFrame = keyFrames[animation.step];\n        me.handleCallback(currentKeyFrame);\n\n        // check for goTo\n        if ( Sys.isDefined(currentKeyFrame.goTo) ) {\n            me.doGoTo(currentKeyFrame);\n        }\n\n        // if we haven't reached the last keyFrame\n        if ( animation.step !== keyFrames.length - 1 ){\n            // check if we should move one more\n            if ( animation.time >= keyFrames[animation.step + 1].time){\n                me.progressKeyFrame();\n            }\n        }\n        else if ( me.loop  ){ // at the last keyFrame and we're looping\n            animation.time -= keyFrames[animation.step].time;\n            me.progressKeyFrame(0);\n        }\n\n    }\n\n    doGoTo (keyFrame){\n        var me = this;\n\n        me.animation.time = me.animation.keyFrames[keyFrame.goTo].time;\n        me.animation.step = keyFrame.goTo;\n\n        /*DEBUG_START*/\n        console.warn(\"Warning: goTo functionality not completed, use at own risk.\");\n        // TODO: fix goTo, callback resets when going back and callback firing when going forward etc.\n        /*DEBUG_END*/\n    }\n\n    /**\n     * Calculates the time steps and sets the values that should be interpolated.\n     *\n     * @protected\n     * @param {Number} currentTime The current time step\n     * @param {Object} currentStep The current frame\n     * @param {Object} nextStep The next frame\n     */\n    calculate (currentTime, currentStep, nextStep) {\n        var me = this,\n            time = me.calculateTime(currentTime, currentStep, nextStep),\n            from = currentStep.value,\n            to = nextStep.value,\n            target;\n\n        if ( Sys.isObj(from) ){\n            Sys.iterate(from, function(key, value){\n                target = Sys.isDefined(me.prop) ? me.target[me.prop] : me.target;\n\n                target[key] = Animation.utils.getInterpolationValue(value, to[key], time, currentStep.ease, key);\n            });\n        }\n        else { // we only animate one number\n            me.target[me.prop] = Animation.utils.getInterpolationValue(from, to, time, currentStep.ease);\n        }\n    }\n\n    /**\n     * @private\n     * @param {Object} currentKeyFrame The object holding the current key frame information\n     */\n    handleCallback (currentKeyFrame) {\n        var callback = currentKeyFrame.callback,\n            container;\n\n        if(Sys.isDefined(callback) && !currentKeyFrame.callbackCompleted) {\n\n            if ( callback.fireImmediately ){\n                if ( Sys.isString(callback.func) ){\n                    // an event\n                    callback.scope.fireEvent(callback.func, callback.args);\n                }\n                else if ( Sys.isFunc(callback.func) ){\n                    // a function\n                    callback.func.apply(callback.scope, callback.args);\n                }\n            }\n            else {\n                container = Game.stage.view.animationManager.callbackContainer;\n                container.push(callback);\n            }\n\n            currentKeyFrame.callbackCompleted = true;\n        }\n    }\n\n    /**\n     * Calculates the time vars.\n     *\n     * @private\n     * @param {Number} currentTime The current time step\n     * @param {Object} currentStep The current frame\n     * @param {Object} nextStep The next frame\n     */\n    calculateTime (currentTime, currentStep, nextStep) {\n        var timeStep = currentTime - currentStep.time,\n            totalTime = nextStep.time - currentStep.time;\n\n        //If timeStep equals 0 and totalTime equals 0. The result will be NaN\n        return totalTime !== 0 ? timeStep / totalTime : 1;\n    }\n\n\n    /**\n     * Increase the timeBuffer\n     *\n     * @param {Number} time The time the time buffer should be increased\n     */\n    increaseAnimationTime  (time) {\n        if (!Sys.isDefined(this.animation.time)) {\n            this.animation.time = time;\n        }\n        else {\n            this.animation.time += time;\n        }\n\n        return this.animation.time;\n    }\n\n    animate (config, play) {\n        this.updateOperation(config);\n        if ( play ){\n            this.play();\n        }\n    }\n\n}","import {BonusWheelItem} from \"./BonusWheelItem\";\nimport {AnimationHolder} from \"./AnimationHolder\";\n\nconst CIRCLE_DEG = 360;\n    //the minimum difference (angle) between current wheel stop and previous wheel stop:\nconst MIN_DIFF = 270;\nconst START_BOUNCE = {\n    //negative value, since the wheel moves backwards\n    maxSpeed: -0.5,\n        //time fraction of the whole acceleration time\n        timeFraction: 1/500\n};\n\nconst WHEEL_ITEMS_CENTER_OFFSET = 300;\nconst WHEEL_ITEM_CONFIG = {\n    width: 100,\n    height: 100\n};\n\nexport class BonusWheel extends PIXI.Container {\n    \n    constructor (config, onStartBounceCompleteCallback, app) {\n        super();\n        var me = this;\n\n        me.sectorItemsList = config.sectorItemsList;\n\n        me.background = me._initBackground(me, \"wheel_bg\");\n\n        me._initBgSpine(me, \"glow\", app);\n\n        me.background.anchor.set(0.5,0.5);\n\n        //degrees per frame\n        me.maxSpeed = config.maxSpeed;\n        me.minSpeed = config.minSpeed;\n\n        me.sprite = me._initWheelSprite(me, \"wheelWin\");\n        me.wheelItems = me._initWheelItems(me.sprite);\n\n        //will be added to a separate spine slot:\n        me.highlightSprite = typeof config.image !== \"undefined\" ? me._initSprite(config.image, PIXI.BLEND_MODES.ADD) : me._initEmptySprite();\n        me.sectorsAngles = me._mapSectorsAgles(config.sectors);\n        me.animations = me._initAnimations(config);\n        me.onStartBounceCompleteCallback = onStartBounceCompleteCallback;\n        me.config = config;\n\n        me.pick = me._initPickSprite(me);\n        me.gift = me._initGiftSprite(me, \"SYM0\");\n\n        me.reset();\n        me.refresh();\n    }\n\n    _initBackground (container, imageName) {\n        return container.addChild(new PIXI.Sprite.fromImage(\"assets/images/\"+imageName+\".jpg\"))\n    }\n\n    _initBgSpine (container, spineName, app) {\n        var me = this,\n            glow;\n\n        PIXI.loader\n            .add('glow', 'assets/spine/glow.json')\n            .load(onAssetsLoaded);\n\n        function onAssetsLoaded(loader,res) {\n            // instantiate the spine animation\n            glow = new PIXI.spine.Spine(res.glow.spineData);\n            glow.skeleton.setToSetupPose();\n            glow.update(0);\n            glow.autoUpdate = false;\n\n            me.background.addChild(glow);\n\n            // once position and scaled, set the animation to play\n            glow.state.setAnimation(0, 'spin', true);\n            app.ticker.add(function() {\n                glow.update(0.02);\n            });\n\n            glow.visible = false;\n            me.bgAnimation = glow;\n        }\n\n    }\n\n    _initWheelSprite (container, imageName) {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/\"+imageName+\".png\");\n        sprite.anchor.set(0.5, 0.5);\n        container.addChild(sprite);\n\n        return sprite;\n    }\n\n    /**\n     * Adds wheel items - sprites that rotate together with the wheel\n     *\n     * @param {PIXI.Container|PIXI.Sprite} parent - wheelItems will be added here\n     * @returns {Array<S.BonusWheelItem>}\n     * @private\n     */\n    _initWheelItems(parent){\n        var me = this,\n            sizedContainer,\n            bonusWheelItem,\n            whellItems = [];\n\n        me.sectorItemsList.forEach(function (item, index) {\n            sizedContainer = new PIXI.Container();\n\n            bonusWheelItem = new BonusWheelItem({\n                parent: sizedContainer,\n                texture: new PIXI.Texture.fromImage(\"assets/images/prizes/\" + item + \".png\"),\n                sectorIndex: index,\n                centerOffset: WHEEL_ITEMS_CENTER_OFFSET,\n                totalSectorsNum: me.sectorItemsList.length\n            });\n\n            bonusWheelItem.width = WHEEL_ITEM_CONFIG.width;\n            bonusWheelItem.height = WHEEL_ITEM_CONFIG.height;\n\n            parent.addChild(sizedContainer);\n            whellItems.push(bonusWheelItem);\n        });\n\n        return whellItems;\n    }\n\n    _initPickSprite (container) {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/pick.png\");\n        sprite.anchor.set(0.5, 0.5);\n        container.addChild(sprite);\n        sprite.position.y = -460;\n\n        return sprite;\n    }\n\n    _initGiftSprite (container, imageName) {\n        var sprite = this._initSprite(imageName, PIXI.BLEND_MODES.NORMAL);\n\n        container.addChild(sprite);\n        sprite.width = 100;\n        sprite.height = 100;\n        sprite.position.y = -250;\n        sprite.visible = false;\n        sprite.animation = new AnimationHolder({\n            addToAnimationLoop: true,\n            target: sprite,\n            children: [\n                {\n                    prop: \"position\",\n                    animate: {\n                        200: {y: -(WHEEL_ITEMS_CENTER_OFFSET)},\n                        1500: {y: 0},\n                        5000: {y: 0},\n                        5500: {y: -(WHEEL_ITEMS_CENTER_OFFSET)},\n                    }\n                },\n                {\n                    prop: \"width\",\n                    animate: {\n                        200: WHEEL_ITEM_CONFIG.width,\n                        1500: WHEEL_ITEM_CONFIG.width * 3,\n                        5000: WHEEL_ITEM_CONFIG.width * 3,\n                        5500: WHEEL_ITEM_CONFIG.width\n                    }\n                },\n                {\n                    prop: \"height\",\n                    animate: {\n                        200: WHEEL_ITEM_CONFIG.height,\n                        1500: WHEEL_ITEM_CONFIG.height * 3,\n                        5000: WHEEL_ITEM_CONFIG.height * 3,\n                        5500: WHEEL_ITEM_CONFIG.height\n                    }\n                }\n            ]\n        });\n\n        return sprite;\n    }\n\n    /**\n     *\n     * @param animSprite - win presentation sprite\n     * @private\n     */\n    _onWinAnimationComplete(animSprite){\n        animSprite.visible = false;\n        this.wheelItems.forEach(function(wheelItem){\n            wheelItem.show();\n        });\n        this.bgAnimation.visible = false;\n    }\n\n    _initSprite (imageName, blendMode) {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/prizes/\"+imageName+\".png\");\n\n        sprite.anchor.set(0.5, 0.5);\n        sprite.blendMode = blendMode;\n\n        return sprite;\n    }\n\n    _initEmptySprite () {\n        return new PIXI.Sprite(PIXI.Texture.EMPTY);\n    }\n\n    /**\n     * @param {Array} sectorsNames - list of sectors names on the wheel\n     * @returns {Object} sectorsAngles - config with all the sectors mapped to angles of wheel rotation\n     */\n    _mapSectorsAgles (sectorsNames) {\n        var sectorsNumber = sectorsNames.length,\n            degreesPerSector = CIRCLE_DEG / sectorsNumber,\n            sectorsAngles = {};\n\n        sectorsNames.forEach(function (sectorName, index) {\n            //forced to use array of angles, since we might have multiple sectors for one value\n            //for instance, the key wheel has 6 sectors with 0 and 2 sectors with 1\n            if(!sectorsAngles[sectorName]){\n                sectorsAngles[sectorName] = [];\n            }\n            sectorsAngles[sectorName].push(degreesPerSector * index);\n        });\n\n        return sectorsAngles\n    }\n\n    /**\n     * These are not \"animations\" in common understanding of the Animation.Holder, they are rather tickers,\n     * that perform certain update functions on every frame\n     *\n     * @param {Object} config - wheel config\n     * @returns {Object} list of all available animations\n     */\n    _initAnimations (config) {\n        return {\n            \"accelerationTicker\": this._initAccelerationTicker(config.accelerationDuration),\n            \"uniformRotationTicker\": this._initUnformRotationTicker(),\n            \"decelerationTicker\": this._initDecelerationTicker()\n        }\n    }\n\n    /**\n     * @param {number} accelerationTime - time it will take to accelerate from 0 to maximum speed\n     * @returns {Object} animation holder that gradually(with easing) increases currentSpeed\n     * that will be used in _updateSpriteAngle on each frame for smooth wheel start\n     */\n    _initAccelerationTicker (accelerationTime) {\n        var me = this;\n\n        return new AnimationHolder({\n            target: me,\n            prop: \"currentSpeed\",\n            onUpdate: me._updateSpriteAngle.bind(me),\n            onEnd: me.startUniformRotation.bind(me),\n            animate: [\n                {\n                    time: 0,\n                    value: 0,\n                    ease: Animation.utils.powerTwoOut\n                },\n                //the wheel bounce back on start:\n                {\n                    time: accelerationTime * START_BOUNCE.timeFraction,\n                    value: START_BOUNCE.maxSpeed,\n                    ease: Animation.utils.powerTwoIn\n                },\n                {\n                    time: accelerationTime,\n                    value: me.maxSpeed\n                }\n            ],\n            addToAnimationLoop: true\n        });\n    }\n\n    /**\n     * @returns {Object} animation holder that calls _updateSpriteAngle on every frame\n     * by this moment, the speed reaches maximum value, so this spins the wheel uniformly\n     */\n    _initUnformRotationTicker () {\n        var me = this;\n\n        return new AnimationHolder({\n            onUpdate: me._updateSpriteAngle.bind(me),\n            addToAnimationLoop: true,\n            loop: true\n        });\n    }\n\n    /**\n     * @returns {Object} animation holder that calls decelerateRotation on every frame and smoothly stops the wheel\n     */\n    _initDecelerationTicker () {\n        var me = this;\n\n        return new AnimationHolder({\n            addToAnimationLoop: true,\n            onUpdate: me.decelerateRotation.bind(me),\n            loop: true\n        });\n    }\n\n    startUniformRotation () {\n        var me = this;\n        //resolving promise (there's no callback on restore):\n        me.onWheelStartCallback && me.onWheelStartCallback();\n        //in regular case it would've reached maxSpeed naturally by this moment, but on restores we're forced to set it manually:\n        me.currentSpeed = me.maxSpeed;\n        me.animations.uniformRotationTicker.play();\n    }\n\n    /**\n     *  decreases currentSpeed depending on currentAngle relative to finalAngle\n     *  the closer we are to the finalAngle the slower we go\n     *  calls _updateSpriteAngle to apply new speed\n     */\n    decelerateRotation () {\n        var me = this,\n            currentAngle = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            distanceLeft = me.finalAngle - currentAngle,\n            maxSpeedFraction = distanceLeft / me.stoppingDistance,\n            timePassedFromStart = 1 - maxSpeedFraction;\n\n        me.currentSpeed = Animation.utils.powerTwoIn(me.maxSpeed, 0, timePassedFromStart);\n\n        //proceed with uniform rotation if the speed might become too low:\n        if (me.currentSpeed < me.minSpeed) {\n            me.currentSpeed = me.minSpeed;\n        }\n\n        me._updateSpriteAngle();\n    }\n\n    /**\n     *  Changes the sprite angle by adding currentSpeed to it, stops the deceleration ticker if reached final angle\n     */\n    _updateSpriteAngle () {\n        var me = this,\n            currentRotation = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            timeScale = me.getTimeScale(),\n            newRawRotation = currentRotation + me.currentSpeed * timeScale,\n            newRotation;\n\n        //startBounce completion condition:\n        if(me.prevFrameSpeed < 0 && me.currentSpeed > 0){\n            me.onStartBounceCompleteCallback(me.config.name);\n        }\n\n        if (newRawRotation >= me.finalAngle) {\n            newRotation = me.finalAngle;\n            me.currentSpeed = 0;\n            me.animations.decelerationTicker.stop();\n\n            //resolving promise:\n            me.onWheelStopped();\n        } else {\n            newRotation = newRawRotation;\n        }\n\n        me.sprite.rotation = newRotation * PIXI.DEG_TO_RAD;\n        me.highlightSprite.rotation = me.sprite.rotation;\n        me.prevFrameSpeed = me.currentSpeed;\n    }\n\n    /**\n     *  Returns timescale coefficient to adjust the animation duration on low FPS\n     *\n     *  @returns {number} - deltaTime correction coefficient\n     */\n    getTimeScale () {\n        var me = this,\n            //todo: remove before release:\n            timeScale = 1.5,\n            oneFrameDuration = 1000/60,\n            now = Date.now(),\n            prev = me.lastTick ? me.lastTick : now - oneFrameDuration;\n\n        me.lastTick = now;\n\n        //todo: remove before release:\n        return (now - prev) * timeScale/oneFrameDuration;\n    }\n\n    start (callback) {\n        this.onWheelStartCallback = callback;\n        this.animations.accelerationTicker.play();\n\n\n    }\n\n    startDeceleration (prevWheelStoppingDistance, onWheelStopped) {\n        var me = this;\n\n        me.onWheelStopped = onWheelStopped;\n        me.animations.uniformRotationTicker.stop();\n        me._updateStoppingDistance(prevWheelStoppingDistance);\n        me.animations.decelerationTicker.play();\n\n        this.bgAnimation.visible = true;\n        this.bgAnimation.state.setAnimation(0, 'spin', true);\n    }\n\n    /**\n     *  updates distance to the destination point and final sprite angle at the moment of stopping\n     *  depending on currentAngle, stopAngle and prevWheelStoppingDistance\n     *\n     *  @param {number} prevWheelStoppingDistance - distance, the previous wheel has to cover before full stop\n     */\n    _updateStoppingDistance (prevWheelStoppingDistance) {\n\n        var me = this,\n            currentAngle = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            //using % me.CIRCLE_DEG here to simply calculations:\n            currentAngleReduced = currentAngle % CIRCLE_DEG,\n            angleToFullCircleLeft = CIRCLE_DEG - currentAngleReduced,\n            stopAngle = me.getStoppingAngle(),\n            minDistanceToTarget = angleToFullCircleLeft + stopAngle,\n            //number of 360 degrees wheel revolutions before stop\n            revolutionsBeforeStop = me.getRevolutionsBeforeStop(minDistanceToTarget, prevWheelStoppingDistance);\n\n        me.stoppingDistance = minDistanceToTarget + revolutionsBeforeStop * CIRCLE_DEG;\n        me.finalAngle = currentAngle + me.stoppingDistance;\n    }\n\n    /**\n     * Calculates the number of extra revolutions to make depending on previous wheel stopping distance\n     * (current wheel distance should always be greater than the previous one)\n     *\n     * @param {number} minDistanceToTarget - minimum possible distance between current and final angles\n     * @param {number} prevWheelStoppingDistance - distance the previous wheel will cover before full stop\n     * @returns {number} spinsBeforeStop - number of extra revolutions before full stop\n     */\n    getRevolutionsBeforeStop (minDistanceToTarget, prevWheelStoppingDistance) {\n        var me = this,\n            revsBeforeStop = 0,\n            targetDistance = prevWheelStoppingDistance + MIN_DIFF,\n            currentValue = minDistanceToTarget;\n        \n        while(currentValue < targetDistance){\n            revsBeforeStop++;\n            currentValue = minDistanceToTarget + CIRCLE_DEG * revsBeforeStop;\n        }\n\n        revsBeforeStop = Math.max(revsBeforeStop, me.config.minimumSpinsBeforeStop);\n\n        return revsBeforeStop;\n    }\n\n    /**\n     * Randomly selects from all available sectors angles for itemToStopOn\n     * (for instance, out of 6 options for 0 level on level wheel) and sets it as stopAngle\n     *\n     * @param {number | string} itemToStopOn - value on the sector whe wheel should stop on\n     * @returns {void}\n     */\n    setStoppingAngle (itemToStopOn) {\n        var me = this,\n            targetAngles = me.sectorsAngles[itemToStopOn],\n            targetAnglesCount = targetAngles.length,\n            randomAngleIndex = Math.floor(Math.random() * targetAnglesCount);\n\n        me.stopAngle = targetAngles[randomAngleIndex];\n    }\n\n    getStoppingAngle () {\n        return this.stopAngle;\n    }\n\n    getCurrentStoppingDistance () {\n        return this.stoppingDistance;\n    }\n\n    playGiftAnimation (name, onEndCallback) {\n        var me = this,\n            gift = me.gift,\n            totalSectorsNum = me.sectorItemsList.length,\n            currentItemIndex = Math.round( totalSectorsNum / CIRCLE_DEG * me.stopAngle),\n            currentWheelItem = me.wheelItems[currentItemIndex];\n\n        currentWheelItem.hide();\n\n        gift.texture = currentWheelItem.texture;\n        gift.visible = true;\n\n        gift.animation.onEnd = function () {\n            me._onWinAnimationComplete(gift);\n            onEndCallback();\n        };\n\n        gift.animation.play();\n\n        me.bgAnimation.state.setAnimation(0, 'win', true);\n    }\n\n    reset () {\n        var me = this;\n\n        me.stoppingDistance = Infinity;\n        me.finalAngle = Infinity;\n        me.sprite.rotation = 0;\n        me.currentSpeed = 0;\n        me.lastTick = 0;\n    }\n\n    startStopping () {\n        var me = this;\n\n        return new Promise(function (resolve) {\n            me.startDeceleration(0, function () {\n                resolve();\n            })\n        })\n    }\n\n    changeTexture (itemIndex, texture) {\n        this.wheelItems[itemIndex].texture = texture;\n    }\n\n    refresh () {\n        this.scale.set(window.innerHeight / 1080);\n    }\n\n}","export class BonusWheelItem extends PIXI.Sprite {\n    /**\n     *\n     * @param {object} config - wheelItem config\n     * @param {PIXI.Container|PIXI.Sprite} config.parent - Display object, the wheelItem will be added to\n     * @param {PIXI.Texture} config.texture - wheelItem texture\n     * @param {number} config.sectorIndex - sector the item is added to\n     * @param {number} config.centerOffset - distance from wheel center to wheelItem center\n     * @param {number} config.totalSectorsNum - total number of sectors on the parent wheel\n     */\n    constructor (config) {\n        super(config.texture);\n        config.parent.addChild(this);\n\n        this.anchor.set(0.5);\n        this.scale.set(config.scale);\n        this.updatePositionAndRotation(config.totalSectorsNum, config.sectorIndex, config.centerOffset);\n    }\n\n    /**\n     * Positions the item to the proper sector and rotates in a way that item's bottom is directed\n     * to the wheel center;\n     *\n     * @param {number} totalSectorsNum - total number of sectors on the parent wheel\n     * @param {number} sectorIndex - sector the item is added to\n     * @param {number} centerOffset - distance from wheel center to wheelItem center\n     */\n    updatePositionAndRotation(totalSectorsNum, sectorIndex, centerOffset){\n        var me = this,\n            angle = (2 * Math.PI / totalSectorsNum) * sectorIndex,\n            y = - centerOffset * Math.cos(angle),\n            x = - centerOffset * Math.sin(angle);\n\n        me.position.set(x, y);\n        me.rotation = -angle;\n    }\n\n    hide(){\n        this.visible = false;\n    }\n\n    show(){\n        this.visible = true;\n    }\n}","const CONFIG = {\n    x: 100,\n    y: 10\n};\n\nexport class FullScreenButton extends PIXI.Sprite {\n    constructor (config) {\n        super();\n\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/fullscreen.png\");\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.enterFullscreenMode = config.enterFullscreenMode;\n        this.exitFullscreenMode = config.exitFullscreenMode;\n\n        this.currentState = \"off\";\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"off\"){\n            this.currentState = \"on\";\n            this.enterFullscreenMode();\n        } else if (this.currentState === \"on\"){\n            this.currentState = \"off\";\n            this.exitFullscreenMode();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n}","const OFFSET = 10;\nconst TOP_OFFSET = 80;\n\nexport class Menu extends PIXI.Container{\n    constructor (config) {\n        super();\n\n        this.onItemImgChange = config.onItemImgChange;\n        this.onCountChange = config.onCountChange;\n\n        const input = document.createElement('input');\n        input.accept = \"image/*\";\n        input.id = \"inpt\";\n        input.type = \"file\";\n        input.onchange = this.updateImageLocally.bind(this);\n\n        document.body.appendChild(input);\n\n        const itemsListContainer = new PIXI.Container();\n        itemsListContainer.position.y = TOP_OFFSET;\n\n        const itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\"));\n        this.itemGroups = this.createItemsListInterface(itemsList, itemsListContainer);\n        this.addChild(itemsListContainer);\n\n        this.hideMenu();\n    }\n\n    onStorageUpdated () {\n        console.log(\"updating the storage\");\n        const itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\"));\n        this.itemGroups.forEach(function (item, index) {\n            item.countText.text = itemsList[index].count;\n        });\n\n    }\n\n    showMenu () {\n        this.visible = true;\n    }\n\n    hideMenu () {\n        this.visible = false;\n    }\n\n    createItemsListInterface (itemsList, parentContainer) {\n        var me = this,\n            itemGroup, itemGroups = [];\n\n        PIXI.loader\n            .load(\n                itemsList.forEach(function (item, itemIndex) {\n                    itemGroup = me.createItemContainer(parentContainer, item, itemIndex);\n                    itemGroups[itemIndex] = itemGroup;\n                })\n            );\n\n        return itemGroups;\n    }\n\n    createItemContainer (parentContainer, item, itemIndex) {\n        const itemContainer = new PIXI.Container();\n        let itemGroup = {};\n\n        itemGroup.button = this.addButton(itemContainer, item.name, itemIndex);\n        itemGroup.countText = this.addTxt(itemContainer, item.count);\n        itemGroup.buttons = this.addPlusMinusButtons(itemContainer, itemIndex, item.count);\n        itemContainer.position.set(OFFSET, (OFFSET * itemIndex) + (itemIndex * itemContainer.height));\n\n        this.addItemsListBg(itemContainer);\n\n        parentContainer.addChild(itemContainer);\n        return itemGroup;\n    }\n\n    addItemsListBg (container) {\n        var graphics = new PIXI.Graphics();\n\n        graphics.beginFill(0x3d5c5c);\n        graphics.lineStyle(2, 0xDE3249, 1);\n        graphics.drawRect(0, 0, container.width, container.height);\n        graphics.endFill();\n        graphics.blendMode = 2;\n\n        container.addChildAt(graphics, 0);\n    }\n\n    addButton (parentContainer, name, itemIndex) {\n        const me = this;\n        const texture = new PIXI.Texture.from(\"assets/images/prizes/\" + name + \".png\");\n        const itemImage = new PIXI.Sprite(texture);\n\n        itemImage.height = 50;\n        itemImage.width = 50;\n\n        itemImage.interactive = true;\n        itemImage.buttonMode = true;\n        itemImage.on('pointerdown', me.onItemClick.bind(me, itemImage, itemIndex));\n\n        parentContainer.addChild(itemImage);\n    }\n\n    addTxt (parentContainer, count) {\n        const style = new PIXI.TextStyle({\n                fill: '#d8df75',\n                fontSize: 15,\n                fontFamily: 'Arial'\n            }),\n            txt = new PIXI.Text(count, style);\n\n        txt.anchor.set(0.5);\n        txt.position.set(100, parentContainer.width / 2);\n\n        parentContainer.addChild(txt);\n        return txt;\n    }\n\n    addPlusMinusButtons (parentContainer, itemIndex) {\n        const me = this;\n        let buttons = {};\n\n        buttons.plusButton = me.initIncrementButton(\n            {\n                x: 160,\n                y: 0,\n                width: 20,\n                height: 20,\n                texture: new PIXI.Texture.from(\"assets/images/buttons/plus.png\"),\n                callback: me.onPlusButtonClick.bind(me, itemIndex),\n                parentContainer: parentContainer\n            });\n\n        buttons.minusButton = me.initIncrementButton(\n            {\n                x: 160,\n                y: 30,\n                width: 20,\n                height: 20,\n                texture: new PIXI.Texture.from(\"assets/images/buttons/minus.png\"),\n                callback: me.onMinusButtonClick.bind(me, itemIndex),\n                parentContainer: parentContainer\n            });\n\n        return buttons;\n    }\n\n    initIncrementButton (config) {\n        let button = new PIXI.Sprite(config.texture);\n\n        button.position.set(config.x, config.y);\n        button.interactive = true;\n        button.buttonMode = true;\n        button.width = config.width;\n        button.height = config.height;\n        button.on(\"pointerdown\", config.callback);\n        config.parentContainer.addChild(button);\n\n        return button;\n    }\n\n    onPlusButtonClick (itemIndex) {\n        let newCount = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count + 1;\n\n        this.onCountChange(itemIndex, newCount);\n        this.updateCountText(itemIndex, newCount);\n    }\n\n    onMinusButtonClick (itemIndex) {\n        const currentCount = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count;\n        let newCount;\n\n        if((currentCount - 1) <= 0){\n            newCount = 0;\n        } else {\n            newCount = currentCount - 1 ;\n        }\n\n        this.onCountChange(itemIndex, newCount);\n        this.updateCountText(itemIndex, newCount);\n    }\n\n    updateCountText (itemIndex, newCount) {\n        if(!newCount){\n            this.itemGroups[itemIndex].countText.text = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count;\n            return;\n        }\n        this.itemGroups[itemIndex].countText.text = newCount;\n    }\n\n    onItemClick (targetSprite, itemIndex) {\n        document.getElementById(\"inpt\").click();\n        this.targetSprite = targetSprite;\n        this.itemIndex = itemIndex;\n    }\n\n    updateImageLocally () {\n        var me = this,\n            file = document.getElementById(\"inpt\").files[0],\n            reader = new FileReader();\n\n        reader.onload = function () {\n            me.targetSprite.setTexture(new PIXI.Texture.from(reader.result));\n            me.onItemImgChange(me.itemIndex, new PIXI.Texture.from(reader.result));\n        };\n\n        if (file) {\n            reader.readAsDataURL(file);\n        }\n\n    }\n\n\n}","const CONFIG = {\n    x: 10,\n    y: 10\n};\n\nexport class OpenCloseButton extends PIXI.Sprite{\n\n    constructor (config) {\n        super();\n\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.openCallback = config.openCallback;\n        this.closeCallback = config.closeCallback;\n\n        this.currentState = \"closed\";\n        this.setClosedTexture();\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"closed\"){\n            this.currentState = \"opened\";\n            this.setOpenedTexture();\n            this.openCallback();\n        } else if (this.currentState === \"opened\"){\n            this.currentState = \"closed\";\n            this.setClosedTexture();\n            this.closeCallback();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n\n    setClosedTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/settings.png\")\n    }\n\n    setOpenedTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/error.png\")\n    }\n\n    onForseClosed () {\n        this.currentState = \"closed\";\n        this.setClosedTexture();\n        this.closeCallback();\n    }\n}","export class ScrollContainer extends PIXI.Container{\n    constructor(x, y, width, height, itemHeight) {\n        super();\n\n        this.po = new PIXI.Container();\n        this.scrollContainer = new PIXI.Container();\n        this.po.addChild(this.scrollContainer);\n        this.items = [];\n        this.x = x;\n        this.y = y;\n\n        this.scrollContainer.x = x;\n        this.scrollContainer.y = y;\n        this.height = height;\n        this.itemHeight = itemHeight;\n\n        this.mask = new PIXI.Graphics();\n        this.mask\n            .beginFill(0xFFFFFF)\n            .drawRect(x, y, width, height)\n            .endFill();\n\n        this.po.addChild(this.mask);\n        this.scrollContainer.mask = this.mask;\n\n        this.mousedown = false;\n        this.lastPos = null;\n        this.lastDiff = null;\n        this.scrollTween = null;\n\n        this.po.interactive = true;\n        this.po.mousemove = e => this.onmousemove(e);\n        this.po.mousedown = e => this.onmousedown(e);\n        this.po.mouseup = e => this.onmouseup(e);\n        this.po.mouseupoutside = e => this.onmouseup(e);\n        this.po.touchmove = e => this.onmousemove(e);\n        this.po.touchstart = e => this.onmousedown(e);\n        this.po.touchend = e => this.onmouseup(e);\n        this.po.touchendoutside = e => this.onmouseup(e);\n    }\n\n    onmousemove(e) {\n        const { originalEvent } = e.data;\n        var clientY = !originalEvent.touches ? originalEvent.clientY : originalEvent.touches[0].clientY;\n\n        if (this.mousedown) {\n            this.lastDiff = clientY - this.lastPos.y;\n            this.lastPos.y = clientY;\n\n            if (-this.scrollContainer.y < 0) {\n                this.scrollContainer.y += this.lastDiff / 2;\n            } else {\n                this.scrollContainer.y += this.lastDiff;\n            }\n        }\n    }\n\n    onmousedown(e) {\n        const { originalEvent } = e.data;\n        const clientY = !originalEvent.touches ? originalEvent.clientY : originalEvent.touches[0].clientY;\n        this.mousedown = true;\n        if (this.scrollTween) {\n            this.scrollTween.kill();\n        }\n        this.lastPos = {\n            y: clientY\n        };\n    }\n\n    onmouseup() {\n        if (this.lastDiff) {\n            let goY = this.scrollContainer.y + this.lastDiff * 10;\n            let ease = Quad.easeOut;\n            let time = Math.abs(this.lastDiff / 150);\n            if (goY < -this.items.length * this.itemHeight + this.height + this.y) {\n                goY = -this.items.length * this.itemHeight + this.height + this.y;\n                ease = Back.easeOut;\n                time = 0.1 + Math.abs(this.lastDiff / 150);\n            }\n            if (goY > this.y) {\n                goY = this.y;\n                ease = Back.easeOut;\n                time = 0.1 + Math.abs(this.lastDiff / 150);\n            }\n\n            if (this.scrollContainer.y > 0) {\n                time = 1 + this.scrollContainer.y / 500;\n                ease = Elastic.easeOut;\n            }\n            if (this.scrollContainer.y < -this.items.length * this.itemHeight + this.height) {\n                time = 1 + (this.items.length * this.itemHeight + this.height + this.scrollContainer.y) / 500;\n                ease = Elastic.easeOut;\n            }\n\n            this.scrollTween = TweenMax.to(this.scrollContainer, time, {\n                y: goY,\n                ease\n            });\n        }\n\n        this.mousedown = false;\n        this.lastPos = null;\n        this.lastDiff = null;\n    }\n\n    // This should be called every tick. Use only for scrolling containers with lots of elements for performance.\n    hideOffscreenElements() {\n        const startIndex = Math.floor(-(this.scrollContainer.y - this.y) / this.itemHeight);\n        const endIndex = Math.floor(startIndex + (this.height / this.itemHeight));\n        for (let i = 0; i < this.items.length; i++) {\n            const item = this.items[i];\n            item.visible = false;\n            if (i >= startIndex && i <= endIndex + 1) {\n                item.visible = true;\n            }\n        }\n    }\n\n    addItem(item) {\n        this.scrollContainer.addChild(item);\n        this.items.push(item);\n        item.y = (this.items.length - 1) * this.itemHeight;\n    }\n}","const CONFIG = {\n    x: 50,\n    y: 10\n};\n\nexport class SoundButton extends PIXI.Sprite {\n    constructor (config) {\n        super();\n\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.soundOn = config.soundOn;\n        this.soundOff = config.soundOff;\n\n        this.currentState = \"on\";\n        this.setOnTexture();\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"off\"){\n            this.currentState = \"on\";\n            this.setOnTexture();\n            this.soundOn();\n        } else if (this.currentState === \"on\"){\n            this.currentState = \"off\";\n            this.setOffTexture();\n            this.soundOff();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n\n    setOffTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/soundOff.png\")\n    }\n\n    setOnTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/soundOn.png\")\n    }\n}","export class StorageManager{\n    static initStorage () {\n        window.localStorage.setItem(\"itemsList\", JSON.stringify([\n                {name: \"SYM0\", count: 2},\n                {name: \"SYM1\", count: 1},\n                {name: \"SYM2\", count: 4},\n                {name: \"SYM3\", count: 3},\n                {name: \"SYM4\", count: 5},\n                {name: \"SYM5\", count: 1},\n                {name: \"SYM6\", count: 3},\n                {name: \"SYM7\", count: 3},\n                {name: \"SYM8\", count: 2},\n                {name: \"SYM9\", count: 2},\n                {name: \"SYM10\", count: 3},\n                {name: \"SYM11\", count: 1}\n            ])\n        );\n    }\n\n    static randomInt (min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    static getSectorItemsList () {\n        var list = [];\n\n        JSON.parse(window.localStorage.getItem(\"itemsList\")).forEach(function (item) {\n            list.push(item.name);\n        });\n\n        return list;\n    }\n\n    static addItems (itemName, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item) {\n                if (itemName === item.name) {\n                    item.count += amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static removeItems (itemName, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item) {\n                if (itemName === item.name) {\n                    if (item.count - amount > 0) {\n                        item.count -= amount;\n                    } else {\n                        item.count = 0;\n                    }\n                }\n                return item\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static addItem (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    item.count += amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n\n    static removeItem (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    if (item.count - amount > 0) {\n                        item.count -= amount;\n                    } else {\n                        item.count = 0;\n                    }\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static setItemCount (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    item.count = amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static countItemsProbabilities (items, total) {\n        var probabilities = [];\n\n        items.forEach(function (item) {\n            probabilities.push(Math.floor(item.count * 100 / total));\n        });\n\n        return probabilities;\n    }\n\n    static countTotalItemsSum (itemsList) {\n        var sum = 0;\n\n        itemsList.forEach(function (item) {\n            sum += item.count;\n        });\n\n        return sum;\n    }\n\n    static getRandomItemAccordingToProbability () {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            totalItemsSum = this.countTotalItemsSum(itemsList),\n            itemsProbabilities = this.countItemsProbabilities(itemsList, totalItemsSum),\n            probabilityArray = [],\n            random;\n\n        itemsList.forEach(function (item, idx) {\n            for (var i = 0; i < itemsProbabilities[idx]; i++) {\n                probabilityArray.push(idx);\n            }\n        });\n\n        random = this.randomInt(0, 100);\n\n        return probabilityArray[random];\n    }\n\n    static isNoMoreItems () {\n        return JSON.parse(window.localStorage.getItem(\"itemsList\")).every(item => item.count === 0);\n    }\n\n    static findSectorToStopOn () {\n        var me = this,\n            randomIndex = me.getRandomItemAccordingToProbability(),\n            itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            randomItem = itemsList[randomIndex];\n\n        console.error(randomItem);\n\n        if (randomItem.count > 0) {\n            randomItem.count--;\n            window.localStorage.setItem(\"itemsList\", JSON.stringify(itemsList));\n\n            return randomIndex;\n        } else {\n            console.warn(\"no more \", randomItem.name);\n            debugger;\n            return me.findSectorToStopOn();\n        }\n    }\n}\n\n\n","import {SoundButton} from \"./SoundButton\";\nimport {FullScreenButton} from \"./FullScreenButton\";\nimport {ScrollContainer} from \"./ScrollContainer\";\nimport {StorageManager} from \"./StorageItemsManager\";\nimport {BonusWheel} from \"./BonusWheel\";\nimport {OpenCloseButton} from \"./OpenCloseButton\";\nimport {Menu} from \"./Menu\";\n\nexport const animationBuffer = [];\n\nvar app = new PIXI.Application(window.innerWidth, window.innerHeight, {backgroundColor : 0x000000});\ndocument.body.appendChild(app.view);\n\nvar ambientSound = new Audio(\"assets/sounds/ambient.mp3\");\nvar winSound = new Audio(\"assets/sounds/AUTOMOBILE.mp3\");\n\nfunction startAmbient() {\n    ambientSound.volume = 0.5;\n    ambientSound.play();\n    ambientSound.loop = true;\n}\n\nambientSound.addEventListener(\"loadeddata\", () => {\n    startAmbient();\n});\n\nconst soundButton = new SoundButton({\n    soundOn: function () {\n        ambientSound.volume = 0.5;\n        winSound.volume = 1;\n    },\n    soundOff: function () {\n        ambientSound.volume = 0;\n        winSound.volume = 0;\n    }\n});\n\nconst fullScreenButton = new FullScreenButton({\n    enterFullscreenMode: function () {\n        document.documentElement.requestFullscreen();\n    },\n    exitFullscreenMode: function () {\n        document.exitFullscreen();\n    }\n});\n\nvar scrollContainer = new ScrollContainer(0, 0, 500, 1000, 1500);\n\nvar prerenderCallbacks = [animate],\n    lastTimeStepOccured = 0,\n    currentStepTime = 0,\n    currentTime = 0;\n\nlastTimeStepOccured = updateTime();\n\nif(!window.localStorage.getItem(\"itemsList\")){\n    StorageManager.initStorage();\n}\n\nvar wheel = new BonusWheel({\n    name: \"freespins\",\n    spineSlot: \"1st_back\",\n    highlightSlot: \"1st_back2\",\n    sectors: [0,1,2,3,4,5,6,7,8,9,10,11],\n    maxSpeed: 16,\n    minSpeed: 0.15,\n    accelerationDuration: 1800,\n    minimumSpinsBeforeStop: 3,\n    sectorItemsList: StorageManager.getSectorItemsList(),\n    image: \"SYM0\"\n}, function () {\n    console.log(\"onStartBounceCompleteCallback\");\n}, app);\n\n// move the sprite to the center of the screen\nwheel.position.set(app.screen.width / 2, app.screen.height / 2);\n\nwindow.addEventListener(\"resize\", function() {\n    app.renderer.resize(window.innerWidth, window.innerHeight);\n    wheel.position.set(window.innerWidth / 2, window.innerHeight / 2);\n});\n\n// Listen for animate update\napp.ticker.add(function(delta) {\n    prerenderCallbacks.forEach(function(cb) {\n        cb();\n    });\n    scrollContainer.hideOffscreenElements();\n});\n\nfunction animate(){\n    animationBuffer.forEach(function(holder){\n        if ( holder.running ){\n            holder.run({\n                timeStep: currentStepTime,\n                time: currentTime\n            });\n        }\n    });\n}\n\nfunction updateTime() {\n    var now = Date.now(),\n        diff = now - lastTimeStepOccured;\n\n    // Check if more time than allowed has passed since the last frame\n    if (diff > 250) {\n        diff = 1000 / 60;\n    }\n\n    currentStepTime = diff | 0;\n    currentTime += currentStepTime;\n\n    return now;\n}\n\napp.stage.addChild(wheel);\n\nvar openCloseButton = new OpenCloseButton({\n    openCallback: function () {\n        menu.showMenu();\n    },\n    closeCallback: function () {\n        menu.hideMenu();\n    }\n});\n\nvar menu = new Menu({\n    onItemImgChange: function (index, texture) {\n        wheel.changeTexture(index, texture);\n    },\n    onCountChange: function (index, count) {\n        StorageManager.setItemCount(index, count);\n    }\n});\n\n//app.stage.addChild(menu);\nscrollContainer.addChild(menu);\napp.stage.addChild(scrollContainer);\napp.stage.addChild(soundButton);\napp.stage.addChild(fullScreenButton);\napp.stage.addChild(openCloseButton);\n\n\nwindow.addEventListener(\"resize\", refreshAll);\nfunction refreshAll() {\n    wheel.refresh();\n}\n\nfunction spacePressHandler(event) {\n    if(event.keyCode === 32){\n        var itemsLeft = !StorageManager.isNoMoreItems(),\n            itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            sectorToStopOn;\n\n        if(!itemsLeft){\n            console.error(\"no more items at all\");\n        } else {\n            winSound.play();\n            sectorToStopOn = StorageManager.findSectorToStopOn();\n            menu.onStorageUpdated();\n            console.warn(\"stopping at: \", sectorToStopOn);\n\n            openCloseButton.onForseClosed();\n            wheel.start();\n            document.removeEventListener(\"keypress\", spacePressHandler);\n\n            wheel.setStoppingAngle(sectorToStopOn);\n            wheel.startStopping().then(function () {\n                wheel.playGiftAnimation(itemsList[sectorToStopOn].name, function () {\n                    document.addEventListener(\"keypress\", spacePressHandler);\n                });\n            });\n        }\n    }\n}\n\ndocument.addEventListener(\"keypress\", spacePressHandler);\n"],"sourceRoot":""}