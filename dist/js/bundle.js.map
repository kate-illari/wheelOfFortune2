{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/AnimationHolder.js","webpack:///./js/BonusWheel.js","webpack:///./js/BonusWheelItem.js","webpack:///./js/FullScreenButton.js","webpack:///./js/Menu.js","webpack:///./js/OpenCloseButton.js","webpack:///./js/ResetButton.js","webpack:///./js/SoundButton.js","webpack:///./js/StorageItemsManager.js","webpack:///./js/imagesConfig.js","webpack:///./js/main.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAsC;;AAE/B;AACP;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,kBAAkB,OAAO,eAAe;AACxC;AACA;AACA,kBAAkB,OAAO,mBAAmB;AAC5C;AACA;AACA,kBAAkB,OAAO,mBAAmB;AAC5C;;;AAGA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,YAAY,qDAAe;AAC3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,yCAAyC;;AAExE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;AC1vBA;AAAA;AAAA;AAAA;AAAA;AAAgD;AACE;AACG;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA;;AAEA,6BAA6B,mEAAc;;AAE3C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,mEAAc;AACvC,wBAAwB,mEAAc;AACtC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAyB,mEAAc;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,yBAAyB,mEAAc;AACvC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAyB,mEAAc;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,mEAAc;AAC9C;AACA;;AAEA,uCAAuC,8DAAc;AACrD;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gEAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D,+BAA+B,KAAK;AACpC,+BAA+B,KAAK;AACpC,+BAA+B,gCAAgC;AAC/D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,+CAA+C,mEAAc;;AAE7D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA,mBAAmB,gEAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA,mBAAmB,gEAAe;AAClC;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA,mBAAmB,gEAAe;AAClC;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;AC/qBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,eAAe,OAAO;AACtB,eAAe,2BAA2B;AAC1C,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClEA;AAAA;AAAA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,C;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAqD;AACT;;AAE5C;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,mEAAc;AACtC;AACA;AACA,YAAY,mEAAc;AAC1B,wBAAwB,mEAAc;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,mEAAc;AACxC;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,0DAAY;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,mEAAc;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C,mEAAc;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,mEAAc;AACtB;AACA;;AAEA;AACA,QAAQ,mEAAc;AACtB;AACA;;AAEA;AACA,oDAAoD,mEAAc;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrNA;AAAA;AAAA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AChDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC5BA;AAAA;AAAA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAwC;;AAEjC;AACP;AACA;AACA;AACA,2BAA2B,mDAAmD;AAC9E,2BAA2B,kDAAkD;AAC7E,2BAA2B,qDAAqD;AAChF,2BAA2B,yDAAyD;AACpF,2BAA2B,0DAA0D;AACrF,2BAA2B,kDAAkD;AAC7E,2BAA2B,0DAA0D;AACrF,2BAA2B,kDAAkD;AAC7E,2BAA2B,uDAAuD;AAClF,2BAA2B,sDAAsD;AACjF,4BAA4B,0DAA0D;AACtF,4BAA4B,wDAAwD;AACpF;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,sDAAU;AAClB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA,SAAS;;AAET,uBAAuB,iBAAiB;;AAExC;AACA,qBAAqB,OAAO;;AAE5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACxKA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACA;AACU;AACC;AACb;AACU;AACtB;;AAErB;;AAEP,uEAAuE,2BAA2B;AAClG;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI,mEAAc;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;AAID,iBAAiB,0CAAI;;AAErB,gBAAgB,sDAAU;AAC1B;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;AAID,wBAAwB,wDAAW;AACnC,6BAA6B,kEAAgB;AAC7C,4BAA4B,gEAAe;AAC3C,wBAAwB,wDAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,qDAAqD;AAChG,SAAS;AACT;AACA,CAAC,E","file":"./js/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import {animationBuffer} from \"./main\"\n\nexport class AnimationHolder {\n    /**\n     * @property {String} [id=\"\"] The identifier for this animation, if you don't specify one we will try to use\n     * parent.id + \":\" + prop + \"Animation\"\n     */\n    /**\n     * @property {Object} [target=undefined] The target object we want to animate, if you don't specify one we will\n     * try to use the parent.target\n     */\n    /**\n     * @property {String} [prop=undefined] The name of the properties on the target we want to change\n     */\n    /**\n     * @property {Boolean} [running=false] If the animation is active\n     */\n    /**\n     * @property {Number} [playbackSpeed=undefined] If we want to play the animation faster (>1) or slower (<1)\n     */\n    /**\n     * @property {Boolean} [loop=false] Will repeat the whole animation. If it have separate operations with different\n     * time the shorter ones will wait at the end key frame until the longest is done. onStart & onEnd will not be\n     * called every loop (if that is needed, set callbacks on key frames instead). Will also wait for all it's\n     * children to complete.\n     */\n    /**\n     * @property {Boolean} [readyToLoop=false] Since we sometime need to wait for our children we use this to know\n     * when we can loop back to the start.\n     */\n    /**\n     * @property {Function} [onStart=undefined] Callback function before the animation starts\n     */\n    /**\n     * @property {Function} [onEnd=undefined] Callback function when the animation is complete\n     */\n    /**\n     * @property {Function} [onUpdate=undefined] Callback function on every frame before the operation run. Will be\n     * called regardless if the holder have operation, target etc or not, as long as it is running (and it's parents) the\n     * function will be called.\n     */\n    /**\n     * @property {Array} [children=[]] So we can nestle animation\n     */\n    /**\n     * @property {Animation.Holder} [parent=undefined] A reference to the holders parent\n     */\n    /**\n     * @property {Number} [localTime=0] Local time counter\n     */\n    /**\n     * @property {Number} [delay=0] Time before the operations start after the animation starts\n     */\n    /**\n     * @property {Number} [startTimeOffset=0] If we want the animation to start at a specific time (TODO: currently if the offset is beyond the first keyframe it will start at that keyframe instead)\n     */\n    /**\n     * @property {Object} [operations={}] The operations the holder preforms\n     */\n    /**\n     * @property {Object} [operationSteps={}] The current key frame for every operation\n     */\n    /**\n     * @property {Object} [operationEnded={}] If all the operations are done\n     */\n\n\n    /**\n     * Constructor\n     *\n     * @param {Object} config The config object\n     */\n    constructor (config) {\n        var me = this,\n            defaultProp = {\n                id                  : undefined,    // the identifier for this animation\n                target              : undefined,    // the target object we want to animate\n                prop                : undefined,    // the name of the properties on the target we want to change.\n                animation           : {             // object that will hold keyFrames etc.\n                    keyFrames : [],\n                    step : 0,                       // the current keyFrame we're on\n                    complete : false                // if the animation is done\n                },\n                running             : false,        // if the animation is active.\n                playbackSpeed       : undefined,    // if we want to play the animation faster (>1) or slower (<1)\n                loop                : false,        // will repeat the whole animation. If it have separate operations\n                                                    // with different time the shorter ones will wait at the end key frame\n                                                    // until the longest is done. onStart & onEnd will not be called every\n                                                    // loop (if that is needed, set callbacks on key frames instead).\n                                                    // Will also wait for all it's children to complete.\n                readyToLoop         : false,        // since we sometime need to wait for our children we use this to know\n                                                    // when we can loop back to the start.\n                onStart             : undefined,    // callback before the animation starts\n                onEnd               : undefined,    // callback when the animation is complete\n                onUpdate            : undefined,    // callback on every frame before the operation run. Will be\n                                                    // called regardless if the holder have operation, target etc or not\n                children            : [],           // so we can nestle animation\n                parent              : undefined,    // a reference to the holders parent\n                localTime           : 0,            // local time counter\n                delay               : 0,            // time before the operations start after the animation starts\n                startTimeOffset     : undefined,    // if we want the animation to start at a specific time\n                //operations          : {},           // the operations the holder preforms\n                //operationSteps      : {},           // the current key frame for every operation\n                //operationsEnded     : false,        // if all the operations are done\n                addToAnimationLoop  : false         // adding the holder to the animation loop on creation\n            };\n\n        config = Sys.applyProperties(defaultProp, config);\n\n        // Parse the config, this allows us to use several config syntax\n        config = me.parseConfig(config);\n\n        me = Sys.applyProperties(me, config);\n\n        //// Set the default parameters needed by the operations\n        //me.setOperationDefaultProperties();\n\n        if ( config.addToAnimationLoop ){\n            animationBuffer.push(me);\n        }\n\n    }\n\n    /**\n     * Parse the config so that it matches the actual object properties.\n     *\n     * @param config\n     * @return {Object} The parsed properties\n     */\n    parseConfig  (config) {\n        var properties = {\n                animation : {\n                    keyFrames : [],\n                    step : 0,\n                    complete : false\n                }\n            },\n            //operations = Object.keys(Animation.Operations),\n            timeSort = function (a, b) {\n                return (a.time - b.time);\n            },\n            obj;\n\n        // Process all keys on the config object\n        Sys.iterate(config, function(key, value){\n\n            // If we have an animation, parse it\n            if (key === \"animate\" ) {\n\n                /*DEBUG_START*/\n                if ( key !== \"animate\" ){\n                    // TODO: right now we only support the \"animate\" operation, when we need more we have to make them.\n                    console.warn(\"You are trying to use a \" + key + \" operation on a Animation.Holder, for now only 'animate' is supported\");\n                }\n                /*DEBUG_END*/\n\n                // if the operation is an array or object\n                if ( Sys.isObj(value) ){\n\n                    Sys.iterate(value, function(time, frameValue){\n                        // Define the frame object with the time value\n                        obj = { time : parseInt(time, 10) };\n\n                        // If the frame is an object with a defined value then we have non value properties mixed in\n                        if (Sys.isObj(frameValue) ) {\n                            if ( Sys.isDefined(frameValue.value) ){\n                                obj = Sys.applyProperties(obj, frameValue);\n                            }\n                            else {\n                                obj.value = frameValue;\n                            }\n                        }\n                        // Otherwise it is just a plain value\n                        else {\n                            obj.value = frameValue;\n                            /*DEBUG_START*/\n                            if ( !Sys.isDefined(config.prop) && config.length > 1 ){\n                                console.warn(\"If we only specify a number value the property 'prop' must exist\");\n                            }\n                            /*DEBUG_END*/\n                        }\n\n                        // Push the key frame\n                        properties.animation.keyFrames.push(obj);\n                    });\n\n                    properties.animation.keyFrames.sort(timeSort);\n                }\n                else if ( Sys.isArray(value) ){\n                    // the operation is already in the right format, add it to the operations object\n                    properties.animation.keyFrames = value;\n                }\n                else {\n                    // error\n                    console.warn(\"Operation is in wrong format\");\n                }\n            }\n            // Else assign the value\n            else {\n                properties[key] = value;\n            }\n        });\n\n        // if target is undefined use the parents target (if it exist)\n        if ( !Sys.isDefined(properties.target) && Sys.isDefined(properties.parent) && Sys.isDefined(properties.parent.target) ){\n            properties.target = properties.parent.target;\n        }\n\n        /*DEBUG_START*/\n        if ( Sys.isDefined(properties.target) && !Sys.isObj(properties.target) ){\n            console.warn(\"The target of a Animation.Holder must be a Object\");\n        }\n        /*DEBUG_END*/\n\n        // if the id is undefined use the targets id (if it exist) and the operation type\n        if ( !Sys.isDefined(properties.id) && Sys.isDefined(properties.target) && Sys.isDefined(properties.target.id) ){\n            var prop = Sys.isDefined(properties.prop) ? properties.prop : \"\";\n\n            properties.id = properties.target.id + \":\" + prop + \"Animation\";\n        }\n\n        // if we already have children in the config, create them and add them\n        if ( Sys.isDefined(properties.children) && properties.children.length > 0 ){\n            var tempChildrenContainer = [],\n                parent = this;\n\n            properties.children.forEach(function(child){\n                var animation;\n\n                if ( Sys.isDefined(child.localTime) ){\n                    // the child is already a AnimationHolder\n                    animation = child;\n                }\n                else {\n                    child.parent = {target : config.target};\n                    animation = new AnimationHolder(child);\n                }\n                animation.parent = parent;\n                tempChildrenContainer.push( animation );\n            });\n\n            properties.children = tempChildrenContainer;\n        }\n\n        return properties;\n    }\n\n    /**\n     * Run the holder and it's children\n     *\n     * @param {Object} timeObj The object containing the time\n     */\n    run (timeObj) {\n        var me = this,\n            timeStep = timeObj.timeStep;\n\n        if (me.localTime === 0 && Sys.isDefined(me.startTimeOffset) ){\n            // if this is the first frame of the animation and we have a start offset\n            timeStep += me.startTimeOffset;\n        }\n\n        if ( Sys.isDefined(me.playbackSpeed) ){\n            // adjust the time step based on playback speed\n            timeStep *= me.playbackSpeed;\n        }\n\n        me.localTime += timeStep; // increase the local timer\n\n        if(me.localTime >= me.delay) {\n\n            // Time step is used to keep track of internal timers on the operation level\n            me.doAnimation(timeStep);\n\n            me.children.forEach(function(child){\n                if ( child.running ){\n                    child.run({timeStep : timeStep, time : timeObj.time});\n\n                    // if the child is still running\n                    if ( child.running ){\n                        // we should also be running\n                        me.running = true;\n\n                        if ( !child.loop && !child.readyToLoop ){\n                            // if it's time for us to loop, wait until the children are done\n                            // but don't wait on looping children\n                            me.readyToLoop = false;\n                        }\n                    }\n                }\n            });\n\n            if ( Sys.isDefined(me.onUpdate) ){\n                me.onUpdate(timeStep);\n            }\n        }\n\n        if ( me.loop && me.readyToLoop ){\n            // meaning I'm done and all my children are done (ignoring children that are looping)\n            me.restoreOnLoop();\n        }\n        else if ( !me.running ){\n            // this animation is done\n            if ( Sys.isDefined(me.onEnd) ){\n                me.onEnd();\n            }\n\n            // restore the animation on completion so we can start it from the beginning on the next play()\n            me.restore();\n        }\n    }\n\n    /**\n     * Runs each animation operation that is set for the holder\n     *\n     * @private\n     * @param {Number} currentStepTime the current time step\n     */\n    doAnimation (currentStepTime) {\n        var me = this,\n            numKeyFrames = me.animation.keyFrames.length;\n\n        // If we don't have any keyFrames or target just return\n        if (numKeyFrames < 2 || !Sys.isDefined(me.target) ) {\n            me.readyToLoop = true;\n            me.running = false;\n            return;\n        }\n\n        // Check if the animation have finished\n        var running = me.performAction(currentStepTime);\n\n        if (!running) {\n            // all the operations are done\n            me.running = false;\n            me.readyToLoop = true;\n        }\n    }\n\n    /**\n     * Play the animation\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to play. If none is\n     * specified (or true) we play all the children. If you send in an empty array [] we'll only play the current.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    play (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.running = true;\n\n        me.handleItems(\"play\", children);\n\n        if (me.localTime === 0 && Sys.isDefined(me.onStart)){\n            // if we start the game from the beginning do the onStart callback\n            me.onStart();\n        }\n\n        // make sure the parents are running\n        if (isRoot){\n            me.runParent();\n        }\n    }\n\n    runParent (){\n        var me = this;\n\n        if ( Sys.isDefined(me.parent) ){\n            me.parent.running = true;\n\n            me.parent.runParent();\n        }\n    }\n\n    /**\n     * Pause the animation\n     *\n     * @param {Array} [children] An array with children that we want to pause. If none is\n     * specified we pause all the children. If you send in an empty array [] we'll only pause the current holder.\n     */\n    pause (children) {\n        this.running = false;\n\n        this.handleItems(\"pause\", children);\n    }\n\n    /**\n     * Stop the animation and reset it to the beginning. Will do it for all the children as well\n     *\n     * @param {Array} [children] An array with children that we want to stop. If none is\n     * specified we stop all the children. If you send in an empty array [] we'll only stop the current.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    stop (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.running = false;\n\n        me.handleItems(\"stop\", children);\n\n        if ( isRoot ){\n            me.restore(children, true);\n        }\n    }\n\n    /**\n     * Restores the basic properties of the holder in order to run it again.\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to restore. If none is\n     * specified (or true) we restore all the children. If you send in an empty array [] we'll only restore the current holder.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    restore (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.localTime = 0;\n        me.readyToLoop = false;\n\n        me.restoreAnimation();\n\n        me.handleItems(\"restore\", children);\n\n        // if we are already running and are the root object we play()\n        if ( me.running && isRoot ){\n            me.play(children, true);\n        }\n    }\n\n    /**\n     * Restores the basic properties of the holder in order to run it again.\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to restore. If none is\n     * specified (or true) we restore all the children. If you send in an empty array [] we'll only restore the current holder.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    restoreOnLoop (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        if ( isRoot || !me.loop ){\n            me.running = true;\n            //me.localTime = 0;\n            me.readyToLoop = false;\n\n            me.restoreAnimation();\n\n            me.handleItems(\"restoreOnLoop\");\n        }\n    }\n\n    restoreAnimation (){\n        this.animation.time = 0;\n        this.animation.step = 0;\n\n        this.animation.keyFrames.forEach(function(key){\n            if (Sys.isDefined(key.callback)) {\n                key.callbackCompleted = false;\n            }\n\n            // add more stuff\n        });\n    }\n\n    /**\n     * @private\n     * Update the holder with the operation configuration\n     *\n     * @param {Object} config The configuration\n     */\n    updateOperation (config) {\n        var me = this,\n            obj = {};\n\n        //me.applyDefaultValuesToItem(me);\n\n        obj.animate = config;\n\n        obj = me.parseConfig(obj);\n\n        me.animation = obj.animation;\n        //me.applyDefaultValuesToOperation(me);\n\n        me.restore();\n    }\n\n    /**\n     * @private\n     * Call the specified function on all the items\n     *\n     * @param {String} type The function to call on the items\n     * @param {Array} [selection] The optional array of items to handle\n     */\n    handleItems (type, selection){\n        var items = (Sys.isDefined(selection) && Sys.isArray(selection)) ? selection : this.children;\n\n        items.forEach(function(child){\n            child[type](true, false);\n        });\n    }\n\n    setParent (parent){\n        this.parent = parent;\n        parent.children.push(this);\n\n        // if you don't have a target, use the parents\n        if ( !Sys.isDefined(this.target) ){\n            this.target = parent.target;\n        }\n    }\n\n    addChild (children){\n        var me = this;\n\n        if (Sys.isArray(children) ){\n            children.forEach(function(child){\n                child.setParent(me);\n            });\n        }\n        else if (Sys.isObj(children)){\n            children.setParent(me);\n        }\n    }\n\n    /**\n     * Will search children (and grandchildren) for a Holder that mach the key and value provide.\n     *\n     * NOTE: if there is more than one match you will get the first one.\n     *\n     * @param {String} value The value that should match\n     * @param {String} [byKey] Which property key we should check against, default \"id\"\n     *\n     * @return {object|boolean} the items that match our search criteria, or false if it didn't find anything\n     */\n    findChild (value, byKey){\n        var key = Sys.isDefined(byKey) ? byKey : \"id\",\n            item = false,\n            searchChildren = function(items) {\n                var result = false,\n                    subResult = false;\n\n                items.forEach(function(item){\n                    if ( Sys.isDefined(item[key]) && item[key] === value ){\n                        result = item;\n                    }\n\n                    if ( Sys.isDefined(item.children) ){\n                        subResult = searchChildren(item.children);\n\n                        if ( Sys.isObj(subResult) ){\n                            result = subResult;\n                        }\n                    }\n                });\n\n                return result;\n            };\n\n        // start with the main Holder\n        if ( this[key] === value ){\n            return this;\n        }\n\n        if ( Sys.isDefined(this.children) ){\n            item = searchChildren(this.children );\n        }\n\n        return item;\n    }\n\n    /**\n     * Performs the specified action on a given object.\n     *\n     * @param {Number} currentStepTime The time since the last render (ms)\n     */\n    performAction (currentStepTime) {\n        var me = this,\n            animation = me.animation,\n            keyFrames = animation.keyFrames,\n            numKeyFrames = keyFrames.length,\n            currentTime = me.increaseAnimationTime(currentStepTime),\n            currentKeyFrame = keyFrames[animation.step],\n            nextKeyFrame = keyFrames[animation.step + 1],\n            running = true;\n\n        /*DEBUG_START*/\n        if ( numKeyFrames < 2 ){\n            console.warn(\"The Holder \" + item + \" have an animation with less than two keyFrames, the operation needs a minimum of two keyFrames to be able to animate.\");\n            return 0;\n        }\n        /*DEBUG_END*/\n\n        me.handleCallback(currentKeyFrame); // added an extra callback check here to make sure callbacks on keyFrame 0 are fired\n\n        // step through keyFrames, from oldKeyFrameIndex, until we are on the current one\n        // loop if necessary\n        // fire events and callbacks on every new keyFrame we pass\n        // goTo keyFrames\n\n        // check if we have passed the next keyFrame\n        if ( nextKeyFrame.time <= currentTime){\n            me.progressKeyFrame();\n\n            currentKeyFrame = keyFrames[animation.step];\n\n            // are we at the last keyFrame, ie we're not looping and the animation is complete\n            if ( animation.step === numKeyFrames - 1 ){\n                nextKeyFrame = currentKeyFrame;\n                running = false;\n            }\n            else {\n                nextKeyFrame = keyFrames[animation.step + 1];\n            }\n        }\n\n        // when we have the current keyFrame, interpolate between that and the next keyFrame\n        me.calculate(animation.time, currentKeyFrame, nextKeyFrame);\n\n        return running;\n    }\n\n    progressKeyFrame (toIndex){\n        var me = this,\n            animation = me.animation,\n            keyFrames = animation.keyFrames,\n            currentKeyFrame;\n\n        // step to next keyFrame\n        animation.step = Sys.isDefined(toIndex) ? toIndex : animation.step + 1;\n\n        // do events and callbacks\n        currentKeyFrame = keyFrames[animation.step];\n        me.handleCallback(currentKeyFrame);\n\n        // check for goTo\n        if ( Sys.isDefined(currentKeyFrame.goTo) ) {\n            me.doGoTo(currentKeyFrame);\n        }\n\n        // if we haven't reached the last keyFrame\n        if ( animation.step !== keyFrames.length - 1 ){\n            // check if we should move one more\n            if ( animation.time >= keyFrames[animation.step + 1].time){\n                me.progressKeyFrame();\n            }\n        }\n        else if ( me.loop  ){ // at the last keyFrame and we're looping\n            animation.time -= keyFrames[animation.step].time;\n            me.progressKeyFrame(0);\n        }\n\n    }\n\n    doGoTo (keyFrame){\n        var me = this;\n\n        me.animation.time = me.animation.keyFrames[keyFrame.goTo].time;\n        me.animation.step = keyFrame.goTo;\n\n        /*DEBUG_START*/\n        console.warn(\"Warning: goTo functionality not completed, use at own risk.\");\n        // TODO: fix goTo, callback resets when going back and callback firing when going forward etc.\n        /*DEBUG_END*/\n    }\n\n    /**\n     * Calculates the time steps and sets the values that should be interpolated.\n     *\n     * @protected\n     * @param {Number} currentTime The current time step\n     * @param {Object} currentStep The current frame\n     * @param {Object} nextStep The next frame\n     */\n    calculate (currentTime, currentStep, nextStep) {\n        var me = this,\n            time = me.calculateTime(currentTime, currentStep, nextStep),\n            from = currentStep.value,\n            to = nextStep.value,\n            target;\n\n        if ( Sys.isObj(from) ){\n            Sys.iterate(from, function(key, value){\n                target = Sys.isDefined(me.prop) ? me.target[me.prop] : me.target;\n\n                target[key] = Animation.utils.getInterpolationValue(value, to[key], time, currentStep.ease, key);\n            });\n        }\n        else { // we only animate one number\n            me.target[me.prop] = Animation.utils.getInterpolationValue(from, to, time, currentStep.ease);\n        }\n    }\n\n    /**\n     * @private\n     * @param {Object} currentKeyFrame The object holding the current key frame information\n     */\n    handleCallback (currentKeyFrame) {\n        var callback = currentKeyFrame.callback,\n            container;\n\n        if(Sys.isDefined(callback) && !currentKeyFrame.callbackCompleted) {\n\n            if ( callback.fireImmediately ){\n                if ( Sys.isString(callback.func) ){\n                    // an event\n                    callback.scope.fireEvent(callback.func, callback.args);\n                }\n                else if ( Sys.isFunc(callback.func) ){\n                    // a function\n                    callback.func.apply(callback.scope, callback.args);\n                }\n            }\n            else {\n                container = Game.stage.view.animationManager.callbackContainer;\n                container.push(callback);\n            }\n\n            currentKeyFrame.callbackCompleted = true;\n        }\n    }\n\n    /**\n     * Calculates the time vars.\n     *\n     * @private\n     * @param {Number} currentTime The current time step\n     * @param {Object} currentStep The current frame\n     * @param {Object} nextStep The next frame\n     */\n    calculateTime (currentTime, currentStep, nextStep) {\n        var timeStep = currentTime - currentStep.time,\n            totalTime = nextStep.time - currentStep.time;\n\n        //If timeStep equals 0 and totalTime equals 0. The result will be NaN\n        return totalTime !== 0 ? timeStep / totalTime : 1;\n    }\n\n\n    /**\n     * Increase the timeBuffer\n     *\n     * @param {Number} time The time the time buffer should be increased\n     */\n    increaseAnimationTime  (time) {\n        if (!Sys.isDefined(this.animation.time)) {\n            this.animation.time = time;\n        }\n        else {\n            this.animation.time += time;\n        }\n\n        return this.animation.time;\n    }\n\n    animate (config, play) {\n        this.updateOperation(config);\n        if ( play ){\n            this.play();\n        }\n    }\n\n}","import {BonusWheelItem} from \"./BonusWheelItem\";\nimport {AnimationHolder} from \"./AnimationHolder\";\nimport {StorageManager} from \"./StorageItemsManager\";\n\nconst CIRCLE_DEG = 360;\n    //the minimum difference (angle) between current wheel stop and previous wheel stop:\nconst MIN_DIFF = 270;\nconst START_BOUNCE = {\n    //negative value, since the wheel moves backwards\n    maxSpeed: -0.5,\n        //time fraction of the whole acceleration time\n        timeFraction: 1/500\n};\n\nconst WHEEL_ITEMS_CENTER_OFFSET = 260;\nconst WHEEL_ITEM_CONFIG = {\n    width: 110,\n    height: 110\n};\nconst WILD_ITEM_CONFIG = {\n    width: 150,\n    height: 150,\n}\n\nconst LOGO_POSITION = {\n    portrait: {\n        x: 0,\n        y: 430\n    },\n    landscape: {\n        x: 380,\n        y: 310\n    }\n};\n\nconst WHEEL_CONFIG = {\n    name: \"freespins\",\n    spineSlot: \"1st_back\",\n    highlightSlot: \"1st_back2\",\n    sectors: [0,1,2,3,4,5,6,7,8,9,10,11],\n    maxSpeed: 16,\n    minSpeed: 0.15,\n    accelerationDuration: 1800,\n    minimumSpinsBeforeStop: 3,\n    image: \"SYM8\"\n};\n\nexport class BonusWheel extends PIXI.Container {\n    \n    constructor (onStartBounceCompleteCallback, app) {\n        super();\n        var me = this;\n\n        me.sectorItemsList = StorageManager.getSectorItemsList();\n\n        me.background = me._initBackground();\n        me.background.anchor.set(0.5,0.5);\n\n        //degrees per frame\n        me.maxSpeed = WHEEL_CONFIG.maxSpeed;\n\n        me.minSpeed = WHEEL_CONFIG.minSpeed;\n        me.wheelBgDisk = me.initWheelBackground();\n\n        me.sprite = me._initWheelSprite();\n        me.spinButton = me.initSpinButton();\n        me.initSpinButtonActions();\n\n        BonusWheel.wheelItems = me._initWheelItems(me.sprite);\n        //will be added to a separate spine slot:\n        me.highlightSprite = typeof WHEEL_CONFIG.image !== \"undefined\" ? me._initSprite(WHEEL_CONFIG.image, PIXI.BLEND_MODES.ADD) : me._initEmptySprite();\n\n        me.sectorsAngles = me._mapSectorsAgles(WHEEL_CONFIG.sectors);\n        me.animations = me._initAnimations(WHEEL_CONFIG);\n        me.onStartBounceCompleteCallback = onStartBounceCompleteCallback;\n        me.config = WHEEL_CONFIG;\n        me.pick = me._initPickSprite();\n\n        me.gift = me._initGiftSprite(me, \"EMPTY\");\n        me.logo = me.initLogo();\n\n        this.winSound = document.getElementById(\"winSound\");\n\n        me.pick = me._initPickSprite();\n        me._initBgSpine(me, \"glow\", app);\n\n\n        me.reset();\n        me.refresh();\n    }\n\n    _initBackground () {\n        return this.addChild(new PIXI.Sprite.fromImage(\"assets/images/background.png\"))\n    }\n\n    initWheelBackground(){\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/disk.png\");\n        sprite.anchor.set(0.5, 0.5);\n\n        return this.addChild(sprite);\n    }\n\n    _initBgSpine (container, spineName, app) {\n        var me = this,\n            glow;\n\n        PIXI.loader\n            .add('glow', 'assets/spine/glow.json')\n            .load(onAssetsLoaded);\n\n        function onAssetsLoaded(loader,res) {\n            // instantiate the spine animation\n            glow = new PIXI.spine.Spine(res.glow.spineData);\n            glow.skeleton.setToSetupPose();\n            glow.update(0);\n            glow.autoUpdate = false;\n            glow.scale.set(0.75);\n            me.addChild(glow);\n            me.addChild(me.pick); // adding it here to make sure it's on top!!!\n\n            // once position and scaled, set the animation to play\n            glow.state.setAnimation(0, 'spin', true);\n            app.ticker.add(function() {\n                glow.update(0.05);\n            });\n\n            glow.visible = false;\n            me.bgAnimation = glow;\n        }\n\n    }\n\n    _initWheelSprite () {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/sectors.png\");\n        sprite.anchor.set(0.5, 0.5);\n\n        return this.addChild(sprite);\n    }\n\n    initSpinButton () {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/stop_idle.png\");\n        sprite.interactive = true;\n        sprite.anchor.set(0.5, 0.5);\n        this.addChild(sprite);\n\n        return sprite;\n    }\n\n    initSpinButtonActions(){\n        var me = this,\n            button = me.spinButton;\n\n        button.on(\"pointerdown\", () => {\n            button.texture = PIXI.Texture.fromImage(\"assets/images/stop_click.png\");\n        });\n\n        button.on(\"pointerup\", () => {\n            this.onSpinButtonUp();\n        });\n\n        button.on(\"pointerupoutside\", () => {\n            button.texture = PIXI.Texture.fromImage(\"assets/images/stop_idle.png\");\n        });\n    }\n\n    onSpinButtonDown() {\n        var me = this,\n            button = me.spinButton;\n\n        button.texture = PIXI.Texture.fromImage(\"assets/images/stop_click.png\");\n    }\n\n    onSpinButtonUp() {\n        var me = this,\n            button = me.spinButton,\n            itemsLeft = !StorageManager.isNoMoreItems(),\n            itemsList = StorageManager.getLocalStorageItem(\"itemsList\"),\n            sectorToStopOn;\n\n        button.texture = PIXI.Texture.fromImage(\"assets/images/stop_idle.png\");\n\n        if(!itemsLeft){\n            alert(\"No more items, please go to menu\");\n            return;\n        }\n\n        button.interactive = false;\n\n        sectorToStopOn = StorageManager.findSectorToStopOn();\n        console.warn(\"stopping at: \", sectorToStopOn);\n\n        me.start();\n        me.setStoppingAngle(sectorToStopOn);\n        me.startStopping().then(function () {\n            if (Object.values(itemsList)[sectorToStopOn].name === \"EMPTY\") {\n                button.interactive = true;\n                me.bgAnimation.visible = false;\n            } else {\n                me.playGiftAnimation(Object.keys(itemsList)[sectorToStopOn], () => {\n                    button.interactive = true;\n                });\n            }\n        });\n    }\n\n    releaseHardButton(callback) {\n        var me = this,\n            button = me.spinButton,\n            itemsLeft = !StorageManager.isNoMoreItems(),\n            sectorToStopOn;\n\n        button.texture = PIXI.Texture.fromImage(\"assets/images/stop_idle.png\");\n\n        if(!itemsLeft){\n            console.error(\"no more items at all\");\n            return;\n        }\n\n        button.interactive = false;\n\n        sectorToStopOn = StorageManager.findSectorToStopOn();\n        console.warn(\"stopping at: \", sectorToStopOn);\n\n        me.start();\n        me.setStoppingAngle(sectorToStopOn);\n        me.startStopping().then(function () {\n            me.playGiftAnimation(\"SYM\" + sectorToStopOn, () => {\n                button.interactive = true;\n                callback();\n            });\n        });\n    }\n\n    /**\n     * Adds wheel items - sprites that rotate together with the wheel\n     *\n     * @param {PIXI.Container|PIXI.Sprite} parent - wheelItems will be added here\n     * @returns {Array<S.BonusWheelItem>}\n     * @private\n     */\n    _initWheelItems(parent){\n        var me = this,\n            whellItems = {};\n\n        me.sectorItemsList.forEach(function (item, index) {\n            const texturePath = StorageManager.getImgPath(item);\n            const texture = new PIXI.Texture.fromImage(texturePath);\n            const sizedContainer = new PIXI.Container();\n\n            const bonusWheelItem = new BonusWheelItem({\n                parent: sizedContainer,\n                texture: texture,\n                sectorIndex: index,\n                centerOffset: WHEEL_ITEMS_CENTER_OFFSET,\n                totalSectorsNum: me.sectorItemsList.length\n            });\n\n            bonusWheelItem.updateSize();\n\n            parent.addChild(sizedContainer);\n            whellItems[item] = bonusWheelItem;\n        });\n\n        return whellItems;\n    }\n\n    _initPickSprite () {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/arrow.png\");\n        sprite.anchor.set(0.5, 0.5);\n        sprite.position.y = -350;\n\n        return sprite;\n    }\n\n    _initGiftSprite (container, imageName) {\n        const sprite = this._initSprite(imageName, PIXI.BLEND_MODES.NORMAL);\n        const wildSubstr = RegExp(\"wild\");\n        const isWild = wildSubstr.test(sprite.texture.baseTexture.imageUrl);\n        const startWidth = isWild ? WILD_ITEM_CONFIG.width : WHEEL_ITEM_CONFIG.width;\n        const startHeight = isWild ? WILD_ITEM_CONFIG.height : WHEEL_ITEM_CONFIG.height;\n\n        container.addChild(sprite);\n        sprite.width = startWidth;\n        sprite.height = startHeight;\n        sprite.position.y = -WHEEL_ITEMS_CENTER_OFFSET/2;\n        sprite.visible = false;\n        sprite.animation = new AnimationHolder({\n            addToAnimationLoop: true,\n            target: sprite,\n            children: [\n                {\n                    prop: \"position\",\n                    animate: {\n                        200: {y: -(WHEEL_ITEMS_CENTER_OFFSET)},\n                        1500: {y: 0},\n                        5000: {y: 0},\n                        5500: {y: -(WHEEL_ITEMS_CENTER_OFFSET)},\n                    }\n                },\n                {\n                    prop: \"width\",\n                    animate: {\n                        200: startWidth,\n                        1500: startWidth * 4,\n                        5000: startWidth * 4,\n                        5500: startWidth\n                    }\n                },\n                {\n                    prop: \"height\",\n                    animate: {\n                        200: startHeight,\n                        1500: startHeight * 4,\n                        5000: startHeight * 4,\n                        5500: startHeight\n                    }\n                }\n            ]\n        });\n\n        return sprite;\n    }\n\n    /**\n     *\n     * @param animSprite - win presentation sprite\n     * @private\n     */\n    _onWinAnimationComplete(animSprite){\n        animSprite.visible = false;\n        Object.values(BonusWheel.wheelItems).forEach(function(wheelItem){\n            wheelItem.show();\n        });\n        this.bgAnimation.visible = false;\n    }\n\n    _initSprite (imageName, blendMode) {\n        var sprite = new PIXI.Sprite.fromImage(StorageManager.getImgPath(imageName));\n\n        sprite.anchor.set(0.5, 0.5);\n        sprite.blendMode = blendMode;\n\n        return sprite;\n    }\n\n    _initEmptySprite () {\n        return new PIXI.Sprite(PIXI.Texture.EMPTY);\n    }\n\n    /**\n     * @param {Array} sectorsNames - list of sectors names on the wheel\n     * @returns {Object} sectorsAngles - config with all the sectors mapped to angles of wheel rotation\n     */\n    _mapSectorsAgles (sectorsNames) {\n        var sectorsNumber = sectorsNames.length,\n            degreesPerSector = CIRCLE_DEG / sectorsNumber,\n            sectorsAngles = {};\n\n        sectorsNames.forEach(function (sectorName, index) {\n            //forced to use array of angles, since we might have multiple sectors for one value\n            //for instance, the key wheel has 6 sectors with 0 and 2 sectors with 1\n            if(!sectorsAngles[sectorName]){\n                sectorsAngles[sectorName] = [];\n            }\n            sectorsAngles[sectorName].push(degreesPerSector * index);\n        });\n\n        return sectorsAngles\n    }\n\n    /**\n     * These are not \"animations\" in common understanding of the Animation.Holder, they are rather tickers,\n     * that perform certain update functions on every frame\n     *\n     * @param {Object} config - wheel config\n     * @returns {Object} list of all available animations\n     */\n    _initAnimations (config) {\n        return {\n            \"accelerationTicker\": this._initAccelerationTicker(config.accelerationDuration),\n            \"uniformRotationTicker\": this._initUnformRotationTicker(),\n            \"decelerationTicker\": this._initDecelerationTicker()\n        }\n    }\n\n    /**\n     * @param {number} accelerationTime - time it will take to accelerate from 0 to maximum speed\n     * @returns {Object} animation holder that gradually(with easing) increases currentSpeed\n     * that will be used in _updateSpriteAngle on each frame for smooth wheel start\n     */\n    _initAccelerationTicker (accelerationTime) {\n        var me = this;\n\n        return new AnimationHolder({\n            target: me,\n            prop: \"currentSpeed\",\n            onUpdate: me._updateSpriteAngle.bind(me),\n            onEnd: me.startUniformRotation.bind(me),\n            animate: [\n                {\n                    time: 0,\n                    value: 0,\n                    ease: Animation.utils.powerTwoOut\n                },\n                //the wheel bounce back on start:\n                {\n                    time: accelerationTime * START_BOUNCE.timeFraction,\n                    value: START_BOUNCE.maxSpeed,\n                    ease: Animation.utils.powerTwoIn\n                },\n                {\n                    time: accelerationTime,\n                    value: me.maxSpeed\n                }\n            ],\n            addToAnimationLoop: true\n        });\n    }\n\n    /**\n     * @returns {Object} animation holder that calls _updateSpriteAngle on every frame\n     * by this moment, the speed reaches maximum value, so this spins the wheel uniformly\n     */\n    _initUnformRotationTicker () {\n        var me = this;\n\n        return new AnimationHolder({\n            onUpdate: me._updateSpriteAngle.bind(me),\n            addToAnimationLoop: true,\n            loop: true\n        });\n    }\n\n    /**\n     * @returns {Object} animation holder that calls decelerateRotation on every frame and smoothly stops the wheel\n     */\n    _initDecelerationTicker () {\n        var me = this;\n\n        return new AnimationHolder({\n            addToAnimationLoop: true,\n            onUpdate: me.decelerateRotation.bind(me),\n            loop: true\n        });\n    }\n\n    startUniformRotation () {\n        var me = this;\n        //resolving promise (there's no callback on restore):\n        me.onWheelStartCallback && me.onWheelStartCallback();\n        //in regular case it would've reached maxSpeed naturally by this moment, but on restores we're forced to set it manually:\n        me.currentSpeed = me.maxSpeed;\n        me.animations.uniformRotationTicker.play();\n    }\n\n    /**\n     *  decreases currentSpeed depending on currentAngle relative to finalAngle\n     *  the closer we are to the finalAngle the slower we go\n     *  calls _updateSpriteAngle to apply new speed\n     */\n    decelerateRotation () {\n        var me = this,\n            currentAngle = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            distanceLeft = me.finalAngle - currentAngle,\n            maxSpeedFraction = distanceLeft / me.stoppingDistance,\n            timePassedFromStart = 1 - maxSpeedFraction;\n\n        me.currentSpeed = Animation.utils.powerTwoIn(me.maxSpeed, 0, timePassedFromStart);\n\n        //proceed with uniform rotation if the speed might become too low:\n        if (me.currentSpeed < me.minSpeed) {\n            me.currentSpeed = me.minSpeed;\n        }\n\n        me._updateSpriteAngle();\n    }\n\n    /**\n     *  Changes the sprite angle by adding currentSpeed to it, stops the deceleration ticker if reached final angle\n     */\n    _updateSpriteAngle () {\n        var me = this,\n            currentRotation = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            timeScale = me.getTimeScale(),\n            newRawRotation = currentRotation + me.currentSpeed * timeScale,\n            newRotation;\n\n        //startBounce completion condition:\n        if(me.prevFrameSpeed < 0 && me.currentSpeed > 0){\n            me.onStartBounceCompleteCallback(me.config.name);\n        }\n\n        if (newRawRotation >= me.finalAngle) {\n            newRotation = me.finalAngle;\n            me.currentSpeed = 0;\n            me.animations.decelerationTicker.stop();\n\n            //resolving promise:\n            me.onWheelStopped();\n        } else {\n            newRotation = newRawRotation;\n        }\n\n        me.sprite.rotation = newRotation * PIXI.DEG_TO_RAD;\n        me.highlightSprite.rotation = me.sprite.rotation;\n        me.prevFrameSpeed = me.currentSpeed;\n    }\n\n    /**\n     *  Returns timescale coefficient to adjust the animation duration on low FPS\n     *\n     *  @returns {number} - deltaTime correction coefficient\n     */\n    getTimeScale () {\n        var me = this,\n            //todo: remove before release:\n            timeScale = 1.5,\n            oneFrameDuration = 1000/60,\n            now = Date.now(),\n            prev = me.lastTick ? me.lastTick : now - oneFrameDuration;\n\n        me.lastTick = now;\n\n        //todo: remove before release:\n        return (now - prev) * timeScale/oneFrameDuration;\n    }\n\n    start (callback) {\n        this.onWheelStartCallback = callback;\n        this.animations.accelerationTicker.play();\n\n        const winSound = this.winSound.cloneNode();\n        winSound.play();\n    }\n\n    startDeceleration (prevWheelStoppingDistance, onWheelStopped) {\n        var me = this;\n\n        me.onWheelStopped = onWheelStopped;\n        me.animations.uniformRotationTicker.stop();\n        me._updateStoppingDistance(prevWheelStoppingDistance);\n        me.animations.decelerationTicker.play();\n\n        this.bgAnimation.visible = true;\n        this.bgAnimation.state.setAnimation(0, 'spin', true);\n    }\n\n    /**\n     *  updates distance to the destination point and final sprite angle at the moment of stopping\n     *  depending on currentAngle, stopAngle and prevWheelStoppingDistance\n     *\n     *  @param {number} prevWheelStoppingDistance - distance, the previous wheel has to cover before full stop\n     */\n    _updateStoppingDistance (prevWheelStoppingDistance) {\n\n        var me = this,\n            currentAngle = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            //using % me.CIRCLE_DEG here to simply calculations:\n            currentAngleReduced = currentAngle % CIRCLE_DEG,\n            angleToFullCircleLeft = CIRCLE_DEG - currentAngleReduced,\n            stopAngle = me.getStoppingAngle(),\n            minDistanceToTarget = angleToFullCircleLeft + stopAngle,\n            //number of 360 degrees wheel revolutions before stop\n            revolutionsBeforeStop = me.getRevolutionsBeforeStop(minDistanceToTarget, prevWheelStoppingDistance);\n\n        me.stoppingDistance = minDistanceToTarget + revolutionsBeforeStop * CIRCLE_DEG;\n        me.finalAngle = currentAngle + me.stoppingDistance;\n    }\n\n    /**\n     * Calculates the number of extra revolutions to make depending on previous wheel stopping distance\n     * (current wheel distance should always be greater than the previous one)\n     *\n     * @param {number} minDistanceToTarget - minimum possible distance between current and final angles\n     * @param {number} prevWheelStoppingDistance - distance the previous wheel will cover before full stop\n     * @returns {number} spinsBeforeStop - number of extra revolutions before full stop\n     */\n    getRevolutionsBeforeStop (minDistanceToTarget, prevWheelStoppingDistance) {\n        var me = this,\n            revsBeforeStop = 0,\n            targetDistance = prevWheelStoppingDistance + MIN_DIFF,\n            currentValue = minDistanceToTarget;\n        \n        while(currentValue < targetDistance){\n            revsBeforeStop++;\n            currentValue = minDistanceToTarget + CIRCLE_DEG * revsBeforeStop;\n        }\n\n        revsBeforeStop = Math.max(revsBeforeStop, me.config.minimumSpinsBeforeStop);\n\n        return revsBeforeStop;\n    }\n\n    /**\n     * Randomly selects from all available sectors angles for itemToStopOn\n     * (for instance, out of 6 options for 0 level on level wheel) and sets it as stopAngle\n     *\n     * @param {number | string} itemToStopOn - value on the sector whe wheel should stop on\n     * @returns {void}\n     */\n    setStoppingAngle (itemToStopOn) {\n        var me = this,\n            targetAngles = me.sectorsAngles[itemToStopOn],\n            targetAnglesCount = targetAngles.length,\n            randomAngleIndex = Math.floor(Math.random() * targetAnglesCount);\n\n        me.stopAngle = targetAngles[randomAngleIndex];\n    }\n\n    getStoppingAngle () {\n        return this.stopAngle;\n    }\n\n    getCurrentStoppingDistance () {\n        return this.stoppingDistance;\n    }\n\n    playGiftAnimation (name, onEndCallback) {\n        console.warn(name);\n        var me = this,\n            gift = me.gift,\n            currentWheelItem = BonusWheel.wheelItems[name];\n\n        currentWheelItem.hide();\n\n        gift.texture = currentWheelItem.texture;\n        gift.visible = true;\n\n        gift.animation.onEnd = function () {\n            me._onWinAnimationComplete(gift);\n            onEndCallback();\n        };\n\n        gift.animation.play();\n\n        me.bgAnimation.state.setAnimation(0, 'win', true);\n    }\n\n    initLogo () {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/logo.png\");\n        sprite.anchor.set(0.5, 0.5);\n        this.addChild(sprite);\n        sprite.position.y = -350;\n\n        return sprite;\n    }\n\n    reset () {\n        var me = this;\n\n        me.stoppingDistance = Infinity;\n        me.finalAngle = Infinity;\n        me.sprite.rotation = 0;\n        me.currentSpeed = 0;\n        me.lastTick = 0;\n    }\n\n    startStopping () {\n        var me = this;\n\n        return new Promise(function (resolve) {\n            me.startDeceleration(0, function () {\n                resolve();\n            })\n        })\n    }\n\n    static changeTexture(name, texture){\n        const wildSubstr = RegExp(\"wild\");\n        BonusWheel.wheelItems[name].texture = texture;\n        BonusWheel.wheelItems[name].updateSize();\n    }\n\n    refresh () {\n        if(window.innerHeight > window.innerWidth){\n            //portrait\n            this.background.rotation = (Math.PI/2);\n            this.logo.position.set(LOGO_POSITION.portrait.x, LOGO_POSITION.portrait.y);\n        } else {\n            //landscape\n            this.background.rotation = (Math.PI*2);\n            this.logo.position.set(LOGO_POSITION.landscape.x, LOGO_POSITION.landscape.y);\n        }\n\n    }\n}\n\nwindow.WHEEL = BonusWheel\n","const WHEEL_ITEM_CONFIG = {\n    width: 110,\n    height: 110\n};\nconst WILD_ITEM_CONFIG = {\n    width: 150,\n    height: 150,\n}\n\nexport class BonusWheelItem extends PIXI.Sprite {\n    /**\n     *\n     * @param {object} config - wheelItem config\n     * @param {PIXI.Container|PIXI.Sprite} config.parent - Display object, the wheelItem will be added to\n     * @param {PIXI.Texture} config.texture - wheelItem texture\n     * @param {number} config.sectorIndex - sector the item is added to\n     * @param {number} config.centerOffset - distance from wheel center to wheelItem center\n     * @param {number} config.totalSectorsNum - total number of sectors on the parent wheel\n     */\n    constructor (config) {\n        super(config.texture);\n        config.parent.addChild(this);\n\n        this.anchor.set(0.5);\n        this.scale.set(config.scale);\n        this.updatePositionAndRotation(config.totalSectorsNum, config.sectorIndex, config.centerOffset);\n        this.updateSize();\n    }\n\n    /**\n     * Positions the item to the proper sector and rotates in a way that item's bottom is directed\n     * to the wheel center;\n     *\n     * @param {number} totalSectorsNum - total number of sectors on the parent wheel\n     * @param {number} sectorIndex - sector the item is added to\n     * @param {number} centerOffset - distance from wheel center to wheelItem center\n     */\n    updatePositionAndRotation(totalSectorsNum, sectorIndex, centerOffset){\n        var me = this,\n            angle = (2 * Math.PI / totalSectorsNum) * sectorIndex,\n            y = - centerOffset * Math.cos(angle),\n            x = - centerOffset * Math.sin(angle);\n\n        me.position.set(x, y);\n        me.rotation = -angle;\n    }\n\n    hide(){\n        this.visible = false;\n    }\n\n    show(){\n        this.visible = true;\n    }\n\n    updateSize() {\n        const wildSubstr = RegExp(\"wild\");\n        const isWild = wildSubstr.test(this.texture.baseTexture.imageUrl);\n        if(isWild){\n            this.width = WILD_ITEM_CONFIG.width;\n            this.height = WILD_ITEM_CONFIG.height;\n        } else {\n            this.width = WHEEL_ITEM_CONFIG.width;\n            this.height = WHEEL_ITEM_CONFIG.height;\n        }\n    }\n}\n","const CONFIG = {\n    x: 100,\n    y: 10\n};\n\nexport class FullScreenButton extends PIXI.Sprite {\n    constructor () {\n        super();\n\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/fullscreen.png\");\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n\n        this.currentState = \"off\";\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"off\"){\n            this.currentState = \"on\";\n            document.documentElement.requestFullscreen();\n        } else if (this.currentState === \"on\"){\n            this.currentState = \"off\";\n            document.exitFullscreen();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n}","import {StorageManager} from \"./StorageItemsManager\";\nimport {imagesConfig} from \"./imagesConfig\";\n\nconst OFFSET = 10;\nconst TOP_OFFSET = 80;\n\nexport class Menu extends PIXI.Container{\n    constructor () {\n        super();\n\n        const itemsListContainer = new PIXI.Container();\n        const imageSelectorContainer = this.createImageSelectorInterface();\n        itemsListContainer.position.y = TOP_OFFSET;\n\n        let itemsList = StorageManager.getLocalStorageItem(\"itemsList\");\n        if (typeof itemsList.SYM0 === \"undefined\"){\n            window.localStorage.clear();\n            StorageManager.initStorage();\n            itemsList = StorageManager.getLocalStorageItem(\"itemsList\");\n        }\n        Menu.itemGroups = this.createItemsListInterface(itemsList, itemsListContainer);\n\n        this.addChild(itemsListContainer);\n        this.addChild(imageSelectorContainer);\n\n        this.hideMenu();\n        imageSelectorContainer.visible = false;\n        this.imageSelectorContainer = imageSelectorContainer;\n    }\n\n    onStorageUpdated () {\n        console.log(\"updating the storage\");\n        const itemsList = StorageManager.getLocalStorageItem(\"itemsList\");\n        Menu.itemGroups.forEach(function (item, index) {\n            item.countText.text = itemsList[\"SYM\" + index].count;\n        });\n\n    }\n\n    showMenu () {\n        this.visible = true;\n    }\n\n    hideMenu () {\n        this.visible = false;\n    }\n\n    createItemsListInterface (itemsList, parentContainer) {\n        var me = this,\n            itemGroup, itemGroups = [];\n\n        PIXI.loader\n            .load(\n                Object.values(itemsList).forEach(function (item, itemIndex) {\n                    item.name = Object.keys(itemsList)[itemIndex];\n                    itemGroup = me.createItemContainer(parentContainer, item, itemIndex);\n                    itemGroups[itemIndex] = itemGroup;\n                })\n            );\n\n        return itemGroups;\n    }\n\n    createImageSelectorInterface () {\n        const container = new PIXI.Container();\n        const me = this;\n        container.position.set(200, TOP_OFFSET);\n\n        PIXI.loader\n            .load(\n                Object.values(imagesConfig).forEach(function (imagePath, imageIndex) {\n                    const texture = new PIXI.Texture.from(imagePath);\n                    const itemImage = new PIXI.Sprite(texture);\n\n                    itemImage.height = 28;\n                    itemImage.width = 28;\n                    itemImage.position.set(0, 28 * imageIndex);\n                    itemImage.interactive = true;\n                    itemImage.buttonMode = true;\n                    itemImage.on('pointerdown', me.onNewImgSelected.bind(me, imagePath));\n\n                    container.addChild(itemImage);\n                })\n            );\n\n        this.addItemsListBg(container);\n        return container;\n    }\n\n    onNewImgSelected(imagePath){\n        this.targetSprite.texture = new PIXI.Texture.from(imagePath);\n        StorageManager.setNewImgPath(this.targetName, imagePath);\n    }\n\n    createItemContainer (parentContainer, item, itemIndex) {\n        const itemContainer = new PIXI.Container();\n        let itemGroup = {};\n\n        itemGroup.button = this.addButton(itemContainer, item.name, itemIndex);\n        itemGroup.countText = this.addTxt(itemContainer, item.count);\n        itemGroup.buttons = this.addPlusMinusButtons(itemContainer, itemIndex, item.count);\n        itemContainer.position.set(OFFSET, (OFFSET * itemIndex) + (itemIndex * itemContainer.height));\n\n        this.addItemsListBg(itemContainer);\n\n        parentContainer.addChild(itemContainer);\n        return itemGroup;\n    }\n\n    addItemsListBg (container) {\n        var graphics = new PIXI.Graphics();\n\n        graphics.beginFill(0x3d5c5c);\n        graphics.lineStyle(2, 0xDE3249, 1);\n        graphics.drawRect(0, 0, container.width, container.height);\n        graphics.endFill();\n        graphics.blendMode = 2;\n\n        container.addChildAt(graphics, 0);\n    }\n\n    addButton (parentContainer, name) {\n        const texture = new PIXI.Texture.from(StorageManager.getImgPath(name));\n        console.warn(texture);\n        const itemImage = new PIXI.Sprite(texture);\n        const me = this;\n\n        itemImage.height = 50;\n        itemImage.width = 50;\n        itemImage.interactive = true;\n        itemImage.buttonMode = true;\n        itemImage.on('pointerdown', me.onItemClick.bind(me, itemImage, name));\n\n        parentContainer.addChild(itemImage);\n    }\n\n    addTxt (parentContainer, count) {\n        const style = new PIXI.TextStyle({\n                fill: '#d8df75',\n                fontSize: 15,\n                fontFamily: 'Arial'\n            }),\n            txt = new PIXI.Text(count, style);\n\n        txt.anchor.set(0.5);\n        txt.position.set(100, parentContainer.width / 2);\n\n        parentContainer.addChild(txt);\n        return txt;\n    }\n\n    addPlusMinusButtons (parentContainer, itemIndex) {\n        const me = this;\n        let buttons = {};\n\n        buttons.plusButton = me.initIncrementButton(\n            {\n                x: 160,\n                y: 0,\n                width: 20,\n                height: 20,\n                texture: new PIXI.Texture.from(\"assets/images/buttons/plus.png\"),\n                callback: me.onPlusButtonClick.bind(me, itemIndex),\n                parentContainer: parentContainer\n            });\n\n        buttons.minusButton = me.initIncrementButton(\n            {\n                x: 160,\n                y: 30,\n                width: 20,\n                height: 20,\n                texture: new PIXI.Texture.from(\"assets/images/buttons/minus.png\"),\n                callback: me.onMinusButtonClick.bind(me, itemIndex),\n                parentContainer: parentContainer\n            });\n\n        return buttons;\n    }\n\n    initIncrementButton (config) {\n        let button = new PIXI.Sprite(config.texture);\n\n        button.position.set(config.x, config.y);\n        button.interactive = true;\n        button.buttonMode = true;\n        button.width = config.width;\n        button.height = config.height;\n        button.on(\"pointerdown\", config.callback);\n        config.parentContainer.addChild(button);\n\n        return button;\n    }\n\n    onPlusButtonClick (itemIndex) {\n        StorageManager.addItem(itemIndex, 1);\n        this.updateCountText(itemIndex);\n    }\n\n    onMinusButtonClick (itemIndex) {\n        StorageManager.removeItem(itemIndex, 1);\n        this.updateCountText(itemIndex);\n    }\n\n    updateCountText (itemIndex) {\n        Menu.itemGroups[itemIndex].countText.text = StorageManager.getLocalStorageItem(\"itemsList\")[\"SYM\" + itemIndex].count;\n    }\n\n    onItemClick (targetSprite, targetName) {\n        this.targetSprite = targetSprite;\n        this.targetName = targetName;\n        this.imageSelectorContainer.visible = !this.imageSelectorContainer.visible;\n    }\n}\n","const CONFIG = {\n    x: 10,\n    y: 10\n};\n\nexport class OpenCloseButton extends PIXI.Sprite{\n\n    constructor (menu) {\n        super();\n\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.openCallback = menu.showMenu.bind(menu);\n        this.closeCallback = menu.hideMenu.bind(menu);\n\n        this.currentState = \"closed\";\n        this.setClosedTexture();\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"closed\"){\n            this.currentState = \"opened\";\n            this.setOpenedTexture();\n            this.openCallback();\n        } else if (this.currentState === \"opened\"){\n            this.currentState = \"closed\";\n            this.setClosedTexture();\n            this.closeCallback();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n\n    setClosedTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/settings.png\")\n    }\n\n    setOpenedTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/error.png\")\n    }\n\n    onForseClosed () {\n        this.currentState = \"closed\";\n        this.setClosedTexture();\n        this.closeCallback();\n    }\n}","const CONFIG = {\n    x: 20,\n    y: 100,\n    width: 15,\n    height: 15,\n};\n\nexport class ResetButton extends PIXI.Sprite {\n    constructor () {\n        super();\n\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/reset.png\");\n        this.position.set(CONFIG.x, window.innerHeight - 50);\n        this.width = CONFIG.width;\n        this.height = CONFIG.height;\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n    }\n\n    onButtonClick () {\n        const confirmed = confirm(\"Are you sure to reset all values and images to default? You may lose your progress.\");\n\n        if(confirmed){\n            window.localStorage.clear();\n            location.reload();\n        }\n    }\n}","const CONFIG = {\n    x: 50,\n    y: 10\n};\n\nexport class SoundButton extends PIXI.Sprite {\n    constructor () {\n        super();\n\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.ambientSound = document.getElementById(\"ambienceSound\");\n        this.ambientSound.loop = true;\n        this.currentState = \"off\";\n        this.setOffTexture();\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"off\"){\n            this.currentState = \"on\";\n            this.setOnTexture();\n            this.soundOn();\n        } else if (this.currentState === \"on\"){\n            this.currentState = \"off\";\n            this.setOffTexture();\n            this.soundOff();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n\n    soundOn () {\n        this.ambientSound.play();\n    }\n\n    soundOff () {\n        this.ambientSound.pause();\n    }\n\n    setOffTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/soundOff.png\")\n    }\n\n    setOnTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/soundOn.png\")\n    }\n}","import {BonusWheel} from \"./BonusWheel\";\n\nexport class StorageManager{\n    static initStorage () {\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(\n                {\n                    SYM0: {count: 1, imgPath: \"assets/images/prizes/wild.png\"},\n                    SYM1: {count: 5, imgPath: \"assets/images/prizes/bag.png\"},\n                    SYM2: {count: 5, imgPath: \"assets/images/prizes/bottle.png\"},\n                    SYM3: {count: 5, imgPath: \"assets/images/prizes/bag_laptop.png\"},\n                    SYM4: {count: 5, imgPath: \"assets/images/prizes/certificate.png\"},\n                    SYM5: {count: 5, imgPath: \"assets/images/prizes/fly.png\"},\n                    SYM6: {count: 5, imgPath: \"assets/images/prizes/memory_card.png\"},\n                    SYM7: {count: 5, imgPath: \"assets/images/prizes/pen.png\"},\n                    SYM8: {count: 5, imgPath: \"assets/images/prizes/notebook.png\"},\n                    SYM9: {count: 5, imgPath: \"assets/images/prizes/pendant.png\"},\n                    SYM10: {count: 7, imgPath: \"assets/images/prizes/phone_cover.png\"},\n                    SYM11: {count: 5, imgPath: \"assets/images/prizes/powerbank.png\"},\n                }\n            )\n        );\n\n\n    }\n\n    static getImgPath (name) {\n        if(name === \"EMPTY\"){\n            return \"assets/images/prizes/EMPTY.png\";\n        }\n        return this.getLocalStorageItem(\"itemsList\")[name].imgPath;\n    }\n\n    static setNewImgPath (name, newPath) {\n        const itemsList = this.getLocalStorageItem(\"itemsList\");\n        itemsList[name].imgPath = newPath;\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(itemsList));\n        BonusWheel.changeTexture(name, new PIXI.Texture.from(newPath));\n    }\n\n\n    static randomInt (min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    static getLocalStorageItem(name) {\n        return JSON.parse(window.localStorage.getItem(name))\n    }\n\n    static getSectorItemsList () {\n        return Object.keys(this.getLocalStorageItem(\"itemsList\"));\n    }\n\n    static addItems (itemName, amount) {\n        const itemsList = this.getLocalStorageItem(\"itemsList\");\n\n        itemsList[itemName].count += amount;\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(itemsList));\n    }\n\n    static removeItems (itemName, amount) {\n        const itemsList = this.getLocalStorageItem(\"itemsList\");\n\n        if(itemsList[itemName].count - amount > 0){\n            itemsList[itemName].count -= amount;\n        } else {\n            itemsList[itemName].count = 0;\n        }\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(itemsList));\n    }\n\n    static addItem (index, amount) {\n        console.log(\"index: \", index, \"amount: \", amount);\n        const itemsList = this.getLocalStorageItem(\"itemsList\");\n\n        console.warn(itemsList[\"SYM\"+index].count, amount);\n        itemsList[\"SYM\"+index].count += amount;\n\n        console.error(itemsList);\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(itemsList));\n    }\n\n\n    static removeItem (index, amount) {\n        const itemsList = this.getLocalStorageItem(\"itemsList\");\n\n        if(itemsList[\"SYM\"+index].count - amount > 0){\n            itemsList[\"SYM\"+index].count -= amount;\n        } else {\n            itemsList[\"SYM\"+index].count = 0;\n        }\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(itemsList));\n    }\n\n    static setItemCount (index, amount) {\n        const itemsList = this.getLocalStorageItem(\"itemsList\");\n\n        itemsList[\"SYM\"+index] = amount;\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(itemsList));\n    }\n\n    static countItemsProbabilities (items, total) {\n        var probabilities = [];\n\n        Object.values(items).forEach(function (item) {\n            probabilities.push(Math.floor(item.count * 100 / total));\n        });\n\n        return probabilities;\n    }\n\n    static countTotalItemsSum (itemsList) {\n        var sum = 0;\n\n        Object.values(itemsList).forEach(function (item) {\n            sum += item.count;\n        });\n\n        return sum;\n    }\n\n    static getRandomItemAccordingToProbability () {\n        var itemsList = this.getLocalStorageItem(\"itemsList\"),\n            totalItemsSum = this.countTotalItemsSum(itemsList),\n            itemsProbabilities = this.countItemsProbabilities(itemsList, totalItemsSum),\n            probabilityArray = [],\n            random;\n\n        console.warn({itemsProbabilities});\n        Object.values(itemsList).forEach(function (item, idx) {\n            for (var i = 0; i < itemsProbabilities[idx]; i++) {\n                probabilityArray.push(idx);\n            }\n        });\n\n        console.error({probabilityArray});\n\n        random = this.randomInt(0, (probabilityArray.length - 1));\n        console.log({random});\n\n        return probabilityArray.sort(() => Math.random() - 0.5)[random];\n    }\n\n    static isNoMoreItems () {\n        return Object.values(this.getLocalStorageItem(\"itemsList\")).every(item => item.count === 0);\n    }\n\n    static findSectorToStopOn () {\n        var me = this,\n            randomIndex = me.getRandomItemAccordingToProbability(),\n            itemsList = this.getLocalStorageItem(\"itemsList\"),\n            randomItem = Object.values(itemsList)[randomIndex];\n\n        if (randomItem.count > 0) {\n            randomItem.count--;\n            window.localStorage.setItem(\"itemsList\", JSON.stringify(itemsList));\n\n            return randomIndex;\n        } else {\n            console.warn(\"no more \", randomItem.name);\n            debugger;\n            return me.findSectorToStopOn();\n        }\n    }\n}\n\nwindow.test = StorageManager;\n\n","export const imagesConfig = {\n    backpack: \"assets/images/prizes/backpack.png\",\n    bag_laptop: \"assets/images/prizes/bag_laptop.png\",\n    bag: \"assets/images/prizes/bag.png\",\n    bottle: \"assets/images/prizes/bottle.png\",\n    certificate: \"assets/images/prizes/certificate.png\",\n    fly: \"assets/images/prizes/fly.png\",\n    memory_card: \"assets/images/prizes/memory_card.png\",\n    notebook: \"assets/images/prizes/notebook.png\",\n    pen: \"assets/images/prizes/pen.png\",\n    pendant: \"assets/images/prizes/pendant.png\",\n    phone_cover: \"assets/images/prizes/phone_cover.png\",\n    powerbank: \"assets/images/prizes/powerbank.png\",\n    signal: \"assets/images/prizes/signal.png\",\n    towel: \"assets/images/prizes/towel.png\",\n    SYM1_old: \"assets/images/prizes/SYM1_old.png\",\n    SYM2_old: \"assets/images/prizes/SYM2_old.png\",\n    SYM3_old: \"assets/images/prizes/SYM3_old.png\",\n    SYM4_old: \"assets/images/prizes/SYM4_old.png\",\n    SYM5_old: \"assets/images/prizes/SYM5_old.png\",\n    SYM7_old: \"assets/images/prizes/SYM7_old.png\",\n    SYM8_old: \"assets/images/prizes/SYM8_old.png\",\n    SYM9_old: \"assets/images/prizes/SYM9_old.png\",\n    SYM10_old: \"assets/images/prizes/SYM10_old.png\",\n    SYM11_old: \"assets/images/prizes/SYM11_old.png\",\n    SYM12_old: \"assets/images/prizes/SYM12_old.png\",\n    run: \"assets/images/prizes/run.png\",\n    wild: \"assets/images/prizes/wild.png\",\n};\n","import {SoundButton} from \"./SoundButton\";\nimport {ResetButton} from \"./ResetButton\";\nimport {FullScreenButton} from \"./FullScreenButton\";\nimport {StorageManager} from \"./StorageItemsManager\";\nimport {BonusWheel} from \"./BonusWheel\";\nimport {OpenCloseButton} from \"./OpenCloseButton\";\nimport {Menu} from \"./Menu\";\n\nexport const animationBuffer = [];\n\nvar app = new PIXI.Application(window.innerWidth, window.innerHeight, {backgroundColor : 0x000000});\ndocument.body.appendChild(app.view);\n\nvar prerenderCallbacks = [animate],\n    lastTimeStepOccured = 0,\n    currentStepTime = 0,\n    currentTime = 0;\n\nlastTimeStepOccured = updateTime();\n\nfunction updateTime() {\n    var now = Date.now(),\n        diff = now - lastTimeStepOccured;\n\n    // Check if more time than allowed has passed since the last frame\n    if (diff > 250) {\n        diff = 1000 / 60;\n    }\n\n    currentStepTime = diff | 0;\n    currentTime += currentStepTime;\n\n    return now;\n}\n\nif(!window.localStorage.getItem(\"itemsList\")) {\n    StorageManager.initStorage();\n}\n\nfunction animate(){\n    animationBuffer.forEach(function(holder){\n        if ( holder.running ){\n            holder.run({\n                timeStep: currentStepTime,\n                time: currentTime\n            });\n        }\n    });\n}\n\n\n// Listen for animate update\napp.ticker.add(function(delta) {\n    prerenderCallbacks.forEach(function(cb) {\n        cb();\n    });\n});\n\n\n\nconst menu = new Menu();\n\nvar wheel = new BonusWheel(function () {\n    menu.onStorageUpdated();\n}, app);\n\n// move the sprite to the center of the screen\nwheel.position.set(app.screen.width / 2, app.screen.height / 2);\n\nwindow.addEventListener(\"resize\", function() {\n    app.renderer.resize(window.innerWidth, window.innerHeight);\n    wheel.position.set(window.innerWidth / 2, window.innerHeight / 2);\n});\n\n\n\nconst soundButton = new SoundButton();\nconst fullScreenButton = new FullScreenButton();\nconst openCloseButton = new OpenCloseButton(menu);\nconst resetButton = new ResetButton();\n\napp.stage.addChild(wheel);\napp.stage.addChild(menu);\napp.stage.addChild(soundButton);\napp.stage.addChild(openCloseButton);\napp.stage.addChild(fullScreenButton);\napp.stage.addChild(resetButton);\nwindow.resetButton = resetButton;\n\ndocument.documentElement.webkitRequestFullscreen();\n\n\nwindow.addEventListener(\"resize\", refresh);\nfunction refresh() {\n    wheel.refresh();\n}\n\ndocument.addEventListener(\"keydown\", function(event) {\n    if(event.keyCode === 32){\n        document.removeEventListener(\"keydown\", keyDownHandler);\n        wheel.onSpinButtonDown();\n\n        setTimeout(() => {\n            wheel.releaseHardButton(() => {document.addEventListener(\"keydown\", keyDownHandler)});\n        }, 300);\n    }\n});"],"sourceRoot":""}