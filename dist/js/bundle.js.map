{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/SoundButton.js","webpack:///./js/FullScreenButton.js","webpack:///./js/StorageItemsManager.js","webpack:///./js/BonusWheelItem.js","webpack:///./js/AnimationHolder.js","webpack:///./js/BonusWheel.js","webpack:///./js/OpenCloseButton.js","webpack:///./js/Menu.js","webpack:///./js/main.js","webpack:///./js/ScrollContainer.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","CONFIG","x","y","FullScreenButton_CONFIG","StorageManager","[object Object]","window","localStorage","setItem","JSON","stringify","count","min","max","Math","floor","random","list","parse","getItem","forEach","item","push","itemName","amount","updatedList","map","index","itemIdx","items","total","probabilities","itemsList","sum","totalItemsSum","this","countTotalItemsSum","itemsProbabilities","countItemsProbabilities","probabilityArray","idx","randomInt","every","randomIndex","getRandomItemAccordingToProbability","randomItem","console","error","warn","findSectorToStopOn","BonusWheelItem","PIXI","Sprite","config","super","texture","parent","addChild","anchor","set","scale","updatePositionAndRotation","totalSectorsNum","sectorIndex","centerOffset","angle","PI","cos","sin","position","rotation","visible","AnimationHolder_AnimationHolder","me","defaultProp","id","undefined","target","prop","animation","keyFrames","step","complete","running","playbackSpeed","loop","readyToLoop","onStart","onEnd","onUpdate","children","localTime","delay","startTimeOffset","addToAnimationLoop","Sys","applyProperties","parseConfig","animationBuffer","obj","properties","timeSort","a","b","time","iterate","isObj","frameValue","parseInt","isDefined","length","sort","isArray","tempChildrenContainer","child","timeObj","timeStep","doAnimation","run","restoreOnLoop","restore","currentStepTime","performAction","root","isRoot","handleItems","runParent","restoreAnimation","play","callback","callbackCompleted","animate","type","selection","setParent","byKey","searchChildren","result","subResult","numKeyFrames","currentTime","increaseAnimationTime","currentKeyFrame","nextKeyFrame","handleCallback","progressKeyFrame","calculate","toIndex","goTo","doGoTo","keyFrame","currentStep","nextStep","calculateTime","from","to","Animation","utils","getInterpolationValue","ease","fireImmediately","isString","func","scope","fireEvent","args","isFunc","apply","Game","stage","view","animationManager","callbackContainer","totalTime","updateOperation","CIRCLE_DEG","MIN_DIFF","START_BOUNCE","maxSpeed","timeFraction","WHEEL_ITEMS_CENTER_OFFSET","WHEEL_ITEM_CONFIG","width","height","OpenCloseButton_CONFIG","OFFSET","TOP_OFFSET","__webpack_exports__","app","Application","innerWidth","innerHeight","backgroundColor","document","body","appendChild","ambientSound","Audio","main_winSound","soundButton","interactive","buttonMode","on","onButtonClick","soundOn","soundOff","currentState","setOnTexture","setOffTexture","Texture","volume","docEl","documentElement","requestFullScreen","requestFullscreen","webkitRequestFullscreen","mozRequestFullScreen","msRequestFullscreen","exitFullscreen","webkitExitFullscreen","mozExitFullScreen","msExitFullscreen","fullScreenButton","enterFullscreenMode","exitFullscreenMode","scrollContainer","Container","itemHeight","po","mask","Graphics","beginFill","drawRect","endFill","mousedown","lastPos","lastDiff","scrollTween","mousemove","e","onmousemove","onmousedown","mouseup","onmouseup","mouseupoutside","touchmove","touchstart","touchend","touchendoutside","originalEvent","data","clientY","touches","kill","goY","Quad","easeOut","abs","Back","Elastic","TweenMax","startIndex","endIndex","prerenderCallbacks","holder","lastTimeStepOccured","now","Date","diff","updateTime","initStorage","main_wheel","onStartBounceCompleteCallback","sectorItemsList","background","_initBackground","_initBgSpine","minSpeed","sprite","_initWheelSprite","spinButton","initSpinButton","wheelItems","_initWheelItems","highlightSprite","image","_initSprite","BLEND_MODES","ADD","_initEmptySprite","sectorsAngles","_mapSectorsAgles","sectors","animations","_initAnimations","pick","_initPickSprite","gift","_initGiftSprite","reset","refresh","container","imageName","fromImage","spineName","glow","loader","add","load","res","spine","Spine","spineData","skeleton","setToSetupPose","update","autoUpdate","state","setAnimation","ticker","bgAnimation","wheel","actionDown","deviceAPI","deviceType","actionUp","sectorToStopOn","itemsLeft","isNoMoreItems","winSound","start","setStoppingAngle","startStopping","then","playGiftAnimation","sizedContainer","bonusWheelItem","whellItems","NORMAL","200","1500","5000","5500","animSprite","wheelItem","show","blendMode","EMPTY","sectorsNames","sectorsNumber","degreesPerSector","sectorName","accelerationTicker","_initAccelerationTicker","accelerationDuration","uniformRotationTicker","_initUnformRotationTicker","decelerationTicker","_initDecelerationTicker","accelerationTime","_updateSpriteAngle","startUniformRotation","powerTwoOut","powerTwoIn","decelerateRotation","onWheelStartCallback","currentSpeed","currentAngle","RAD_TO_DEG","timePassedFromStart","finalAngle","stoppingDistance","newRotation","currentRotation","timeScale","getTimeScale","newRawRotation","prevFrameSpeed","stop","onWheelStopped","DEG_TO_RAD","prev","lastTick","prevWheelStoppingDistance","_updateStoppingDistance","minDistanceToTarget","getStoppingAngle","revolutionsBeforeStop","getRevolutionsBeforeStop","revsBeforeStop","targetDistance","currentValue","minimumSpinsBeforeStop","itemToStopOn","targetAngles","targetAnglesCount","randomAngleIndex","stopAngle","onEndCallback","currentItemIndex","round","currentWheelItem","hide","_onWinAnimationComplete","Infinity","Promise","resolve","startDeceleration","itemIndex","spineSlot","highlightSlot","getSectorItemsList","menu","onStorageUpdated","screen","addEventListener","renderer","resize","delta","cb","hideOffscreenElements","openCloseButton","openCallback","closeCallback","setClosedTexture","setOpenedTexture","showMenu","hideMenu","onItemImgChange","onCountChange","input","createElement","accept","onchange","updateImageLocally","itemsListContainer","itemGroups","createItemsListInterface","log","countText","text","parentContainer","itemGroup","createItemContainer","itemContainer","button","addButton","addTxt","buttons","addPlusMinusButtons","addItemsListBg","graphics","lineStyle","addChildAt","itemImage","onItemClick","style","TextStyle","fill","fontSize","fontFamily","txt","Text","plusButton","initIncrementButton","onPlusButtonClick","minusButton","onMinusButtonClick","newCount","updateCountText","currentCount","targetSprite","getElementById","click","file","files","reader","FileReader","onload","setTexture","readAsDataURL","changeTexture","setItemCount"],"mappings":"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","file":"./js/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const CONFIG = {\n    x: 50,\n    y: 10\n};\n\nexport class SoundButton extends PIXI.Sprite {\n    constructor (config) {\n        super();\n\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.soundOn = config.soundOn;\n        this.soundOff = config.soundOff;\n\n        this.currentState = \"on\";\n        this.setOnTexture();\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"off\"){\n            this.currentState = \"on\";\n            this.setOnTexture();\n            this.soundOn();\n        } else if (this.currentState === \"on\"){\n            this.currentState = \"off\";\n            this.setOffTexture();\n            this.soundOff();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n\n    setOffTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/soundOff.png\")\n    }\n\n    setOnTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/soundOn.png\")\n    }\n}","const CONFIG = {\n    x: 100,\n    y: 10\n};\n\nexport class FullScreenButton extends PIXI.Sprite {\n    constructor (config) {\n        super();\n\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/fullscreen.png\");\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.enterFullscreenMode = config.enterFullscreenMode;\n        this.exitFullscreenMode = config.exitFullscreenMode;\n\n        this.currentState = \"off\";\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"off\"){\n            this.currentState = \"on\";\n            this.enterFullscreenMode();\n        } else if (this.currentState === \"on\"){\n            this.currentState = \"off\";\n            this.exitFullscreenMode();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n}","export class StorageManager{\n    static initStorage () {\n        window.localStorage.setItem(\"itemsList\", JSON.stringify([\n                {name: \"SYM0\", count: 2},\n                {name: \"SYM1\", count: 1},\n                {name: \"SYM2\", count: 4},\n                {name: \"SYM3\", count: 3},\n                {name: \"SYM4\", count: 5},\n                {name: \"SYM5\", count: 1},\n                {name: \"SYM6\", count: 3},\n                {name: \"SYM7\", count: 3},\n                {name: \"SYM8\", count: 2},\n                {name: \"SYM9\", count: 2},\n                {name: \"SYM10\", count: 3},\n                {name: \"SYM11\", count: 1}\n            ])\n        );\n    }\n\n    static randomInt (min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    static getSectorItemsList () {\n        var list = [];\n\n        JSON.parse(window.localStorage.getItem(\"itemsList\")).forEach(function (item) {\n            list.push(item.name);\n        });\n\n        return list;\n    }\n\n    static addItems (itemName, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item) {\n                if (itemName === item.name) {\n                    item.count += amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static removeItems (itemName, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item) {\n                if (itemName === item.name) {\n                    if (item.count - amount > 0) {\n                        item.count -= amount;\n                    } else {\n                        item.count = 0;\n                    }\n                }\n                return item\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static addItem (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    item.count += amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n\n    static removeItem (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    if (item.count - amount > 0) {\n                        item.count -= amount;\n                    } else {\n                        item.count = 0;\n                    }\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static setItemCount (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    item.count = amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static countItemsProbabilities (items, total) {\n        var probabilities = [];\n\n        items.forEach(function (item) {\n            probabilities.push(Math.floor(item.count * 100 / total));\n        });\n\n        return probabilities;\n    }\n\n    static countTotalItemsSum (itemsList) {\n        var sum = 0;\n\n        itemsList.forEach(function (item) {\n            sum += item.count;\n        });\n\n        return sum;\n    }\n\n    static getRandomItemAccordingToProbability () {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            totalItemsSum = this.countTotalItemsSum(itemsList),\n            itemsProbabilities = this.countItemsProbabilities(itemsList, totalItemsSum),\n            probabilityArray = [],\n            random;\n\n        itemsList.forEach(function (item, idx) {\n            for (var i = 0; i < itemsProbabilities[idx]; i++) {\n                probabilityArray.push(idx);\n            }\n        });\n\n        random = this.randomInt(0, 100);\n\n        return probabilityArray[random];\n    }\n\n    static isNoMoreItems () {\n        return JSON.parse(window.localStorage.getItem(\"itemsList\")).every(item => item.count === 0);\n    }\n\n    static findSectorToStopOn () {\n        var me = this,\n            randomIndex = me.getRandomItemAccordingToProbability(),\n            itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            randomItem = itemsList[randomIndex];\n\n        console.error(randomItem);\n\n        if (randomItem.count > 0) {\n            randomItem.count--;\n            window.localStorage.setItem(\"itemsList\", JSON.stringify(itemsList));\n\n            return randomIndex;\n        } else {\n            console.warn(\"no more \", randomItem.name);\n            debugger;\n            return me.findSectorToStopOn();\n        }\n    }\n}\n\n\n","export class BonusWheelItem extends PIXI.Sprite {\n    /**\n     *\n     * @param {object} config - wheelItem config\n     * @param {PIXI.Container|PIXI.Sprite} config.parent - Display object, the wheelItem will be added to\n     * @param {PIXI.Texture} config.texture - wheelItem texture\n     * @param {number} config.sectorIndex - sector the item is added to\n     * @param {number} config.centerOffset - distance from wheel center to wheelItem center\n     * @param {number} config.totalSectorsNum - total number of sectors on the parent wheel\n     */\n    constructor (config) {\n        super(config.texture);\n        config.parent.addChild(this);\n\n        this.anchor.set(0.5);\n        this.scale.set(config.scale);\n        this.updatePositionAndRotation(config.totalSectorsNum, config.sectorIndex, config.centerOffset);\n    }\n\n    /**\n     * Positions the item to the proper sector and rotates in a way that item's bottom is directed\n     * to the wheel center;\n     *\n     * @param {number} totalSectorsNum - total number of sectors on the parent wheel\n     * @param {number} sectorIndex - sector the item is added to\n     * @param {number} centerOffset - distance from wheel center to wheelItem center\n     */\n    updatePositionAndRotation(totalSectorsNum, sectorIndex, centerOffset){\n        var me = this,\n            angle = (2 * Math.PI / totalSectorsNum) * sectorIndex,\n            y = - centerOffset * Math.cos(angle),\n            x = - centerOffset * Math.sin(angle);\n\n        me.position.set(x, y);\n        me.rotation = -angle;\n    }\n\n    hide(){\n        this.visible = false;\n    }\n\n    show(){\n        this.visible = true;\n    }\n}","import {animationBuffer} from \"./main\"\n\nexport class AnimationHolder {\n    /**\n     * @property {String} [id=\"\"] The identifier for this animation, if you don't specify one we will try to use\n     * parent.id + \":\" + prop + \"Animation\"\n     */\n    /**\n     * @property {Object} [target=undefined] The target object we want to animate, if you don't specify one we will\n     * try to use the parent.target\n     */\n    /**\n     * @property {String} [prop=undefined] The name of the properties on the target we want to change\n     */\n    /**\n     * @property {Boolean} [running=false] If the animation is active\n     */\n    /**\n     * @property {Number} [playbackSpeed=undefined] If we want to play the animation faster (>1) or slower (<1)\n     */\n    /**\n     * @property {Boolean} [loop=false] Will repeat the whole animation. If it have separate operations with different\n     * time the shorter ones will wait at the end key frame until the longest is done. onStart & onEnd will not be\n     * called every loop (if that is needed, set callbacks on key frames instead). Will also wait for all it's\n     * children to complete.\n     */\n    /**\n     * @property {Boolean} [readyToLoop=false] Since we sometime need to wait for our children we use this to know\n     * when we can loop back to the start.\n     */\n    /**\n     * @property {Function} [onStart=undefined] Callback function before the animation starts\n     */\n    /**\n     * @property {Function} [onEnd=undefined] Callback function when the animation is complete\n     */\n    /**\n     * @property {Function} [onUpdate=undefined] Callback function on every frame before the operation run. Will be\n     * called regardless if the holder have operation, target etc or not, as long as it is running (and it's parents) the\n     * function will be called.\n     */\n    /**\n     * @property {Array} [children=[]] So we can nestle animation\n     */\n    /**\n     * @property {Animation.Holder} [parent=undefined] A reference to the holders parent\n     */\n    /**\n     * @property {Number} [localTime=0] Local time counter\n     */\n    /**\n     * @property {Number} [delay=0] Time before the operations start after the animation starts\n     */\n    /**\n     * @property {Number} [startTimeOffset=0] If we want the animation to start at a specific time (TODO: currently if the offset is beyond the first keyframe it will start at that keyframe instead)\n     */\n    /**\n     * @property {Object} [operations={}] The operations the holder preforms\n     */\n    /**\n     * @property {Object} [operationSteps={}] The current key frame for every operation\n     */\n    /**\n     * @property {Object} [operationEnded={}] If all the operations are done\n     */\n\n\n    /**\n     * Constructor\n     *\n     * @param {Object} config The config object\n     */\n    constructor (config) {\n        var me = this,\n            defaultProp = {\n                id                  : undefined,    // the identifier for this animation\n                target              : undefined,    // the target object we want to animate\n                prop                : undefined,    // the name of the properties on the target we want to change.\n                animation           : {             // object that will hold keyFrames etc.\n                    keyFrames : [],\n                    step : 0,                       // the current keyFrame we're on\n                    complete : false                // if the animation is done\n                },\n                running             : false,        // if the animation is active.\n                playbackSpeed       : undefined,    // if we want to play the animation faster (>1) or slower (<1)\n                loop                : false,        // will repeat the whole animation. If it have separate operations\n                                                    // with different time the shorter ones will wait at the end key frame\n                                                    // until the longest is done. onStart & onEnd will not be called every\n                                                    // loop (if that is needed, set callbacks on key frames instead).\n                                                    // Will also wait for all it's children to complete.\n                readyToLoop         : false,        // since we sometime need to wait for our children we use this to know\n                                                    // when we can loop back to the start.\n                onStart             : undefined,    // callback before the animation starts\n                onEnd               : undefined,    // callback when the animation is complete\n                onUpdate            : undefined,    // callback on every frame before the operation run. Will be\n                                                    // called regardless if the holder have operation, target etc or not\n                children            : [],           // so we can nestle animation\n                parent              : undefined,    // a reference to the holders parent\n                localTime           : 0,            // local time counter\n                delay               : 0,            // time before the operations start after the animation starts\n                startTimeOffset     : undefined,    // if we want the animation to start at a specific time\n                //operations          : {},           // the operations the holder preforms\n                //operationSteps      : {},           // the current key frame for every operation\n                //operationsEnded     : false,        // if all the operations are done\n                addToAnimationLoop  : false         // adding the holder to the animation loop on creation\n            };\n\n        config = Sys.applyProperties(defaultProp, config);\n\n        // Parse the config, this allows us to use several config syntax\n        config = me.parseConfig(config);\n\n        me = Sys.applyProperties(me, config);\n\n        //// Set the default parameters needed by the operations\n        //me.setOperationDefaultProperties();\n\n        if ( config.addToAnimationLoop ){\n            animationBuffer.push(me);\n        }\n\n    }\n\n    /**\n     * Parse the config so that it matches the actual object properties.\n     *\n     * @param config\n     * @return {Object} The parsed properties\n     */\n    parseConfig  (config) {\n        var properties = {\n                animation : {\n                    keyFrames : [],\n                    step : 0,\n                    complete : false\n                }\n            },\n            //operations = Object.keys(Animation.Operations),\n            timeSort = function (a, b) {\n                return (a.time - b.time);\n            },\n            obj;\n\n        // Process all keys on the config object\n        Sys.iterate(config, function(key, value){\n\n            // If we have an animation, parse it\n            if (key === \"animate\" ) {\n\n                /*DEBUG_START*/\n                if ( key !== \"animate\" ){\n                    // TODO: right now we only support the \"animate\" operation, when we need more we have to make them.\n                    console.warn(\"You are trying to use a \" + key + \" operation on a Animation.Holder, for now only 'animate' is supported\");\n                }\n                /*DEBUG_END*/\n\n                // if the operation is an array or object\n                if ( Sys.isObj(value) ){\n\n                    Sys.iterate(value, function(time, frameValue){\n                        // Define the frame object with the time value\n                        obj = { time : parseInt(time, 10) };\n\n                        // If the frame is an object with a defined value then we have non value properties mixed in\n                        if (Sys.isObj(frameValue) ) {\n                            if ( Sys.isDefined(frameValue.value) ){\n                                obj = Sys.applyProperties(obj, frameValue);\n                            }\n                            else {\n                                obj.value = frameValue;\n                            }\n                        }\n                        // Otherwise it is just a plain value\n                        else {\n                            obj.value = frameValue;\n                            /*DEBUG_START*/\n                            if ( !Sys.isDefined(config.prop) && config.length > 1 ){\n                                console.warn(\"If we only specify a number value the property 'prop' must exist\");\n                            }\n                            /*DEBUG_END*/\n                        }\n\n                        // Push the key frame\n                        properties.animation.keyFrames.push(obj);\n                    });\n\n                    properties.animation.keyFrames.sort(timeSort);\n                }\n                else if ( Sys.isArray(value) ){\n                    // the operation is already in the right format, add it to the operations object\n                    properties.animation.keyFrames = value;\n                }\n                else {\n                    // error\n                    console.warn(\"Operation is in wrong format\");\n                }\n            }\n            // Else assign the value\n            else {\n                properties[key] = value;\n            }\n        });\n\n        // if target is undefined use the parents target (if it exist)\n        if ( !Sys.isDefined(properties.target) && Sys.isDefined(properties.parent) && Sys.isDefined(properties.parent.target) ){\n            properties.target = properties.parent.target;\n        }\n\n        /*DEBUG_START*/\n        if ( Sys.isDefined(properties.target) && !Sys.isObj(properties.target) ){\n            console.warn(\"The target of a Animation.Holder must be a Object\");\n        }\n        /*DEBUG_END*/\n\n        // if the id is undefined use the targets id (if it exist) and the operation type\n        if ( !Sys.isDefined(properties.id) && Sys.isDefined(properties.target) && Sys.isDefined(properties.target.id) ){\n            var prop = Sys.isDefined(properties.prop) ? properties.prop : \"\";\n\n            properties.id = properties.target.id + \":\" + prop + \"Animation\";\n        }\n\n        // if we already have children in the config, create them and add them\n        if ( Sys.isDefined(properties.children) && properties.children.length > 0 ){\n            var tempChildrenContainer = [],\n                parent = this;\n\n            properties.children.forEach(function(child){\n                var animation;\n\n                if ( Sys.isDefined(child.localTime) ){\n                    // the child is already a AnimationHolder\n                    animation = child;\n                }\n                else {\n                    child.parent = {target : config.target};\n                    animation = new AnimationHolder(child);\n                }\n                animation.parent = parent;\n                tempChildrenContainer.push( animation );\n            });\n\n            properties.children = tempChildrenContainer;\n        }\n\n        return properties;\n    }\n\n    /**\n     * Run the holder and it's children\n     *\n     * @param {Object} timeObj The object containing the time\n     */\n    run (timeObj) {\n        var me = this,\n            timeStep = timeObj.timeStep;\n\n        if (me.localTime === 0 && Sys.isDefined(me.startTimeOffset) ){\n            // if this is the first frame of the animation and we have a start offset\n            timeStep += me.startTimeOffset;\n        }\n\n        if ( Sys.isDefined(me.playbackSpeed) ){\n            // adjust the time step based on playback speed\n            timeStep *= me.playbackSpeed;\n        }\n\n        me.localTime += timeStep; // increase the local timer\n\n        if(me.localTime >= me.delay) {\n\n            // Time step is used to keep track of internal timers on the operation level\n            me.doAnimation(timeStep);\n\n            me.children.forEach(function(child){\n                if ( child.running ){\n                    child.run({timeStep : timeStep, time : timeObj.time});\n\n                    // if the child is still running\n                    if ( child.running ){\n                        // we should also be running\n                        me.running = true;\n\n                        if ( !child.loop && !child.readyToLoop ){\n                            // if it's time for us to loop, wait until the children are done\n                            // but don't wait on looping children\n                            me.readyToLoop = false;\n                        }\n                    }\n                }\n            });\n\n            if ( Sys.isDefined(me.onUpdate) ){\n                me.onUpdate(timeStep);\n            }\n        }\n\n        if ( me.loop && me.readyToLoop ){\n            // meaning I'm done and all my children are done (ignoring children that are looping)\n            me.restoreOnLoop();\n        }\n        else if ( !me.running ){\n            // this animation is done\n            if ( Sys.isDefined(me.onEnd) ){\n                me.onEnd();\n            }\n\n            // restore the animation on completion so we can start it from the beginning on the next play()\n            me.restore();\n        }\n    }\n\n    /**\n     * Runs each animation operation that is set for the holder\n     *\n     * @private\n     * @param {Number} currentStepTime the current time step\n     */\n    doAnimation (currentStepTime) {\n        var me = this,\n            numKeyFrames = me.animation.keyFrames.length;\n\n        // If we don't have any keyFrames or target just return\n        if (numKeyFrames < 2 || !Sys.isDefined(me.target) ) {\n            me.readyToLoop = true;\n            me.running = false;\n            return;\n        }\n\n        // Check if the animation have finished\n        var running = me.performAction(currentStepTime);\n\n        if (!running) {\n            // all the operations are done\n            me.running = false;\n            me.readyToLoop = true;\n        }\n    }\n\n    /**\n     * Play the animation\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to play. If none is\n     * specified (or true) we play all the children. If you send in an empty array [] we'll only play the current.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    play (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.running = true;\n\n        me.handleItems(\"play\", children);\n\n        if (me.localTime === 0 && Sys.isDefined(me.onStart)){\n            // if we start the game from the beginning do the onStart callback\n            me.onStart();\n        }\n\n        // make sure the parents are running\n        if (isRoot){\n            me.runParent();\n        }\n    }\n\n    runParent (){\n        var me = this;\n\n        if ( Sys.isDefined(me.parent) ){\n            me.parent.running = true;\n\n            me.parent.runParent();\n        }\n    }\n\n    /**\n     * Pause the animation\n     *\n     * @param {Array} [children] An array with children that we want to pause. If none is\n     * specified we pause all the children. If you send in an empty array [] we'll only pause the current holder.\n     */\n    pause (children) {\n        this.running = false;\n\n        this.handleItems(\"pause\", children);\n    }\n\n    /**\n     * Stop the animation and reset it to the beginning. Will do it for all the children as well\n     *\n     * @param {Array} [children] An array with children that we want to stop. If none is\n     * specified we stop all the children. If you send in an empty array [] we'll only stop the current.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    stop (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.running = false;\n\n        me.handleItems(\"stop\", children);\n\n        if ( isRoot ){\n            me.restore(children, true);\n        }\n    }\n\n    /**\n     * Restores the basic properties of the holder in order to run it again.\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to restore. If none is\n     * specified (or true) we restore all the children. If you send in an empty array [] we'll only restore the current holder.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    restore (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.localTime = 0;\n        me.readyToLoop = false;\n\n        me.restoreAnimation();\n\n        me.handleItems(\"restore\", children);\n\n        // if we are already running and are the root object we play()\n        if ( me.running && isRoot ){\n            me.play(children, true);\n        }\n    }\n\n    /**\n     * Restores the basic properties of the holder in order to run it again.\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to restore. If none is\n     * specified (or true) we restore all the children. If you send in an empty array [] we'll only restore the current holder.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    restoreOnLoop (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        if ( isRoot || !me.loop ){\n            me.running = true;\n            //me.localTime = 0;\n            me.readyToLoop = false;\n\n            me.restoreAnimation();\n\n            me.handleItems(\"restoreOnLoop\");\n        }\n    }\n\n    restoreAnimation (){\n        this.animation.time = 0;\n        this.animation.step = 0;\n\n        this.animation.keyFrames.forEach(function(key){\n            if (Sys.isDefined(key.callback)) {\n                key.callbackCompleted = false;\n            }\n\n            // add more stuff\n        });\n    }\n\n    /**\n     * @private\n     * Update the holder with the operation configuration\n     *\n     * @param {Object} config The configuration\n     */\n    updateOperation (config) {\n        var me = this,\n            obj = {};\n\n        //me.applyDefaultValuesToItem(me);\n\n        obj.animate = config;\n\n        obj = me.parseConfig(obj);\n\n        me.animation = obj.animation;\n        //me.applyDefaultValuesToOperation(me);\n\n        me.restore();\n    }\n\n    /**\n     * @private\n     * Call the specified function on all the items\n     *\n     * @param {String} type The function to call on the items\n     * @param {Array} [selection] The optional array of items to handle\n     */\n    handleItems (type, selection){\n        var items = (Sys.isDefined(selection) && Sys.isArray(selection)) ? selection : this.children;\n\n        items.forEach(function(child){\n            child[type](true, false);\n        });\n    }\n\n    setParent (parent){\n        this.parent = parent;\n        parent.children.push(this);\n\n        // if you don't have a target, use the parents\n        if ( !Sys.isDefined(this.target) ){\n            this.target = parent.target;\n        }\n    }\n\n    addChild (children){\n        var me = this;\n\n        if (Sys.isArray(children) ){\n            children.forEach(function(child){\n                child.setParent(me);\n            });\n        }\n        else if (Sys.isObj(children)){\n            children.setParent(me);\n        }\n    }\n\n    /**\n     * Will search children (and grandchildren) for a Holder that mach the key and value provide.\n     *\n     * NOTE: if there is more than one match you will get the first one.\n     *\n     * @param {String} value The value that should match\n     * @param {String} [byKey] Which property key we should check against, default \"id\"\n     *\n     * @return {object|boolean} the items that match our search criteria, or false if it didn't find anything\n     */\n    findChild (value, byKey){\n        var key = Sys.isDefined(byKey) ? byKey : \"id\",\n            item = false,\n            searchChildren = function(items) {\n                var result = false,\n                    subResult = false;\n\n                items.forEach(function(item){\n                    if ( Sys.isDefined(item[key]) && item[key] === value ){\n                        result = item;\n                    }\n\n                    if ( Sys.isDefined(item.children) ){\n                        subResult = searchChildren(item.children);\n\n                        if ( Sys.isObj(subResult) ){\n                            result = subResult;\n                        }\n                    }\n                });\n\n                return result;\n            };\n\n        // start with the main Holder\n        if ( this[key] === value ){\n            return this;\n        }\n\n        if ( Sys.isDefined(this.children) ){\n            item = searchChildren(this.children );\n        }\n\n        return item;\n    }\n\n    /**\n     * Performs the specified action on a given object.\n     *\n     * @param {Number} currentStepTime The time since the last render (ms)\n     */\n    performAction (currentStepTime) {\n        var me = this,\n            animation = me.animation,\n            keyFrames = animation.keyFrames,\n            numKeyFrames = keyFrames.length,\n            currentTime = me.increaseAnimationTime(currentStepTime),\n            currentKeyFrame = keyFrames[animation.step],\n            nextKeyFrame = keyFrames[animation.step + 1],\n            running = true;\n\n        /*DEBUG_START*/\n        if ( numKeyFrames < 2 ){\n            console.warn(\"The Holder \" + item + \" have an animation with less than two keyFrames, the operation needs a minimum of two keyFrames to be able to animate.\");\n            return 0;\n        }\n        /*DEBUG_END*/\n\n        me.handleCallback(currentKeyFrame); // added an extra callback check here to make sure callbacks on keyFrame 0 are fired\n\n        // step through keyFrames, from oldKeyFrameIndex, until we are on the current one\n        // loop if necessary\n        // fire events and callbacks on every new keyFrame we pass\n        // goTo keyFrames\n\n        // check if we have passed the next keyFrame\n        if ( nextKeyFrame.time <= currentTime){\n            me.progressKeyFrame();\n\n            currentKeyFrame = keyFrames[animation.step];\n\n            // are we at the last keyFrame, ie we're not looping and the animation is complete\n            if ( animation.step === numKeyFrames - 1 ){\n                nextKeyFrame = currentKeyFrame;\n                running = false;\n            }\n            else {\n                nextKeyFrame = keyFrames[animation.step + 1];\n            }\n        }\n\n        // when we have the current keyFrame, interpolate between that and the next keyFrame\n        me.calculate(animation.time, currentKeyFrame, nextKeyFrame);\n\n        return running;\n    }\n\n    progressKeyFrame (toIndex){\n        var me = this,\n            animation = me.animation,\n            keyFrames = animation.keyFrames,\n            currentKeyFrame;\n\n        // step to next keyFrame\n        animation.step = Sys.isDefined(toIndex) ? toIndex : animation.step + 1;\n\n        // do events and callbacks\n        currentKeyFrame = keyFrames[animation.step];\n        me.handleCallback(currentKeyFrame);\n\n        // check for goTo\n        if ( Sys.isDefined(currentKeyFrame.goTo) ) {\n            me.doGoTo(currentKeyFrame);\n        }\n\n        // if we haven't reached the last keyFrame\n        if ( animation.step !== keyFrames.length - 1 ){\n            // check if we should move one more\n            if ( animation.time >= keyFrames[animation.step + 1].time){\n                me.progressKeyFrame();\n            }\n        }\n        else if ( me.loop  ){ // at the last keyFrame and we're looping\n            animation.time -= keyFrames[animation.step].time;\n            me.progressKeyFrame(0);\n        }\n\n    }\n\n    doGoTo (keyFrame){\n        var me = this;\n\n        me.animation.time = me.animation.keyFrames[keyFrame.goTo].time;\n        me.animation.step = keyFrame.goTo;\n\n        /*DEBUG_START*/\n        console.warn(\"Warning: goTo functionality not completed, use at own risk.\");\n        // TODO: fix goTo, callback resets when going back and callback firing when going forward etc.\n        /*DEBUG_END*/\n    }\n\n    /**\n     * Calculates the time steps and sets the values that should be interpolated.\n     *\n     * @protected\n     * @param {Number} currentTime The current time step\n     * @param {Object} currentStep The current frame\n     * @param {Object} nextStep The next frame\n     */\n    calculate (currentTime, currentStep, nextStep) {\n        var me = this,\n            time = me.calculateTime(currentTime, currentStep, nextStep),\n            from = currentStep.value,\n            to = nextStep.value,\n            target;\n\n        if ( Sys.isObj(from) ){\n            Sys.iterate(from, function(key, value){\n                target = Sys.isDefined(me.prop) ? me.target[me.prop] : me.target;\n\n                target[key] = Animation.utils.getInterpolationValue(value, to[key], time, currentStep.ease, key);\n            });\n        }\n        else { // we only animate one number\n            me.target[me.prop] = Animation.utils.getInterpolationValue(from, to, time, currentStep.ease);\n        }\n    }\n\n    /**\n     * @private\n     * @param {Object} currentKeyFrame The object holding the current key frame information\n     */\n    handleCallback (currentKeyFrame) {\n        var callback = currentKeyFrame.callback,\n            container;\n\n        if(Sys.isDefined(callback) && !currentKeyFrame.callbackCompleted) {\n\n            if ( callback.fireImmediately ){\n                if ( Sys.isString(callback.func) ){\n                    // an event\n                    callback.scope.fireEvent(callback.func, callback.args);\n                }\n                else if ( Sys.isFunc(callback.func) ){\n                    // a function\n                    callback.func.apply(callback.scope, callback.args);\n                }\n            }\n            else {\n                container = Game.stage.view.animationManager.callbackContainer;\n                container.push(callback);\n            }\n\n            currentKeyFrame.callbackCompleted = true;\n        }\n    }\n\n    /**\n     * Calculates the time vars.\n     *\n     * @private\n     * @param {Number} currentTime The current time step\n     * @param {Object} currentStep The current frame\n     * @param {Object} nextStep The next frame\n     */\n    calculateTime (currentTime, currentStep, nextStep) {\n        var timeStep = currentTime - currentStep.time,\n            totalTime = nextStep.time - currentStep.time;\n\n        //If timeStep equals 0 and totalTime equals 0. The result will be NaN\n        return totalTime !== 0 ? timeStep / totalTime : 1;\n    }\n\n\n    /**\n     * Increase the timeBuffer\n     *\n     * @param {Number} time The time the time buffer should be increased\n     */\n    increaseAnimationTime  (time) {\n        if (!Sys.isDefined(this.animation.time)) {\n            this.animation.time = time;\n        }\n        else {\n            this.animation.time += time;\n        }\n\n        return this.animation.time;\n    }\n\n    animate (config, play) {\n        this.updateOperation(config);\n        if ( play ){\n            this.play();\n        }\n    }\n\n}","import {BonusWheelItem} from \"./BonusWheelItem\";\nimport {AnimationHolder} from \"./AnimationHolder\";\nimport {StorageManager} from \"./StorageItemsManager\";\n\nconst CIRCLE_DEG = 360;\n    //the minimum difference (angle) between current wheel stop and previous wheel stop:\nconst MIN_DIFF = 270;\nconst START_BOUNCE = {\n    //negative value, since the wheel moves backwards\n    maxSpeed: -0.5,\n        //time fraction of the whole acceleration time\n        timeFraction: 1/500\n};\n\nconst WHEEL_ITEMS_CENTER_OFFSET = 300;\nconst WHEEL_ITEM_CONFIG = {\n    width: 100,\n    height: 100\n};\n\nexport class BonusWheel extends PIXI.Container {\n    \n    constructor (config, onStartBounceCompleteCallback, app) {\n        super();\n        var me = this;\n\n        me.sectorItemsList = config.sectorItemsList;\n\n        me.background = me._initBackground(me, \"wheel_bg\");\n\n        me._initBgSpine(me, \"glow\", app);\n\n        me.background.anchor.set(0.5,0.5);\n\n        //degrees per frame\n        me.maxSpeed = config.maxSpeed;\n        me.minSpeed = config.minSpeed;\n\n        me.sprite = me._initWheelSprite(me, \"wheelWin\");\n        me.spinButton = me.initSpinButton(me);\n        me.wheelItems = me._initWheelItems(me.sprite);\n\n        //will be added to a separate spine slot:\n        me.highlightSprite = typeof config.image !== \"undefined\" ? me._initSprite(config.image, PIXI.BLEND_MODES.ADD) : me._initEmptySprite();\n        me.sectorsAngles = me._mapSectorsAgles(config.sectors);\n        me.animations = me._initAnimations(config);\n        me.onStartBounceCompleteCallback = onStartBounceCompleteCallback;\n        me.config = config;\n\n        me.pick = me._initPickSprite(me);\n        me.gift = me._initGiftSprite(me, \"SYM0\");\n\n        me.reset();\n        me.refresh();\n    }\n\n    _initBackground (container, imageName) {\n        return container.addChild(new PIXI.Sprite.fromImage(\"assets/images/\"+imageName+\".jpg\"))\n    }\n\n    _initBgSpine (container, spineName, app) {\n        var me = this,\n            glow;\n\n        PIXI.loader\n            .add('glow', 'assets/spine/glow.json')\n            .load(onAssetsLoaded);\n\n        function onAssetsLoaded(loader,res) {\n            // instantiate the spine animation\n            glow = new PIXI.spine.Spine(res.glow.spineData);\n            glow.skeleton.setToSetupPose();\n            glow.update(0);\n            glow.autoUpdate = false;\n\n            me.background.addChild(glow);\n\n            // once position and scaled, set the animation to play\n            glow.state.setAnimation(0, 'spin', true);\n            app.ticker.add(function() {\n                glow.update(0.02);\n            });\n\n            glow.visible = false;\n            me.bgAnimation = glow;\n        }\n\n    }\n\n    _initWheelSprite (container, imageName) {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/\"+imageName+\".png\");\n        sprite.anchor.set(0.5, 0.5);\n        container.addChild(sprite);\n\n        return sprite;\n    }\n\n    initSpinButton (wheel) {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/stop_idle.png\");\n        sprite.interactive = true;\n        sprite.anchor.set(0.5, 0.5);\n        wheel.addChild(sprite);\n        var actionDown = function () {\n            if(deviceAPI.deviceType === \"desktop\"){\n                return \"mousedown\";\n            }\n            return \"touchstart\"\n        }();\n        var actionUp = function () {\n            if(deviceAPI.deviceType === \"desktop\"){\n                return \"mouseup\";\n            }\n            return \"touchend\"\n        }();\n\n        {\n            sprite.on(actionDown, function () {\n                sprite.texture = PIXI.Texture.fromImage(\"assets/images/stop_click.png\");\n            });\n\n            sprite.on(\"mouseupoutside\", function () {\n                sprite.texture = PIXI.Texture.fromImage(\"assets/images/stop_idle.png\");\n            });\n\n            sprite.on(\"touchendoutside\", function () {\n                sprite.texture = PIXI.Texture.fromImage(\"assets/images/stop_idle.png\");\n            });\n        }\n\n        sprite.on(actionUp, function () {\n            sprite.texture = PIXI.Texture.fromImage(\"assets/images/stop_idle.png\");\n\n            var itemsLeft = !StorageManager.isNoMoreItems(),\n                itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n                winSound = new Audio(\"assets/sounds/AUTOMOBILE.mp3\"),\n                sectorToStopOn;\n\n            if(!itemsLeft){\n                console.error(\"no more items at all\");\n            } else {\n                sprite.interactive = false;\n                winSound.play();\n                sectorToStopOn = StorageManager.findSectorToStopOn();\n                console.warn(\"stopping at: \", sectorToStopOn);\n\n                wheel.start();\n                wheel.setStoppingAngle(sectorToStopOn);\n                wheel.startStopping().then(function () {\n                    wheel.playGiftAnimation(itemsList[sectorToStopOn].name, function () {\n                        sprite.interactive = true;\n                    });\n                });\n            }\n        });\n\n        return sprite;\n    }\n\n    /**\n     * Adds wheel items - sprites that rotate together with the wheel\n     *\n     * @param {PIXI.Container|PIXI.Sprite} parent - wheelItems will be added here\n     * @returns {Array<S.BonusWheelItem>}\n     * @private\n     */\n    _initWheelItems(parent){\n        var me = this,\n            sizedContainer,\n            bonusWheelItem,\n            whellItems = [];\n\n        me.sectorItemsList.forEach(function (item, index) {\n            sizedContainer = new PIXI.Container();\n\n            bonusWheelItem = new BonusWheelItem({\n                parent: sizedContainer,\n                texture: new PIXI.Texture.fromImage(\"assets/images/prizes/\" + item + \".png\"),\n                sectorIndex: index,\n                centerOffset: WHEEL_ITEMS_CENTER_OFFSET,\n                totalSectorsNum: me.sectorItemsList.length\n            });\n\n            bonusWheelItem.width = WHEEL_ITEM_CONFIG.width;\n            bonusWheelItem.height = WHEEL_ITEM_CONFIG.height;\n\n            parent.addChild(sizedContainer);\n            whellItems.push(bonusWheelItem);\n        });\n\n        return whellItems;\n    }\n\n    _initPickSprite (container) {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/pick.png\");\n        sprite.anchor.set(0.5, 0.5);\n        container.addChild(sprite);\n        sprite.position.y = -460;\n\n        return sprite;\n    }\n\n    _initGiftSprite (container, imageName) {\n        var sprite = this._initSprite(imageName, PIXI.BLEND_MODES.NORMAL);\n\n        container.addChild(sprite);\n        sprite.width = 100;\n        sprite.height = 100;\n        sprite.position.y = -250;\n        sprite.visible = false;\n        sprite.animation = new AnimationHolder({\n            addToAnimationLoop: true,\n            target: sprite,\n            children: [\n                {\n                    prop: \"position\",\n                    animate: {\n                        200: {y: -(WHEEL_ITEMS_CENTER_OFFSET)},\n                        1500: {y: 0},\n                        5000: {y: 0},\n                        5500: {y: -(WHEEL_ITEMS_CENTER_OFFSET)},\n                    }\n                },\n                {\n                    prop: \"width\",\n                    animate: {\n                        200: WHEEL_ITEM_CONFIG.width,\n                        1500: WHEEL_ITEM_CONFIG.width * 3,\n                        5000: WHEEL_ITEM_CONFIG.width * 3,\n                        5500: WHEEL_ITEM_CONFIG.width\n                    }\n                },\n                {\n                    prop: \"height\",\n                    animate: {\n                        200: WHEEL_ITEM_CONFIG.height,\n                        1500: WHEEL_ITEM_CONFIG.height * 3,\n                        5000: WHEEL_ITEM_CONFIG.height * 3,\n                        5500: WHEEL_ITEM_CONFIG.height\n                    }\n                }\n            ]\n        });\n\n        return sprite;\n    }\n\n    /**\n     *\n     * @param animSprite - win presentation sprite\n     * @private\n     */\n    _onWinAnimationComplete(animSprite){\n        animSprite.visible = false;\n        this.wheelItems.forEach(function(wheelItem){\n            wheelItem.show();\n        });\n        this.bgAnimation.visible = false;\n    }\n\n    _initSprite (imageName, blendMode) {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/prizes/\"+imageName+\".png\");\n\n        sprite.anchor.set(0.5, 0.5);\n        sprite.blendMode = blendMode;\n\n        return sprite;\n    }\n\n    _initEmptySprite () {\n        return new PIXI.Sprite(PIXI.Texture.EMPTY);\n    }\n\n    /**\n     * @param {Array} sectorsNames - list of sectors names on the wheel\n     * @returns {Object} sectorsAngles - config with all the sectors mapped to angles of wheel rotation\n     */\n    _mapSectorsAgles (sectorsNames) {\n        var sectorsNumber = sectorsNames.length,\n            degreesPerSector = CIRCLE_DEG / sectorsNumber,\n            sectorsAngles = {};\n\n        sectorsNames.forEach(function (sectorName, index) {\n            //forced to use array of angles, since we might have multiple sectors for one value\n            //for instance, the key wheel has 6 sectors with 0 and 2 sectors with 1\n            if(!sectorsAngles[sectorName]){\n                sectorsAngles[sectorName] = [];\n            }\n            sectorsAngles[sectorName].push(degreesPerSector * index);\n        });\n\n        return sectorsAngles\n    }\n\n    /**\n     * These are not \"animations\" in common understanding of the Animation.Holder, they are rather tickers,\n     * that perform certain update functions on every frame\n     *\n     * @param {Object} config - wheel config\n     * @returns {Object} list of all available animations\n     */\n    _initAnimations (config) {\n        return {\n            \"accelerationTicker\": this._initAccelerationTicker(config.accelerationDuration),\n            \"uniformRotationTicker\": this._initUnformRotationTicker(),\n            \"decelerationTicker\": this._initDecelerationTicker()\n        }\n    }\n\n    /**\n     * @param {number} accelerationTime - time it will take to accelerate from 0 to maximum speed\n     * @returns {Object} animation holder that gradually(with easing) increases currentSpeed\n     * that will be used in _updateSpriteAngle on each frame for smooth wheel start\n     */\n    _initAccelerationTicker (accelerationTime) {\n        var me = this;\n\n        return new AnimationHolder({\n            target: me,\n            prop: \"currentSpeed\",\n            onUpdate: me._updateSpriteAngle.bind(me),\n            onEnd: me.startUniformRotation.bind(me),\n            animate: [\n                {\n                    time: 0,\n                    value: 0,\n                    ease: Animation.utils.powerTwoOut\n                },\n                //the wheel bounce back on start:\n                {\n                    time: accelerationTime * START_BOUNCE.timeFraction,\n                    value: START_BOUNCE.maxSpeed,\n                    ease: Animation.utils.powerTwoIn\n                },\n                {\n                    time: accelerationTime,\n                    value: me.maxSpeed\n                }\n            ],\n            addToAnimationLoop: true\n        });\n    }\n\n    /**\n     * @returns {Object} animation holder that calls _updateSpriteAngle on every frame\n     * by this moment, the speed reaches maximum value, so this spins the wheel uniformly\n     */\n    _initUnformRotationTicker () {\n        var me = this;\n\n        return new AnimationHolder({\n            onUpdate: me._updateSpriteAngle.bind(me),\n            addToAnimationLoop: true,\n            loop: true\n        });\n    }\n\n    /**\n     * @returns {Object} animation holder that calls decelerateRotation on every frame and smoothly stops the wheel\n     */\n    _initDecelerationTicker () {\n        var me = this;\n\n        return new AnimationHolder({\n            addToAnimationLoop: true,\n            onUpdate: me.decelerateRotation.bind(me),\n            loop: true\n        });\n    }\n\n    startUniformRotation () {\n        var me = this;\n        //resolving promise (there's no callback on restore):\n        me.onWheelStartCallback && me.onWheelStartCallback();\n        //in regular case it would've reached maxSpeed naturally by this moment, but on restores we're forced to set it manually:\n        me.currentSpeed = me.maxSpeed;\n        me.animations.uniformRotationTicker.play();\n    }\n\n    /**\n     *  decreases currentSpeed depending on currentAngle relative to finalAngle\n     *  the closer we are to the finalAngle the slower we go\n     *  calls _updateSpriteAngle to apply new speed\n     */\n    decelerateRotation () {\n        var me = this,\n            currentAngle = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            distanceLeft = me.finalAngle - currentAngle,\n            maxSpeedFraction = distanceLeft / me.stoppingDistance,\n            timePassedFromStart = 1 - maxSpeedFraction;\n\n        me.currentSpeed = Animation.utils.powerTwoIn(me.maxSpeed, 0, timePassedFromStart);\n\n        //proceed with uniform rotation if the speed might become too low:\n        if (me.currentSpeed < me.minSpeed) {\n            me.currentSpeed = me.minSpeed;\n        }\n\n        me._updateSpriteAngle();\n    }\n\n    /**\n     *  Changes the sprite angle by adding currentSpeed to it, stops the deceleration ticker if reached final angle\n     */\n    _updateSpriteAngle () {\n        var me = this,\n            currentRotation = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            timeScale = me.getTimeScale(),\n            newRawRotation = currentRotation + me.currentSpeed * timeScale,\n            newRotation;\n\n        //startBounce completion condition:\n        if(me.prevFrameSpeed < 0 && me.currentSpeed > 0){\n            me.onStartBounceCompleteCallback(me.config.name);\n        }\n\n        if (newRawRotation >= me.finalAngle) {\n            newRotation = me.finalAngle;\n            me.currentSpeed = 0;\n            me.animations.decelerationTicker.stop();\n\n            //resolving promise:\n            me.onWheelStopped();\n        } else {\n            newRotation = newRawRotation;\n        }\n\n        me.sprite.rotation = newRotation * PIXI.DEG_TO_RAD;\n        me.highlightSprite.rotation = me.sprite.rotation;\n        me.prevFrameSpeed = me.currentSpeed;\n    }\n\n    /**\n     *  Returns timescale coefficient to adjust the animation duration on low FPS\n     *\n     *  @returns {number} - deltaTime correction coefficient\n     */\n    getTimeScale () {\n        var me = this,\n            //todo: remove before release:\n            timeScale = 1.5,\n            oneFrameDuration = 1000/60,\n            now = Date.now(),\n            prev = me.lastTick ? me.lastTick : now - oneFrameDuration;\n\n        me.lastTick = now;\n\n        //todo: remove before release:\n        return (now - prev) * timeScale/oneFrameDuration;\n    }\n\n    start (callback) {\n        this.onWheelStartCallback = callback;\n        this.animations.accelerationTicker.play();\n\n\n    }\n\n    startDeceleration (prevWheelStoppingDistance, onWheelStopped) {\n        var me = this;\n\n        me.onWheelStopped = onWheelStopped;\n        me.animations.uniformRotationTicker.stop();\n        me._updateStoppingDistance(prevWheelStoppingDistance);\n        me.animations.decelerationTicker.play();\n\n        this.bgAnimation.visible = true;\n        this.bgAnimation.state.setAnimation(0, 'spin', true);\n    }\n\n    /**\n     *  updates distance to the destination point and final sprite angle at the moment of stopping\n     *  depending on currentAngle, stopAngle and prevWheelStoppingDistance\n     *\n     *  @param {number} prevWheelStoppingDistance - distance, the previous wheel has to cover before full stop\n     */\n    _updateStoppingDistance (prevWheelStoppingDistance) {\n\n        var me = this,\n            currentAngle = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            //using % me.CIRCLE_DEG here to simply calculations:\n            currentAngleReduced = currentAngle % CIRCLE_DEG,\n            angleToFullCircleLeft = CIRCLE_DEG - currentAngleReduced,\n            stopAngle = me.getStoppingAngle(),\n            minDistanceToTarget = angleToFullCircleLeft + stopAngle,\n            //number of 360 degrees wheel revolutions before stop\n            revolutionsBeforeStop = me.getRevolutionsBeforeStop(minDistanceToTarget, prevWheelStoppingDistance);\n\n        me.stoppingDistance = minDistanceToTarget + revolutionsBeforeStop * CIRCLE_DEG;\n        me.finalAngle = currentAngle + me.stoppingDistance;\n    }\n\n    /**\n     * Calculates the number of extra revolutions to make depending on previous wheel stopping distance\n     * (current wheel distance should always be greater than the previous one)\n     *\n     * @param {number} minDistanceToTarget - minimum possible distance between current and final angles\n     * @param {number} prevWheelStoppingDistance - distance the previous wheel will cover before full stop\n     * @returns {number} spinsBeforeStop - number of extra revolutions before full stop\n     */\n    getRevolutionsBeforeStop (minDistanceToTarget, prevWheelStoppingDistance) {\n        var me = this,\n            revsBeforeStop = 0,\n            targetDistance = prevWheelStoppingDistance + MIN_DIFF,\n            currentValue = minDistanceToTarget;\n        \n        while(currentValue < targetDistance){\n            revsBeforeStop++;\n            currentValue = minDistanceToTarget + CIRCLE_DEG * revsBeforeStop;\n        }\n\n        revsBeforeStop = Math.max(revsBeforeStop, me.config.minimumSpinsBeforeStop);\n\n        return revsBeforeStop;\n    }\n\n    /**\n     * Randomly selects from all available sectors angles for itemToStopOn\n     * (for instance, out of 6 options for 0 level on level wheel) and sets it as stopAngle\n     *\n     * @param {number | string} itemToStopOn - value on the sector whe wheel should stop on\n     * @returns {void}\n     */\n    setStoppingAngle (itemToStopOn) {\n        var me = this,\n            targetAngles = me.sectorsAngles[itemToStopOn],\n            targetAnglesCount = targetAngles.length,\n            randomAngleIndex = Math.floor(Math.random() * targetAnglesCount);\n\n        me.stopAngle = targetAngles[randomAngleIndex];\n    }\n\n    getStoppingAngle () {\n        return this.stopAngle;\n    }\n\n    getCurrentStoppingDistance () {\n        return this.stoppingDistance;\n    }\n\n    playGiftAnimation (name, onEndCallback) {\n        var me = this,\n            gift = me.gift,\n            totalSectorsNum = me.sectorItemsList.length,\n            currentItemIndex = Math.round( totalSectorsNum / CIRCLE_DEG * me.stopAngle),\n            currentWheelItem = me.wheelItems[currentItemIndex];\n\n        currentWheelItem.hide();\n\n        gift.texture = currentWheelItem.texture;\n        gift.visible = true;\n\n        gift.animation.onEnd = function () {\n            me._onWinAnimationComplete(gift);\n            onEndCallback();\n        };\n\n        gift.animation.play();\n\n        me.bgAnimation.state.setAnimation(0, 'win', true);\n    }\n\n    reset () {\n        var me = this;\n\n        me.stoppingDistance = Infinity;\n        me.finalAngle = Infinity;\n        me.sprite.rotation = 0;\n        me.currentSpeed = 0;\n        me.lastTick = 0;\n    }\n\n    startStopping () {\n        var me = this;\n\n        return new Promise(function (resolve) {\n            me.startDeceleration(0, function () {\n                resolve();\n            })\n        })\n    }\n\n    changeTexture (itemIndex, texture) {\n        this.wheelItems[itemIndex].texture = texture;\n    }\n\n    refresh () {\n        this.scale.set(window.innerHeight / 1080);\n    }\n\n}","const CONFIG = {\n    x: 10,\n    y: 10\n};\n\nexport class OpenCloseButton extends PIXI.Sprite{\n\n    constructor (config) {\n        super();\n\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.openCallback = config.openCallback;\n        this.closeCallback = config.closeCallback;\n\n        this.currentState = \"closed\";\n        this.setClosedTexture();\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"closed\"){\n            this.currentState = \"opened\";\n            this.setOpenedTexture();\n            this.openCallback();\n        } else if (this.currentState === \"opened\"){\n            this.currentState = \"closed\";\n            this.setClosedTexture();\n            this.closeCallback();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n\n    setClosedTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/settings.png\")\n    }\n\n    setOpenedTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/error.png\")\n    }\n\n    onForseClosed () {\n        this.currentState = \"closed\";\n        this.setClosedTexture();\n        this.closeCallback();\n    }\n}","const OFFSET = 10;\nconst TOP_OFFSET = 80;\n\nexport class Menu extends PIXI.Container{\n    constructor (config) {\n        super();\n\n        this.onItemImgChange = config.onItemImgChange;\n        this.onCountChange = config.onCountChange;\n\n        const input = document.createElement('input');\n        input.accept = \"image/*\";\n        input.id = \"inpt\";\n        input.type = \"file\";\n        input.onchange = this.updateImageLocally.bind(this);\n\n        document.body.appendChild(input);\n\n        const itemsListContainer = new PIXI.Container();\n        itemsListContainer.position.y = TOP_OFFSET;\n\n        const itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\"));\n        this.itemGroups = this.createItemsListInterface(itemsList, itemsListContainer);\n        this.addChild(itemsListContainer);\n\n        this.hideMenu();\n    }\n\n    onStorageUpdated () {\n        console.log(\"updating the storage\");\n        const itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\"));\n        this.itemGroups.forEach(function (item, index) {\n            item.countText.text = itemsList[index].count;\n        });\n\n    }\n\n    showMenu () {\n        this.visible = true;\n    }\n\n    hideMenu () {\n        this.visible = false;\n    }\n\n    createItemsListInterface (itemsList, parentContainer) {\n        var me = this,\n            itemGroup, itemGroups = [];\n\n        PIXI.loader\n            .load(\n                itemsList.forEach(function (item, itemIndex) {\n                    itemGroup = me.createItemContainer(parentContainer, item, itemIndex);\n                    itemGroups[itemIndex] = itemGroup;\n                })\n            );\n\n        return itemGroups;\n    }\n\n    createItemContainer (parentContainer, item, itemIndex) {\n        const itemContainer = new PIXI.Container();\n        let itemGroup = {};\n\n        itemGroup.button = this.addButton(itemContainer, item.name, itemIndex);\n        itemGroup.countText = this.addTxt(itemContainer, item.count);\n        itemGroup.buttons = this.addPlusMinusButtons(itemContainer, itemIndex, item.count);\n        itemContainer.position.set(OFFSET, (OFFSET * itemIndex) + (itemIndex * itemContainer.height));\n\n        this.addItemsListBg(itemContainer);\n\n        parentContainer.addChild(itemContainer);\n        return itemGroup;\n    }\n\n    addItemsListBg (container) {\n        var graphics = new PIXI.Graphics();\n\n        graphics.beginFill(0x3d5c5c);\n        graphics.lineStyle(2, 0xDE3249, 1);\n        graphics.drawRect(0, 0, container.width, container.height);\n        graphics.endFill();\n        graphics.blendMode = 2;\n\n        container.addChildAt(graphics, 0);\n    }\n\n    addButton (parentContainer, name, itemIndex) {\n        const me = this;\n        const texture = new PIXI.Texture.from(\"assets/images/prizes/\" + name + \".png\");\n        const itemImage = new PIXI.Sprite(texture);\n\n        itemImage.height = 50;\n        itemImage.width = 50;\n\n        itemImage.interactive = true;\n        itemImage.buttonMode = true;\n        itemImage.on('pointerdown', me.onItemClick.bind(me, itemImage, itemIndex));\n\n        parentContainer.addChild(itemImage);\n    }\n\n    addTxt (parentContainer, count) {\n        const style = new PIXI.TextStyle({\n                fill: '#d8df75',\n                fontSize: 15,\n                fontFamily: 'Arial'\n            }),\n            txt = new PIXI.Text(count, style);\n\n        txt.anchor.set(0.5);\n        txt.position.set(100, parentContainer.width / 2);\n\n        parentContainer.addChild(txt);\n        return txt;\n    }\n\n    addPlusMinusButtons (parentContainer, itemIndex) {\n        const me = this;\n        let buttons = {};\n\n        buttons.plusButton = me.initIncrementButton(\n            {\n                x: 160,\n                y: 0,\n                width: 20,\n                height: 20,\n                texture: new PIXI.Texture.from(\"assets/images/buttons/plus.png\"),\n                callback: me.onPlusButtonClick.bind(me, itemIndex),\n                parentContainer: parentContainer\n            });\n\n        buttons.minusButton = me.initIncrementButton(\n            {\n                x: 160,\n                y: 30,\n                width: 20,\n                height: 20,\n                texture: new PIXI.Texture.from(\"assets/images/buttons/minus.png\"),\n                callback: me.onMinusButtonClick.bind(me, itemIndex),\n                parentContainer: parentContainer\n            });\n\n        return buttons;\n    }\n\n    initIncrementButton (config) {\n        let button = new PIXI.Sprite(config.texture);\n\n        button.position.set(config.x, config.y);\n        button.interactive = true;\n        button.buttonMode = true;\n        button.width = config.width;\n        button.height = config.height;\n        button.on(\"pointerdown\", config.callback);\n        config.parentContainer.addChild(button);\n\n        return button;\n    }\n\n    onPlusButtonClick (itemIndex) {\n        let newCount = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count + 1;\n\n        this.onCountChange(itemIndex, newCount);\n        this.updateCountText(itemIndex, newCount);\n    }\n\n    onMinusButtonClick (itemIndex) {\n        const currentCount = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count;\n        let newCount;\n\n        if((currentCount - 1) <= 0){\n            newCount = 0;\n        } else {\n            newCount = currentCount - 1 ;\n        }\n\n        this.onCountChange(itemIndex, newCount);\n        this.updateCountText(itemIndex, newCount);\n    }\n\n    updateCountText (itemIndex, newCount) {\n        if(!newCount){\n            this.itemGroups[itemIndex].countText.text = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count;\n            return;\n        }\n        this.itemGroups[itemIndex].countText.text = newCount;\n    }\n\n    onItemClick (targetSprite, itemIndex) {\n        document.getElementById(\"inpt\").click();\n        this.targetSprite = targetSprite;\n        this.itemIndex = itemIndex;\n    }\n\n    updateImageLocally () {\n        var me = this,\n            file = document.getElementById(\"inpt\").files[0],\n            reader = new FileReader();\n\n        reader.onload = function () {\n            me.targetSprite.setTexture(new PIXI.Texture.from(reader.result));\n            me.onItemImgChange(me.itemIndex, new PIXI.Texture.from(reader.result));\n        };\n\n        if (file) {\n            reader.readAsDataURL(file);\n        }\n\n    }\n\n\n}","import {SoundButton} from \"./SoundButton\";\nimport {FullScreenButton} from \"./FullScreenButton\";\nimport {ScrollContainer} from \"./ScrollContainer\";\nimport {StorageManager} from \"./StorageItemsManager\";\nimport {BonusWheel} from \"./BonusWheel\";\nimport {OpenCloseButton} from \"./OpenCloseButton\";\nimport {Menu} from \"./Menu\";\n\nexport const animationBuffer = [];\n\nvar app = new PIXI.Application(window.innerWidth, window.innerHeight, {backgroundColor : 0x000000});\ndocument.body.appendChild(app.view);\n\nvar ambientSound = new Audio(\"assets/sounds/ambient.mp3\");\nvar winSound = new Audio(\"assets/sounds/AUTOMOBILE.mp3\");\n\nconst soundButton = new SoundButton({\n    soundOn: function () {\n        ambientSound.volume = 0.5;\n        winSound.volume = 1;\n    },\n    soundOff: function () {\n        ambientSound.volume = 0;\n        winSound.volume = 0;\n    }\n});\n\nvar docEl = document.documentElement;\nvar requestFullScreen = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen ||  docEl.msRequestFullscreen;\nvar exitFullscreen = docEl.exitFullscreen || docEl.webkitExitFullscreen || docEl.mozExitFullScreen ||  docEl.msExitFullscreen;\n\nconst fullScreenButton = new FullScreenButton({\n    enterFullscreenMode: function () {\n        requestFullScreen();\n    },\n    exitFullscreenMode: function () {\n        exitFullscreen();\n    }\n});\n\nvar scrollContainer = new ScrollContainer(0, 0, 500, 1000, 1500);\n\nvar prerenderCallbacks = [animate],\n    lastTimeStepOccured = 0,\n    currentStepTime = 0,\n    currentTime = 0;\n\nlastTimeStepOccured = updateTime();\n\nif(!window.localStorage.getItem(\"itemsList\")){\n    StorageManager.initStorage();\n}\n\nvar wheel = new BonusWheel({\n    name: \"freespins\",\n    spineSlot: \"1st_back\",\n    highlightSlot: \"1st_back2\",\n    sectors: [0,1,2,3,4,5,6,7,8,9,10,11],\n    maxSpeed: 16,\n    minSpeed: 0.15,\n    accelerationDuration: 1800,\n    minimumSpinsBeforeStop: 3,\n    sectorItemsList: StorageManager.getSectorItemsList(),\n    image: \"SYM0\"\n}, function () {\n    menu.onStorageUpdated();\n}, app);\n\n// move the sprite to the center of the screen\nwheel.position.set(app.screen.width / 2, app.screen.height / 2);\n\nwindow.addEventListener(\"resize\", function() {\n    app.renderer.resize(window.innerWidth, window.innerHeight);\n    wheel.position.set(window.innerWidth / 2, window.innerHeight / 2);\n});\n\n// Listen for animate update\napp.ticker.add(function(delta) {\n    prerenderCallbacks.forEach(function(cb) {\n        cb();\n    });\n    scrollContainer.hideOffscreenElements();\n});\n\nfunction animate(){\n    animationBuffer.forEach(function(holder){\n        if ( holder.running ){\n            holder.run({\n                timeStep: currentStepTime,\n                time: currentTime\n            });\n        }\n    });\n}\n\nfunction updateTime() {\n    var now = Date.now(),\n        diff = now - lastTimeStepOccured;\n\n    // Check if more time than allowed has passed since the last frame\n    if (diff > 250) {\n        diff = 1000 / 60;\n    }\n\n    currentStepTime = diff | 0;\n    currentTime += currentStepTime;\n\n    return now;\n}\n\napp.stage.addChild(wheel);\n\nvar openCloseButton = new OpenCloseButton({\n    openCallback: function () {\n        menu.showMenu();\n    },\n    closeCallback: function () {\n        menu.hideMenu();\n    }\n});\n\nvar menu = new Menu({\n    onItemImgChange: function (index, texture) {\n        wheel.changeTexture(index, texture);\n    },\n    onCountChange: function (index, count) {\n        StorageManager.setItemCount(index, count);\n    }\n});\n\n//app.stage.addChild(menu);\nscrollContainer.addChild(menu);\napp.stage.addChild(scrollContainer);\napp.stage.addChild(soundButton);\napp.stage.addChild(fullScreenButton);\napp.stage.addChild(openCloseButton);\n\ndocument.documentElement.webkitRequestFullscreen();\n\n\nwindow.addEventListener(\"resize\", refreshAll);\nfunction refreshAll() {\n    wheel.refresh();\n}\n","export class ScrollContainer extends PIXI.Container{\n    constructor(x, y, width, height, itemHeight) {\n        super();\n\n        this.po = new PIXI.Container();\n        this.scrollContainer = new PIXI.Container();\n        this.po.addChild(this.scrollContainer);\n        this.items = [];\n        this.x = x;\n        this.y = y;\n\n        this.scrollContainer.x = x;\n        this.scrollContainer.y = y;\n        this.height = height;\n        this.itemHeight = itemHeight;\n\n        this.mask = new PIXI.Graphics();\n        this.mask\n            .beginFill(0xFFFFFF)\n            .drawRect(x, y, width, height)\n            .endFill();\n\n        this.po.addChild(this.mask);\n        this.scrollContainer.mask = this.mask;\n\n        this.mousedown = false;\n        this.lastPos = null;\n        this.lastDiff = null;\n        this.scrollTween = null;\n\n        this.po.interactive = true;\n        this.po.mousemove = e => this.onmousemove(e);\n        this.po.mousedown = e => this.onmousedown(e);\n        this.po.mouseup = e => this.onmouseup(e);\n        this.po.mouseupoutside = e => this.onmouseup(e);\n        this.po.touchmove = e => this.onmousemove(e);\n        this.po.touchstart = e => this.onmousedown(e);\n        this.po.touchend = e => this.onmouseup(e);\n        this.po.touchendoutside = e => this.onmouseup(e);\n    }\n\n    onmousemove(e) {\n        const { originalEvent } = e.data;\n        var clientY = !originalEvent.touches ? originalEvent.clientY : originalEvent.touches[0].clientY;\n\n        if (this.mousedown) {\n            this.lastDiff = clientY - this.lastPos.y;\n            this.lastPos.y = clientY;\n\n            if (-this.scrollContainer.y < 0) {\n                this.scrollContainer.y += this.lastDiff / 2;\n            } else {\n                this.scrollContainer.y += this.lastDiff;\n            }\n        }\n    }\n\n    onmousedown(e) {\n        const { originalEvent } = e.data;\n        const clientY = !originalEvent.touches ? originalEvent.clientY : originalEvent.touches[0].clientY;\n        this.mousedown = true;\n        if (this.scrollTween) {\n            this.scrollTween.kill();\n        }\n        this.lastPos = {\n            y: clientY\n        };\n    }\n\n    onmouseup() {\n        if (this.lastDiff) {\n            let goY = this.scrollContainer.y + this.lastDiff * 10;\n            let ease = Quad.easeOut;\n            let time = Math.abs(this.lastDiff / 150);\n            if (goY < -this.items.length * this.itemHeight + this.height + this.y) {\n                goY = -this.items.length * this.itemHeight + this.height + this.y;\n                ease = Back.easeOut;\n                time = 0.1 + Math.abs(this.lastDiff / 150);\n            }\n            if (goY > this.y) {\n                goY = this.y;\n                ease = Back.easeOut;\n                time = 0.1 + Math.abs(this.lastDiff / 150);\n            }\n\n            if (this.scrollContainer.y > 0) {\n                time = 1 + this.scrollContainer.y / 500;\n                ease = Elastic.easeOut;\n            }\n            if (this.scrollContainer.y < -this.items.length * this.itemHeight + this.height) {\n                time = 1 + (this.items.length * this.itemHeight + this.height + this.scrollContainer.y) / 500;\n                ease = Elastic.easeOut;\n            }\n\n            this.scrollTween = TweenMax.to(this.scrollContainer, time, {\n                y: goY,\n                ease\n            });\n        }\n\n        this.mousedown = false;\n        this.lastPos = null;\n        this.lastDiff = null;\n    }\n\n    // This should be called every tick. Use only for scrolling containers with lots of elements for performance.\n    hideOffscreenElements() {\n        const startIndex = Math.floor(-(this.scrollContainer.y - this.y) / this.itemHeight);\n        const endIndex = Math.floor(startIndex + (this.height / this.itemHeight));\n        for (let i = 0; i < this.items.length; i++) {\n            const item = this.items[i];\n            item.visible = false;\n            if (i >= startIndex && i <= endIndex + 1) {\n                item.visible = true;\n            }\n        }\n    }\n\n    addItem(item) {\n        this.scrollContainer.addChild(item);\n        this.items.push(item);\n        item.y = (this.items.length - 1) * this.itemHeight;\n    }\n}"],"sourceRoot":""}