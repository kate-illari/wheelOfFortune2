{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/SoundButton.js","webpack:///./js/FullScreenButton.js","webpack:///./js/StorageItemsManager.js","webpack:///./js/BonusWheelItem.js","webpack:///./js/AnimationHolder.js","webpack:///./js/BonusWheel.js","webpack:///./js/OpenCloseButton.js","webpack:///./js/Menu.js","webpack:///./js/main.js","webpack:///./js/ScrollContainer.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","CONFIG","x","y","FullScreenButton_CONFIG","StorageManager","[object Object]","window","localStorage","setItem","JSON","stringify","count","min","max","Math","floor","random","list","parse","getItem","forEach","item","push","itemName","amount","updatedList","map","index","itemIdx","items","total","probabilities","itemsList","sum","totalItemsSum","this","countTotalItemsSum","itemsProbabilities","countItemsProbabilities","probabilityArray","console","warn","idx","error","randomInt","length","log","sort","every","randomIndex","getRandomItemAccordingToProbability","randomItem","findSectorToStopOn","BonusWheelItem","PIXI","Sprite","config","super","texture","parent","addChild","anchor","set","scale","updatePositionAndRotation","totalSectorsNum","sectorIndex","centerOffset","angle","PI","cos","sin","position","rotation","visible","AnimationHolder_AnimationHolder","me","defaultProp","id","undefined","target","prop","animation","keyFrames","step","complete","running","playbackSpeed","loop","readyToLoop","onStart","onEnd","onUpdate","children","localTime","delay","startTimeOffset","addToAnimationLoop","Sys","applyProperties","parseConfig","animationBuffer","obj","properties","timeSort","a","b","time","iterate","isObj","frameValue","parseInt","isDefined","isArray","tempChildrenContainer","child","timeObj","timeStep","doAnimation","run","restoreOnLoop","restore","currentStepTime","performAction","root","isRoot","handleItems","runParent","restoreAnimation","play","callback","callbackCompleted","animate","type","selection","setParent","byKey","searchChildren","result","subResult","numKeyFrames","currentTime","increaseAnimationTime","currentKeyFrame","nextKeyFrame","handleCallback","progressKeyFrame","calculate","toIndex","goTo","doGoTo","keyFrame","currentStep","nextStep","calculateTime","from","to","Animation","utils","getInterpolationValue","ease","fireImmediately","isString","func","scope","fireEvent","args","isFunc","apply","Game","stage","view","animationManager","callbackContainer","totalTime","updateOperation","CIRCLE_DEG","MIN_DIFF","START_BOUNCE","maxSpeed","timeFraction","WHEEL_ITEMS_CENTER_OFFSET","WHEEL_ITEM_CONFIG","width","height","LOGO_POSITION","portrait","landscape","OpenCloseButton_CONFIG","OFFSET","TOP_OFFSET","__webpack_exports__","app","Application","innerWidth","innerHeight","backgroundColor","document","body","appendChild","soundButton","interactive","buttonMode","on","onButtonClick","ambientSound","Audio","currentState","setOffTexture","setOnTexture","soundOn","soundOff","pause","Texture","docEl","documentElement","requestFullScreen","requestFullscreen","webkitRequestFullscreen","mozRequestFullScreen","msRequestFullscreen","exitFullscreen","webkitExitFullscreen","mozExitFullScreen","msExitFullscreen","fullScreenButton","enterFullscreenMode","exitFullscreenMode","scrollContainer","Container","itemHeight","po","mask","Graphics","beginFill","drawRect","endFill","mousedown","lastPos","lastDiff","scrollTween","mousemove","e","onmousemove","onmousedown","mouseup","onmouseup","mouseupoutside","touchmove","touchstart","touchend","touchendoutside","originalEvent","data","clientY","touches","kill","goY","Quad","easeOut","abs","Back","Elastic","TweenMax","startIndex","endIndex","prerenderCallbacks","holder","lastTimeStepOccured","now","Date","diff","updateTime","initStorage","main_wheel","onStartBounceCompleteCallback","sectorItemsList","background","_initBackground","_initBgSpine","minSpeed","wheelBgDisk","initWheelBackground","sprite","_initWheelSprite","spinButton","initSpinButton","wheelItems","_initWheelItems","highlightSprite","image","_initSprite","BLEND_MODES","ADD","_initEmptySprite","sectorsAngles","_mapSectorsAgles","sectors","animations","_initAnimations","pick","_initPickSprite","gift","_initGiftSprite","logo","initLogo","reset","refresh","fromImage","container","spineName","glow","loader","add","load","res","spine","Spine","spineData","skeleton","setToSetupPose","update","autoUpdate","state","setAnimation","ticker","bgAnimation","initSpinButtonActions","actionDown","deviceAPI","deviceType","actionUp","sectorToStopOn","itemsLeft","isNoMoreItems","spinSound","winSound","wheel","start","setStoppingAngle","startStopping","then","playGiftAnimation","sizedContainer","bonusWheelItem","whellItems","imageName","NORMAL","200","1500","5000","5500","animSprite","wheelItem","show","blendMode","EMPTY","sectorsNames","sectorsNumber","degreesPerSector","sectorName","accelerationTicker","_initAccelerationTicker","accelerationDuration","uniformRotationTicker","_initUnformRotationTicker","decelerationTicker","_initDecelerationTicker","accelerationTime","_updateSpriteAngle","startUniformRotation","powerTwoOut","powerTwoIn","decelerateRotation","onWheelStartCallback","currentSpeed","currentAngle","RAD_TO_DEG","timePassedFromStart","finalAngle","stoppingDistance","newRotation","currentRotation","timeScale","getTimeScale","newRawRotation","prevFrameSpeed","stop","onWheelStopped","DEG_TO_RAD","prev","lastTick","prevWheelStoppingDistance","_updateStoppingDistance","minDistanceToTarget","getStoppingAngle","revolutionsBeforeStop","getRevolutionsBeforeStop","revsBeforeStop","targetDistance","currentValue","minimumSpinsBeforeStop","itemToStopOn","targetAngles","targetAnglesCount","randomAngleIndex","stopAngle","onEndCallback","currentItemIndex","round","currentWheelItem","hide","_onWinAnimationComplete","Infinity","Promise","resolve","startDeceleration","itemIndex","spineSlot","highlightSlot","getSectorItemsList","menu","onStorageUpdated","screen","addEventListener","renderer","resize","delta","cb","hideOffscreenElements","openCloseButton","openCallback","closeCallback","setClosedTexture","setOpenedTexture","showMenu","hideMenu","onItemImgChange","onCountChange","input","createElement","accept","onchange","updateImageLocally","itemsListContainer","itemGroups","createItemsListInterface","countText","text","parentContainer","itemGroup","createItemContainer","itemContainer","button","addButton","addTxt","buttons","addPlusMinusButtons","addItemsListBg","graphics","lineStyle","addChildAt","itemImage","onItemClick","style","TextStyle","fill","fontSize","fontFamily","txt","Text","plusButton","initIncrementButton","onPlusButtonClick","minusButton","onMinusButtonClick","newCount","updateCountText","currentCount","targetSprite","getElementById","click","file","files","reader","FileReader","onload","setTexture","readAsDataURL","changeTexture","setItemCount","storageManager"],"mappings":"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","file":"./js/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const CONFIG = {\n    x: 50,\n    y: 10\n};\n\nexport class SoundButton extends PIXI.Sprite {\n    constructor () {\n        super();\n\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.ambientSound = new Audio(\"assets/sounds/ambience.mp3\");\n        this.ambientSound.loop = true;\n        this.currentState = \"off\";\n        this.setOffTexture();\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"off\"){\n            this.currentState = \"on\";\n            this.setOnTexture();\n            this.soundOn();\n        } else if (this.currentState === \"on\"){\n            this.currentState = \"off\";\n            this.setOffTexture();\n            this.soundOff();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n\n    soundOn () {\n        this.ambientSound.play();\n    }\n\n    soundOff () {\n        this.ambientSound.pause();\n    }\n\n    setOffTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/soundOff.png\")\n    }\n\n    setOnTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/soundOn.png\")\n    }\n}","const CONFIG = {\n    x: 100,\n    y: 10\n};\n\nexport class FullScreenButton extends PIXI.Sprite {\n    constructor (config) {\n        super();\n\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/fullscreen.png\");\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.enterFullscreenMode = config.enterFullscreenMode;\n        this.exitFullscreenMode = config.exitFullscreenMode;\n\n        this.currentState = \"off\";\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"off\"){\n            this.currentState = \"on\";\n            this.enterFullscreenMode();\n        } else if (this.currentState === \"on\"){\n            this.currentState = \"off\";\n            this.exitFullscreenMode();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n}","export class StorageManager{\n    static initStorage () {\n        window.localStorage.setItem(\"itemsList\", JSON.stringify([\n                {name: \"SYM8\", count: 50},\n                {name: \"SYM8\", count: 50},\n                {name: \"SYM1\", count: 40},\n                {name: \"SYM8\", count: 50},\n                {name: \"SYM8\", count: 50},\n                {name: \"SYM2\", count: 40},\n                {name: \"SYM8\", count: 50},\n                {name: \"SYM8\", count: 50},\n                {name: \"SYM3\", count: 40},\n                {name: \"SYM8\", count: 50},\n                {name: \"SYM8\", count: 50},\n                {name: \"SYM8\", count: 50}\n            ])\n        );\n    }\n\n    static randomInt (min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    static getSectorItemsList () {\n        var list = [];\n\n        JSON.parse(window.localStorage.getItem(\"itemsList\")).forEach(function (item) {\n            list.push(item.name);\n        });\n\n        return list;\n    }\n\n    static addItems (itemName, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item) {\n                if (itemName === item.name) {\n                    item.count += amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static removeItems (itemName, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item) {\n                if (itemName === item.name) {\n                    if (item.count - amount > 0) {\n                        item.count -= amount;\n                    } else {\n                        item.count = 0;\n                    }\n                }\n                return item\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static addItem (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    item.count += amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n\n    static removeItem (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    if (item.count - amount > 0) {\n                        item.count -= amount;\n                    } else {\n                        item.count = 0;\n                    }\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static setItemCount (index, amount) {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            updatedList = itemsList.map(function (item, itemIdx) {\n                if (index === itemIdx) {\n                    item.count = amount;\n                }\n                return item;\n            });\n\n        window.localStorage.setItem(\"itemsList\", JSON.stringify(updatedList));\n    }\n\n    static countItemsProbabilities (items, total) {\n        var probabilities = [];\n\n        items.forEach(function (item) {\n            probabilities.push(Math.floor(item.count * 100 / total));\n        });\n\n        return probabilities;\n    }\n\n    static countTotalItemsSum (itemsList) {\n        var sum = 0;\n\n        itemsList.forEach(function (item) {\n            sum += item.count;\n        });\n\n        return sum;\n    }\n\n    static getRandomItemAccordingToProbability () {\n        var itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            totalItemsSum = this.countTotalItemsSum(itemsList),\n            itemsProbabilities = this.countItemsProbabilities(itemsList, totalItemsSum),\n            probabilityArray = [],\n            random;\n\n        console.warn({itemsProbabilities});\n        itemsList.forEach(function (item, idx) {\n            for (var i = 0; i < itemsProbabilities[idx]; i++) {\n                probabilityArray.push(idx);\n            }\n        });\n\n        console.error({probabilityArray});\n\n        random = this.randomInt(0, (probabilityArray.length - 1));\n        console.log({random});\n\n        return probabilityArray.sort(() => Math.random() - 0.5)[random];\n    }\n\n    static isNoMoreItems () {\n        return JSON.parse(window.localStorage.getItem(\"itemsList\")).every(item => item.count === 0);\n    }\n\n    static findSectorToStopOn () {\n        var me = this,\n            randomIndex = me.getRandomItemAccordingToProbability(),\n            itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n            randomItem = itemsList[randomIndex];\n\n        if (randomItem.count > 0) {\n            randomItem.count--;\n            window.localStorage.setItem(\"itemsList\", JSON.stringify(itemsList));\n\n            return randomIndex;\n        } else {\n            console.warn(\"no more \", randomItem.name);\n            debugger;\n            return me.findSectorToStopOn();\n        }\n    }\n}\n\n\n","export class BonusWheelItem extends PIXI.Sprite {\n    /**\n     *\n     * @param {object} config - wheelItem config\n     * @param {PIXI.Container|PIXI.Sprite} config.parent - Display object, the wheelItem will be added to\n     * @param {PIXI.Texture} config.texture - wheelItem texture\n     * @param {number} config.sectorIndex - sector the item is added to\n     * @param {number} config.centerOffset - distance from wheel center to wheelItem center\n     * @param {number} config.totalSectorsNum - total number of sectors on the parent wheel\n     */\n    constructor (config) {\n        super(config.texture);\n        config.parent.addChild(this);\n\n        this.anchor.set(0.5);\n        this.scale.set(config.scale);\n        this.updatePositionAndRotation(config.totalSectorsNum, config.sectorIndex, config.centerOffset);\n    }\n\n    /**\n     * Positions the item to the proper sector and rotates in a way that item's bottom is directed\n     * to the wheel center;\n     *\n     * @param {number} totalSectorsNum - total number of sectors on the parent wheel\n     * @param {number} sectorIndex - sector the item is added to\n     * @param {number} centerOffset - distance from wheel center to wheelItem center\n     */\n    updatePositionAndRotation(totalSectorsNum, sectorIndex, centerOffset){\n        var me = this,\n            angle = (2 * Math.PI / totalSectorsNum) * sectorIndex,\n            y = - centerOffset * Math.cos(angle),\n            x = - centerOffset * Math.sin(angle);\n\n        me.position.set(x, y);\n        me.rotation = -angle;\n    }\n\n    hide(){\n        this.visible = false;\n    }\n\n    show(){\n        this.visible = true;\n    }\n}","import {animationBuffer} from \"./main\"\n\nexport class AnimationHolder {\n    /**\n     * @property {String} [id=\"\"] The identifier for this animation, if you don't specify one we will try to use\n     * parent.id + \":\" + prop + \"Animation\"\n     */\n    /**\n     * @property {Object} [target=undefined] The target object we want to animate, if you don't specify one we will\n     * try to use the parent.target\n     */\n    /**\n     * @property {String} [prop=undefined] The name of the properties on the target we want to change\n     */\n    /**\n     * @property {Boolean} [running=false] If the animation is active\n     */\n    /**\n     * @property {Number} [playbackSpeed=undefined] If we want to play the animation faster (>1) or slower (<1)\n     */\n    /**\n     * @property {Boolean} [loop=false] Will repeat the whole animation. If it have separate operations with different\n     * time the shorter ones will wait at the end key frame until the longest is done. onStart & onEnd will not be\n     * called every loop (if that is needed, set callbacks on key frames instead). Will also wait for all it's\n     * children to complete.\n     */\n    /**\n     * @property {Boolean} [readyToLoop=false] Since we sometime need to wait for our children we use this to know\n     * when we can loop back to the start.\n     */\n    /**\n     * @property {Function} [onStart=undefined] Callback function before the animation starts\n     */\n    /**\n     * @property {Function} [onEnd=undefined] Callback function when the animation is complete\n     */\n    /**\n     * @property {Function} [onUpdate=undefined] Callback function on every frame before the operation run. Will be\n     * called regardless if the holder have operation, target etc or not, as long as it is running (and it's parents) the\n     * function will be called.\n     */\n    /**\n     * @property {Array} [children=[]] So we can nestle animation\n     */\n    /**\n     * @property {Animation.Holder} [parent=undefined] A reference to the holders parent\n     */\n    /**\n     * @property {Number} [localTime=0] Local time counter\n     */\n    /**\n     * @property {Number} [delay=0] Time before the operations start after the animation starts\n     */\n    /**\n     * @property {Number} [startTimeOffset=0] If we want the animation to start at a specific time (TODO: currently if the offset is beyond the first keyframe it will start at that keyframe instead)\n     */\n    /**\n     * @property {Object} [operations={}] The operations the holder preforms\n     */\n    /**\n     * @property {Object} [operationSteps={}] The current key frame for every operation\n     */\n    /**\n     * @property {Object} [operationEnded={}] If all the operations are done\n     */\n\n\n    /**\n     * Constructor\n     *\n     * @param {Object} config The config object\n     */\n    constructor (config) {\n        var me = this,\n            defaultProp = {\n                id                  : undefined,    // the identifier for this animation\n                target              : undefined,    // the target object we want to animate\n                prop                : undefined,    // the name of the properties on the target we want to change.\n                animation           : {             // object that will hold keyFrames etc.\n                    keyFrames : [],\n                    step : 0,                       // the current keyFrame we're on\n                    complete : false                // if the animation is done\n                },\n                running             : false,        // if the animation is active.\n                playbackSpeed       : undefined,    // if we want to play the animation faster (>1) or slower (<1)\n                loop                : false,        // will repeat the whole animation. If it have separate operations\n                                                    // with different time the shorter ones will wait at the end key frame\n                                                    // until the longest is done. onStart & onEnd will not be called every\n                                                    // loop (if that is needed, set callbacks on key frames instead).\n                                                    // Will also wait for all it's children to complete.\n                readyToLoop         : false,        // since we sometime need to wait for our children we use this to know\n                                                    // when we can loop back to the start.\n                onStart             : undefined,    // callback before the animation starts\n                onEnd               : undefined,    // callback when the animation is complete\n                onUpdate            : undefined,    // callback on every frame before the operation run. Will be\n                                                    // called regardless if the holder have operation, target etc or not\n                children            : [],           // so we can nestle animation\n                parent              : undefined,    // a reference to the holders parent\n                localTime           : 0,            // local time counter\n                delay               : 0,            // time before the operations start after the animation starts\n                startTimeOffset     : undefined,    // if we want the animation to start at a specific time\n                //operations          : {},           // the operations the holder preforms\n                //operationSteps      : {},           // the current key frame for every operation\n                //operationsEnded     : false,        // if all the operations are done\n                addToAnimationLoop  : false         // adding the holder to the animation loop on creation\n            };\n\n        config = Sys.applyProperties(defaultProp, config);\n\n        // Parse the config, this allows us to use several config syntax\n        config = me.parseConfig(config);\n\n        me = Sys.applyProperties(me, config);\n\n        //// Set the default parameters needed by the operations\n        //me.setOperationDefaultProperties();\n\n        if ( config.addToAnimationLoop ){\n            animationBuffer.push(me);\n        }\n\n    }\n\n    /**\n     * Parse the config so that it matches the actual object properties.\n     *\n     * @param config\n     * @return {Object} The parsed properties\n     */\n    parseConfig  (config) {\n        var properties = {\n                animation : {\n                    keyFrames : [],\n                    step : 0,\n                    complete : false\n                }\n            },\n            //operations = Object.keys(Animation.Operations),\n            timeSort = function (a, b) {\n                return (a.time - b.time);\n            },\n            obj;\n\n        // Process all keys on the config object\n        Sys.iterate(config, function(key, value){\n\n            // If we have an animation, parse it\n            if (key === \"animate\" ) {\n\n                /*DEBUG_START*/\n                if ( key !== \"animate\" ){\n                    // TODO: right now we only support the \"animate\" operation, when we need more we have to make them.\n                    console.warn(\"You are trying to use a \" + key + \" operation on a Animation.Holder, for now only 'animate' is supported\");\n                }\n                /*DEBUG_END*/\n\n                // if the operation is an array or object\n                if ( Sys.isObj(value) ){\n\n                    Sys.iterate(value, function(time, frameValue){\n                        // Define the frame object with the time value\n                        obj = { time : parseInt(time, 10) };\n\n                        // If the frame is an object with a defined value then we have non value properties mixed in\n                        if (Sys.isObj(frameValue) ) {\n                            if ( Sys.isDefined(frameValue.value) ){\n                                obj = Sys.applyProperties(obj, frameValue);\n                            }\n                            else {\n                                obj.value = frameValue;\n                            }\n                        }\n                        // Otherwise it is just a plain value\n                        else {\n                            obj.value = frameValue;\n                            /*DEBUG_START*/\n                            if ( !Sys.isDefined(config.prop) && config.length > 1 ){\n                                console.warn(\"If we only specify a number value the property 'prop' must exist\");\n                            }\n                            /*DEBUG_END*/\n                        }\n\n                        // Push the key frame\n                        properties.animation.keyFrames.push(obj);\n                    });\n\n                    properties.animation.keyFrames.sort(timeSort);\n                }\n                else if ( Sys.isArray(value) ){\n                    // the operation is already in the right format, add it to the operations object\n                    properties.animation.keyFrames = value;\n                }\n                else {\n                    // error\n                    console.warn(\"Operation is in wrong format\");\n                }\n            }\n            // Else assign the value\n            else {\n                properties[key] = value;\n            }\n        });\n\n        // if target is undefined use the parents target (if it exist)\n        if ( !Sys.isDefined(properties.target) && Sys.isDefined(properties.parent) && Sys.isDefined(properties.parent.target) ){\n            properties.target = properties.parent.target;\n        }\n\n        /*DEBUG_START*/\n        if ( Sys.isDefined(properties.target) && !Sys.isObj(properties.target) ){\n            console.warn(\"The target of a Animation.Holder must be a Object\");\n        }\n        /*DEBUG_END*/\n\n        // if the id is undefined use the targets id (if it exist) and the operation type\n        if ( !Sys.isDefined(properties.id) && Sys.isDefined(properties.target) && Sys.isDefined(properties.target.id) ){\n            var prop = Sys.isDefined(properties.prop) ? properties.prop : \"\";\n\n            properties.id = properties.target.id + \":\" + prop + \"Animation\";\n        }\n\n        // if we already have children in the config, create them and add them\n        if ( Sys.isDefined(properties.children) && properties.children.length > 0 ){\n            var tempChildrenContainer = [],\n                parent = this;\n\n            properties.children.forEach(function(child){\n                var animation;\n\n                if ( Sys.isDefined(child.localTime) ){\n                    // the child is already a AnimationHolder\n                    animation = child;\n                }\n                else {\n                    child.parent = {target : config.target};\n                    animation = new AnimationHolder(child);\n                }\n                animation.parent = parent;\n                tempChildrenContainer.push( animation );\n            });\n\n            properties.children = tempChildrenContainer;\n        }\n\n        return properties;\n    }\n\n    /**\n     * Run the holder and it's children\n     *\n     * @param {Object} timeObj The object containing the time\n     */\n    run (timeObj) {\n        var me = this,\n            timeStep = timeObj.timeStep;\n\n        if (me.localTime === 0 && Sys.isDefined(me.startTimeOffset) ){\n            // if this is the first frame of the animation and we have a start offset\n            timeStep += me.startTimeOffset;\n        }\n\n        if ( Sys.isDefined(me.playbackSpeed) ){\n            // adjust the time step based on playback speed\n            timeStep *= me.playbackSpeed;\n        }\n\n        me.localTime += timeStep; // increase the local timer\n\n        if(me.localTime >= me.delay) {\n\n            // Time step is used to keep track of internal timers on the operation level\n            me.doAnimation(timeStep);\n\n            me.children.forEach(function(child){\n                if ( child.running ){\n                    child.run({timeStep : timeStep, time : timeObj.time});\n\n                    // if the child is still running\n                    if ( child.running ){\n                        // we should also be running\n                        me.running = true;\n\n                        if ( !child.loop && !child.readyToLoop ){\n                            // if it's time for us to loop, wait until the children are done\n                            // but don't wait on looping children\n                            me.readyToLoop = false;\n                        }\n                    }\n                }\n            });\n\n            if ( Sys.isDefined(me.onUpdate) ){\n                me.onUpdate(timeStep);\n            }\n        }\n\n        if ( me.loop && me.readyToLoop ){\n            // meaning I'm done and all my children are done (ignoring children that are looping)\n            me.restoreOnLoop();\n        }\n        else if ( !me.running ){\n            // this animation is done\n            if ( Sys.isDefined(me.onEnd) ){\n                me.onEnd();\n            }\n\n            // restore the animation on completion so we can start it from the beginning on the next play()\n            me.restore();\n        }\n    }\n\n    /**\n     * Runs each animation operation that is set for the holder\n     *\n     * @private\n     * @param {Number} currentStepTime the current time step\n     */\n    doAnimation (currentStepTime) {\n        var me = this,\n            numKeyFrames = me.animation.keyFrames.length;\n\n        // If we don't have any keyFrames or target just return\n        if (numKeyFrames < 2 || !Sys.isDefined(me.target) ) {\n            me.readyToLoop = true;\n            me.running = false;\n            return;\n        }\n\n        // Check if the animation have finished\n        var running = me.performAction(currentStepTime);\n\n        if (!running) {\n            // all the operations are done\n            me.running = false;\n            me.readyToLoop = true;\n        }\n    }\n\n    /**\n     * Play the animation\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to play. If none is\n     * specified (or true) we play all the children. If you send in an empty array [] we'll only play the current.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    play (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.running = true;\n\n        me.handleItems(\"play\", children);\n\n        if (me.localTime === 0 && Sys.isDefined(me.onStart)){\n            // if we start the game from the beginning do the onStart callback\n            me.onStart();\n        }\n\n        // make sure the parents are running\n        if (isRoot){\n            me.runParent();\n        }\n    }\n\n    runParent (){\n        var me = this;\n\n        if ( Sys.isDefined(me.parent) ){\n            me.parent.running = true;\n\n            me.parent.runParent();\n        }\n    }\n\n    /**\n     * Pause the animation\n     *\n     * @param {Array} [children] An array with children that we want to pause. If none is\n     * specified we pause all the children. If you send in an empty array [] we'll only pause the current holder.\n     */\n    pause (children) {\n        this.running = false;\n\n        this.handleItems(\"pause\", children);\n    }\n\n    /**\n     * Stop the animation and reset it to the beginning. Will do it for all the children as well\n     *\n     * @param {Array} [children] An array with children that we want to stop. If none is\n     * specified we stop all the children. If you send in an empty array [] we'll only stop the current.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    stop (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.running = false;\n\n        me.handleItems(\"stop\", children);\n\n        if ( isRoot ){\n            me.restore(children, true);\n        }\n    }\n\n    /**\n     * Restores the basic properties of the holder in order to run it again.\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to restore. If none is\n     * specified (or true) we restore all the children. If you send in an empty array [] we'll only restore the current holder.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    restore (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        me.localTime = 0;\n        me.readyToLoop = false;\n\n        me.restoreAnimation();\n\n        me.handleItems(\"restore\", children);\n\n        // if we are already running and are the root object we play()\n        if ( me.running && isRoot ){\n            me.play(children, true);\n        }\n    }\n\n    /**\n     * Restores the basic properties of the holder in order to run it again.\n     *\n     * @param {Array|Boolean} [children] An array with children that we want to restore. If none is\n     * specified (or true) we restore all the children. If you send in an empty array [] we'll only restore the current holder.\n     * @param {Boolean} [root] If this is the first object we call this function on (will be false for all it's children)\n     */\n    restoreOnLoop (children, root) {\n        var me = this,\n            isRoot = Sys.isDefined(root) ? root : true;\n\n        if ( isRoot || !me.loop ){\n            me.running = true;\n            //me.localTime = 0;\n            me.readyToLoop = false;\n\n            me.restoreAnimation();\n\n            me.handleItems(\"restoreOnLoop\");\n        }\n    }\n\n    restoreAnimation (){\n        this.animation.time = 0;\n        this.animation.step = 0;\n\n        this.animation.keyFrames.forEach(function(key){\n            if (Sys.isDefined(key.callback)) {\n                key.callbackCompleted = false;\n            }\n\n            // add more stuff\n        });\n    }\n\n    /**\n     * @private\n     * Update the holder with the operation configuration\n     *\n     * @param {Object} config The configuration\n     */\n    updateOperation (config) {\n        var me = this,\n            obj = {};\n\n        //me.applyDefaultValuesToItem(me);\n\n        obj.animate = config;\n\n        obj = me.parseConfig(obj);\n\n        me.animation = obj.animation;\n        //me.applyDefaultValuesToOperation(me);\n\n        me.restore();\n    }\n\n    /**\n     * @private\n     * Call the specified function on all the items\n     *\n     * @param {String} type The function to call on the items\n     * @param {Array} [selection] The optional array of items to handle\n     */\n    handleItems (type, selection){\n        var items = (Sys.isDefined(selection) && Sys.isArray(selection)) ? selection : this.children;\n\n        items.forEach(function(child){\n            child[type](true, false);\n        });\n    }\n\n    setParent (parent){\n        this.parent = parent;\n        parent.children.push(this);\n\n        // if you don't have a target, use the parents\n        if ( !Sys.isDefined(this.target) ){\n            this.target = parent.target;\n        }\n    }\n\n    addChild (children){\n        var me = this;\n\n        if (Sys.isArray(children) ){\n            children.forEach(function(child){\n                child.setParent(me);\n            });\n        }\n        else if (Sys.isObj(children)){\n            children.setParent(me);\n        }\n    }\n\n    /**\n     * Will search children (and grandchildren) for a Holder that mach the key and value provide.\n     *\n     * NOTE: if there is more than one match you will get the first one.\n     *\n     * @param {String} value The value that should match\n     * @param {String} [byKey] Which property key we should check against, default \"id\"\n     *\n     * @return {object|boolean} the items that match our search criteria, or false if it didn't find anything\n     */\n    findChild (value, byKey){\n        var key = Sys.isDefined(byKey) ? byKey : \"id\",\n            item = false,\n            searchChildren = function(items) {\n                var result = false,\n                    subResult = false;\n\n                items.forEach(function(item){\n                    if ( Sys.isDefined(item[key]) && item[key] === value ){\n                        result = item;\n                    }\n\n                    if ( Sys.isDefined(item.children) ){\n                        subResult = searchChildren(item.children);\n\n                        if ( Sys.isObj(subResult) ){\n                            result = subResult;\n                        }\n                    }\n                });\n\n                return result;\n            };\n\n        // start with the main Holder\n        if ( this[key] === value ){\n            return this;\n        }\n\n        if ( Sys.isDefined(this.children) ){\n            item = searchChildren(this.children );\n        }\n\n        return item;\n    }\n\n    /**\n     * Performs the specified action on a given object.\n     *\n     * @param {Number} currentStepTime The time since the last render (ms)\n     */\n    performAction (currentStepTime) {\n        var me = this,\n            animation = me.animation,\n            keyFrames = animation.keyFrames,\n            numKeyFrames = keyFrames.length,\n            currentTime = me.increaseAnimationTime(currentStepTime),\n            currentKeyFrame = keyFrames[animation.step],\n            nextKeyFrame = keyFrames[animation.step + 1],\n            running = true;\n\n        /*DEBUG_START*/\n        if ( numKeyFrames < 2 ){\n            console.warn(\"The Holder \" + item + \" have an animation with less than two keyFrames, the operation needs a minimum of two keyFrames to be able to animate.\");\n            return 0;\n        }\n        /*DEBUG_END*/\n\n        me.handleCallback(currentKeyFrame); // added an extra callback check here to make sure callbacks on keyFrame 0 are fired\n\n        // step through keyFrames, from oldKeyFrameIndex, until we are on the current one\n        // loop if necessary\n        // fire events and callbacks on every new keyFrame we pass\n        // goTo keyFrames\n\n        // check if we have passed the next keyFrame\n        if ( nextKeyFrame.time <= currentTime){\n            me.progressKeyFrame();\n\n            currentKeyFrame = keyFrames[animation.step];\n\n            // are we at the last keyFrame, ie we're not looping and the animation is complete\n            if ( animation.step === numKeyFrames - 1 ){\n                nextKeyFrame = currentKeyFrame;\n                running = false;\n            }\n            else {\n                nextKeyFrame = keyFrames[animation.step + 1];\n            }\n        }\n\n        // when we have the current keyFrame, interpolate between that and the next keyFrame\n        me.calculate(animation.time, currentKeyFrame, nextKeyFrame);\n\n        return running;\n    }\n\n    progressKeyFrame (toIndex){\n        var me = this,\n            animation = me.animation,\n            keyFrames = animation.keyFrames,\n            currentKeyFrame;\n\n        // step to next keyFrame\n        animation.step = Sys.isDefined(toIndex) ? toIndex : animation.step + 1;\n\n        // do events and callbacks\n        currentKeyFrame = keyFrames[animation.step];\n        me.handleCallback(currentKeyFrame);\n\n        // check for goTo\n        if ( Sys.isDefined(currentKeyFrame.goTo) ) {\n            me.doGoTo(currentKeyFrame);\n        }\n\n        // if we haven't reached the last keyFrame\n        if ( animation.step !== keyFrames.length - 1 ){\n            // check if we should move one more\n            if ( animation.time >= keyFrames[animation.step + 1].time){\n                me.progressKeyFrame();\n            }\n        }\n        else if ( me.loop  ){ // at the last keyFrame and we're looping\n            animation.time -= keyFrames[animation.step].time;\n            me.progressKeyFrame(0);\n        }\n\n    }\n\n    doGoTo (keyFrame){\n        var me = this;\n\n        me.animation.time = me.animation.keyFrames[keyFrame.goTo].time;\n        me.animation.step = keyFrame.goTo;\n\n        /*DEBUG_START*/\n        console.warn(\"Warning: goTo functionality not completed, use at own risk.\");\n        // TODO: fix goTo, callback resets when going back and callback firing when going forward etc.\n        /*DEBUG_END*/\n    }\n\n    /**\n     * Calculates the time steps and sets the values that should be interpolated.\n     *\n     * @protected\n     * @param {Number} currentTime The current time step\n     * @param {Object} currentStep The current frame\n     * @param {Object} nextStep The next frame\n     */\n    calculate (currentTime, currentStep, nextStep) {\n        var me = this,\n            time = me.calculateTime(currentTime, currentStep, nextStep),\n            from = currentStep.value,\n            to = nextStep.value,\n            target;\n\n        if ( Sys.isObj(from) ){\n            Sys.iterate(from, function(key, value){\n                target = Sys.isDefined(me.prop) ? me.target[me.prop] : me.target;\n\n                target[key] = Animation.utils.getInterpolationValue(value, to[key], time, currentStep.ease, key);\n            });\n        }\n        else { // we only animate one number\n            me.target[me.prop] = Animation.utils.getInterpolationValue(from, to, time, currentStep.ease);\n        }\n    }\n\n    /**\n     * @private\n     * @param {Object} currentKeyFrame The object holding the current key frame information\n     */\n    handleCallback (currentKeyFrame) {\n        var callback = currentKeyFrame.callback,\n            container;\n\n        if(Sys.isDefined(callback) && !currentKeyFrame.callbackCompleted) {\n\n            if ( callback.fireImmediately ){\n                if ( Sys.isString(callback.func) ){\n                    // an event\n                    callback.scope.fireEvent(callback.func, callback.args);\n                }\n                else if ( Sys.isFunc(callback.func) ){\n                    // a function\n                    callback.func.apply(callback.scope, callback.args);\n                }\n            }\n            else {\n                container = Game.stage.view.animationManager.callbackContainer;\n                container.push(callback);\n            }\n\n            currentKeyFrame.callbackCompleted = true;\n        }\n    }\n\n    /**\n     * Calculates the time vars.\n     *\n     * @private\n     * @param {Number} currentTime The current time step\n     * @param {Object} currentStep The current frame\n     * @param {Object} nextStep The next frame\n     */\n    calculateTime (currentTime, currentStep, nextStep) {\n        var timeStep = currentTime - currentStep.time,\n            totalTime = nextStep.time - currentStep.time;\n\n        //If timeStep equals 0 and totalTime equals 0. The result will be NaN\n        return totalTime !== 0 ? timeStep / totalTime : 1;\n    }\n\n\n    /**\n     * Increase the timeBuffer\n     *\n     * @param {Number} time The time the time buffer should be increased\n     */\n    increaseAnimationTime  (time) {\n        if (!Sys.isDefined(this.animation.time)) {\n            this.animation.time = time;\n        }\n        else {\n            this.animation.time += time;\n        }\n\n        return this.animation.time;\n    }\n\n    animate (config, play) {\n        this.updateOperation(config);\n        if ( play ){\n            this.play();\n        }\n    }\n\n}","import {BonusWheelItem} from \"./BonusWheelItem\";\nimport {AnimationHolder} from \"./AnimationHolder\";\nimport {StorageManager} from \"./StorageItemsManager\";\n\nconst CIRCLE_DEG = 360;\n    //the minimum difference (angle) between current wheel stop and previous wheel stop:\nconst MIN_DIFF = 270;\nconst START_BOUNCE = {\n    //negative value, since the wheel moves backwards\n    maxSpeed: -0.5,\n        //time fraction of the whole acceleration time\n        timeFraction: 1/500\n};\n\nconst WHEEL_ITEMS_CENTER_OFFSET = 520;\nconst WHEEL_ITEM_CONFIG = {\n    width: 220,\n    height: 220\n};\n\nconst LOGO_POSITION = {\n    portrait: {\n        x: 0,\n        y: 430\n    },\n    landscape: {\n        x: 380,\n        y: 310\n    }\n};\n\nexport class BonusWheel extends PIXI.Container {\n    \n    constructor (config, onStartBounceCompleteCallback, app) {\n        super();\n        var me = this;\n\n        me.sectorItemsList = config.sectorItemsList;\n\n        me.background = me._initBackground();\n\n        me._initBgSpine(me, \"glow\", app);\n\n        me.background.anchor.set(0.5,0.5);\n\n        //degrees per frame\n        me.maxSpeed = config.maxSpeed;\n        me.minSpeed = config.minSpeed;\n\n        me.wheelBgDisk = me.initWheelBackground();\n        me.sprite = me._initWheelSprite();\n        me.spinButton = me.initSpinButton();\n        me.wheelItems = me._initWheelItems(me.sprite);\n\n        //will be added to a separate spine slot:\n        me.highlightSprite = typeof config.image !== \"undefined\" ? me._initSprite(config.image, PIXI.BLEND_MODES.ADD) : me._initEmptySprite();\n        me.sectorsAngles = me._mapSectorsAgles(config.sectors);\n        me.animations = me._initAnimations(config);\n        me.onStartBounceCompleteCallback = onStartBounceCompleteCallback;\n        me.config = config;\n\n        me.pick = me._initPickSprite();\n        me.gift = me._initGiftSprite(me, \"SYM8\");\n\n        me.logo = me.initLogo();\n\n        me.reset();\n        me.refresh();\n    }\n\n    _initBackground () {\n        return this.addChild(new PIXI.Sprite.fromImage(\"assets/images/background.png\"))\n    }\n\n    initWheelBackground(){\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/disk.png\");\n        sprite.anchor.set(0.5, 0.5);\n        sprite.scale.set(0.5);\n\n        return this.addChild(sprite);\n    }\n\n    _initBgSpine (container, spineName, app) {\n        var me = this,\n            glow;\n\n        PIXI.loader\n            .add('glow', 'assets/spine/glow.json')\n            .load(onAssetsLoaded);\n\n        function onAssetsLoaded(loader,res) {\n            // instantiate the spine animation\n            glow = new PIXI.spine.Spine(res.glow.spineData);\n            glow.skeleton.setToSetupPose();\n            glow.update(0);\n            glow.autoUpdate = false;\n\n            me.background.addChild(glow);\n\n            // once position and scaled, set the animation to play\n            glow.state.setAnimation(0, 'spin', true);\n            app.ticker.add(function() {\n                glow.update(0.02);\n            });\n\n            glow.visible = false;\n            me.bgAnimation = glow;\n        }\n\n    }\n\n    _initWheelSprite () {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/sectors.png\");\n        sprite.anchor.set(0.5, 0.5);\n        sprite.scale.set(0.5);\n\n        return this.addChild(sprite);\n    }\n\n    initSpinButton () {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/stop_idle.png\");\n        sprite.interactive = true;\n        sprite.anchor.set(0.5, 0.5);\n        sprite.scale.set(0.5);\n        this.addChild(sprite);\n        this.initSpinButtonActions(sprite);\n\n        return sprite;\n    }\n\n    initSpinButtonActions(sprite){\n        var actionDown = function () {\n            if(deviceAPI.deviceType === \"desktop\"){\n                return \"mousedown\";\n            }\n            return \"touchstart\"\n        }();\n        var actionUp = function () {\n            if(deviceAPI.deviceType === \"desktop\"){\n                return \"mouseup\";\n            }\n            return \"touchend\"\n        }();\n\n        {\n            sprite.on(actionDown, function () {\n                sprite.texture = PIXI.Texture.fromImage(\"assets/images/stop_click.png\");\n            });\n\n            sprite.on(\"mouseupoutside\", function () {\n                sprite.texture = PIXI.Texture.fromImage(\"assets/images/stop_idle.png\");\n            });\n\n            sprite.on(\"touchendoutside\", function () {\n                sprite.texture = PIXI.Texture.fromImage(\"assets/images/stop_idle.png\");\n            });\n        }\n\n        sprite.on(actionUp, function () {\n            sprite.texture = PIXI.Texture.fromImage(\"assets/images/stop_idle.png\");\n\n            var itemsLeft = !StorageManager.isNoMoreItems(),\n                itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\")),\n                spinSound = new Audio(\"assets/sounds/spinStart.mp3\"),\n                winSound = new Audio(\"assets/sounds/win.mp3\"),\n                sectorToStopOn;\n\n            if(!itemsLeft){\n                console.error(\"no more items at all\");\n            } else {\n                sprite.interactive = false;\n                spinSound.play();\n                sectorToStopOn = StorageManager.findSectorToStopOn();\n                console.warn(\"stopping at: \", sectorToStopOn);\n\n                wheel.start();\n                wheel.setStoppingAngle(sectorToStopOn);\n                wheel.startStopping().then(function () {\n                    if(itemsList[sectorToStopOn].name === \"SYM8\"){\n                        sprite.interactive = true;\n                    } else {\n                        wheel.playGiftAnimation(itemsList[sectorToStopOn].name, function () {\n                            sprite.interactive = true;\n                        });\n                        winSound.play();\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Adds wheel items - sprites that rotate together with the wheel\n     *\n     * @param {PIXI.Container|PIXI.Sprite} parent - wheelItems will be added here\n     * @returns {Array<S.BonusWheelItem>}\n     * @private\n     */\n    _initWheelItems(parent){\n        var me = this,\n            sizedContainer,\n            bonusWheelItem,\n            whellItems = [];\n\n        me.sectorItemsList.forEach(function (item, index) {\n            sizedContainer = new PIXI.Container();\n\n            bonusWheelItem = new BonusWheelItem({\n                parent: sizedContainer,\n                texture: new PIXI.Texture.fromImage(\"assets/images/prizes/\" + item + \".png\"),\n                sectorIndex: index,\n                centerOffset: WHEEL_ITEMS_CENTER_OFFSET,\n                totalSectorsNum: me.sectorItemsList.length\n            });\n\n            bonusWheelItem.width = WHEEL_ITEM_CONFIG.width;\n            bonusWheelItem.height = WHEEL_ITEM_CONFIG.height;\n\n            parent.addChild(sizedContainer);\n            whellItems.push(bonusWheelItem);\n        });\n\n        return whellItems;\n    }\n\n    _initPickSprite () {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/arrow.png\");\n        sprite.anchor.set(0.5, 0.5);\n        sprite.scale.set(0.5);\n        this.addChild(sprite);\n        sprite.position.y = -350;\n\n        return sprite;\n    }\n\n    _initGiftSprite (container, imageName) {\n        var sprite = this._initSprite(imageName, PIXI.BLEND_MODES.NORMAL);\n\n        container.addChild(sprite);\n        sprite.width = 120;\n        sprite.height = 120;\n        sprite.position.y = -WHEEL_ITEMS_CENTER_OFFSET/2;\n        sprite.visible = false;\n        sprite.animation = new AnimationHolder({\n            addToAnimationLoop: true,\n            target: sprite,\n            children: [\n                {\n                    prop: \"position\",\n                    animate: {\n                        200: {y: -(WHEEL_ITEMS_CENTER_OFFSET/2)},\n                        1500: {y: 0},\n                        5000: {y: 0},\n                        5500: {y: -(WHEEL_ITEMS_CENTER_OFFSET/2)},\n                    }\n                },\n                {\n                    prop: \"width\",\n                    animate: {\n                        200: 120,\n                        1500: WHEEL_ITEM_CONFIG.width * 3,\n                        5000: WHEEL_ITEM_CONFIG.width * 3,\n                        5500: 120\n                    }\n                },\n                {\n                    prop: \"height\",\n                    animate: {\n                        200: 120,\n                        1500: WHEEL_ITEM_CONFIG.height * 3,\n                        5000: WHEEL_ITEM_CONFIG.height * 3,\n                        5500: 120\n                    }\n                }\n            ]\n        });\n\n        return sprite;\n    }\n\n    /**\n     *\n     * @param animSprite - win presentation sprite\n     * @private\n     */\n    _onWinAnimationComplete(animSprite){\n        animSprite.visible = false;\n        this.wheelItems.forEach(function(wheelItem){\n            wheelItem.show();\n        });\n        this.bgAnimation.visible = false;\n    }\n\n    _initSprite (imageName, blendMode) {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/prizes/\"+imageName+\".png\");\n\n        sprite.anchor.set(0.5, 0.5);\n        sprite.blendMode = blendMode;\n\n        return sprite;\n    }\n\n    _initEmptySprite () {\n        return new PIXI.Sprite(PIXI.Texture.EMPTY);\n    }\n\n    /**\n     * @param {Array} sectorsNames - list of sectors names on the wheel\n     * @returns {Object} sectorsAngles - config with all the sectors mapped to angles of wheel rotation\n     */\n    _mapSectorsAgles (sectorsNames) {\n        var sectorsNumber = sectorsNames.length,\n            degreesPerSector = CIRCLE_DEG / sectorsNumber,\n            sectorsAngles = {};\n\n        sectorsNames.forEach(function (sectorName, index) {\n            //forced to use array of angles, since we might have multiple sectors for one value\n            //for instance, the key wheel has 6 sectors with 0 and 2 sectors with 1\n            if(!sectorsAngles[sectorName]){\n                sectorsAngles[sectorName] = [];\n            }\n            sectorsAngles[sectorName].push(degreesPerSector * index);\n        });\n\n        return sectorsAngles\n    }\n\n    /**\n     * These are not \"animations\" in common understanding of the Animation.Holder, they are rather tickers,\n     * that perform certain update functions on every frame\n     *\n     * @param {Object} config - wheel config\n     * @returns {Object} list of all available animations\n     */\n    _initAnimations (config) {\n        return {\n            \"accelerationTicker\": this._initAccelerationTicker(config.accelerationDuration),\n            \"uniformRotationTicker\": this._initUnformRotationTicker(),\n            \"decelerationTicker\": this._initDecelerationTicker()\n        }\n    }\n\n    /**\n     * @param {number} accelerationTime - time it will take to accelerate from 0 to maximum speed\n     * @returns {Object} animation holder that gradually(with easing) increases currentSpeed\n     * that will be used in _updateSpriteAngle on each frame for smooth wheel start\n     */\n    _initAccelerationTicker (accelerationTime) {\n        var me = this;\n\n        return new AnimationHolder({\n            target: me,\n            prop: \"currentSpeed\",\n            onUpdate: me._updateSpriteAngle.bind(me),\n            onEnd: me.startUniformRotation.bind(me),\n            animate: [\n                {\n                    time: 0,\n                    value: 0,\n                    ease: Animation.utils.powerTwoOut\n                },\n                //the wheel bounce back on start:\n                {\n                    time: accelerationTime * START_BOUNCE.timeFraction,\n                    value: START_BOUNCE.maxSpeed,\n                    ease: Animation.utils.powerTwoIn\n                },\n                {\n                    time: accelerationTime,\n                    value: me.maxSpeed\n                }\n            ],\n            addToAnimationLoop: true\n        });\n    }\n\n    /**\n     * @returns {Object} animation holder that calls _updateSpriteAngle on every frame\n     * by this moment, the speed reaches maximum value, so this spins the wheel uniformly\n     */\n    _initUnformRotationTicker () {\n        var me = this;\n\n        return new AnimationHolder({\n            onUpdate: me._updateSpriteAngle.bind(me),\n            addToAnimationLoop: true,\n            loop: true\n        });\n    }\n\n    /**\n     * @returns {Object} animation holder that calls decelerateRotation on every frame and smoothly stops the wheel\n     */\n    _initDecelerationTicker () {\n        var me = this;\n\n        return new AnimationHolder({\n            addToAnimationLoop: true,\n            onUpdate: me.decelerateRotation.bind(me),\n            loop: true\n        });\n    }\n\n    startUniformRotation () {\n        var me = this;\n        //resolving promise (there's no callback on restore):\n        me.onWheelStartCallback && me.onWheelStartCallback();\n        //in regular case it would've reached maxSpeed naturally by this moment, but on restores we're forced to set it manually:\n        me.currentSpeed = me.maxSpeed;\n        me.animations.uniformRotationTicker.play();\n    }\n\n    /**\n     *  decreases currentSpeed depending on currentAngle relative to finalAngle\n     *  the closer we are to the finalAngle the slower we go\n     *  calls _updateSpriteAngle to apply new speed\n     */\n    decelerateRotation () {\n        var me = this,\n            currentAngle = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            distanceLeft = me.finalAngle - currentAngle,\n            maxSpeedFraction = distanceLeft / me.stoppingDistance,\n            timePassedFromStart = 1 - maxSpeedFraction;\n\n        me.currentSpeed = Animation.utils.powerTwoIn(me.maxSpeed, 0, timePassedFromStart);\n\n        //proceed with uniform rotation if the speed might become too low:\n        if (me.currentSpeed < me.minSpeed) {\n            me.currentSpeed = me.minSpeed;\n        }\n\n        me._updateSpriteAngle();\n    }\n\n    /**\n     *  Changes the sprite angle by adding currentSpeed to it, stops the deceleration ticker if reached final angle\n     */\n    _updateSpriteAngle () {\n        var me = this,\n            currentRotation = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            timeScale = me.getTimeScale(),\n            newRawRotation = currentRotation + me.currentSpeed * timeScale,\n            newRotation;\n\n        //startBounce completion condition:\n        if(me.prevFrameSpeed < 0 && me.currentSpeed > 0){\n            me.onStartBounceCompleteCallback(me.config.name);\n        }\n\n        if (newRawRotation >= me.finalAngle) {\n            newRotation = me.finalAngle;\n            me.currentSpeed = 0;\n            me.animations.decelerationTicker.stop();\n\n            //resolving promise:\n            me.onWheelStopped();\n        } else {\n            newRotation = newRawRotation;\n        }\n\n        me.sprite.rotation = newRotation * PIXI.DEG_TO_RAD;\n        me.highlightSprite.rotation = me.sprite.rotation;\n        me.prevFrameSpeed = me.currentSpeed;\n    }\n\n    /**\n     *  Returns timescale coefficient to adjust the animation duration on low FPS\n     *\n     *  @returns {number} - deltaTime correction coefficient\n     */\n    getTimeScale () {\n        var me = this,\n            //todo: remove before release:\n            timeScale = 1.5,\n            oneFrameDuration = 1000/60,\n            now = Date.now(),\n            prev = me.lastTick ? me.lastTick : now - oneFrameDuration;\n\n        me.lastTick = now;\n\n        //todo: remove before release:\n        return (now - prev) * timeScale/oneFrameDuration;\n    }\n\n    start (callback) {\n        this.onWheelStartCallback = callback;\n        this.animations.accelerationTicker.play();\n\n\n    }\n\n    startDeceleration (prevWheelStoppingDistance, onWheelStopped) {\n        var me = this;\n\n        me.onWheelStopped = onWheelStopped;\n        me.animations.uniformRotationTicker.stop();\n        me._updateStoppingDistance(prevWheelStoppingDistance);\n        me.animations.decelerationTicker.play();\n\n        this.bgAnimation.visible = true;\n        this.bgAnimation.state.setAnimation(0, 'spin', true);\n    }\n\n    /**\n     *  updates distance to the destination point and final sprite angle at the moment of stopping\n     *  depending on currentAngle, stopAngle and prevWheelStoppingDistance\n     *\n     *  @param {number} prevWheelStoppingDistance - distance, the previous wheel has to cover before full stop\n     */\n    _updateStoppingDistance (prevWheelStoppingDistance) {\n\n        var me = this,\n            currentAngle = me.sprite.rotation * PIXI.RAD_TO_DEG,\n            //using % me.CIRCLE_DEG here to simply calculations:\n            currentAngleReduced = currentAngle % CIRCLE_DEG,\n            angleToFullCircleLeft = CIRCLE_DEG - currentAngleReduced,\n            stopAngle = me.getStoppingAngle(),\n            minDistanceToTarget = angleToFullCircleLeft + stopAngle,\n            //number of 360 degrees wheel revolutions before stop\n            revolutionsBeforeStop = me.getRevolutionsBeforeStop(minDistanceToTarget, prevWheelStoppingDistance);\n\n        me.stoppingDistance = minDistanceToTarget + revolutionsBeforeStop * CIRCLE_DEG;\n        me.finalAngle = currentAngle + me.stoppingDistance;\n    }\n\n    /**\n     * Calculates the number of extra revolutions to make depending on previous wheel stopping distance\n     * (current wheel distance should always be greater than the previous one)\n     *\n     * @param {number} minDistanceToTarget - minimum possible distance between current and final angles\n     * @param {number} prevWheelStoppingDistance - distance the previous wheel will cover before full stop\n     * @returns {number} spinsBeforeStop - number of extra revolutions before full stop\n     */\n    getRevolutionsBeforeStop (minDistanceToTarget, prevWheelStoppingDistance) {\n        var me = this,\n            revsBeforeStop = 0,\n            targetDistance = prevWheelStoppingDistance + MIN_DIFF,\n            currentValue = minDistanceToTarget;\n        \n        while(currentValue < targetDistance){\n            revsBeforeStop++;\n            currentValue = minDistanceToTarget + CIRCLE_DEG * revsBeforeStop;\n        }\n\n        revsBeforeStop = Math.max(revsBeforeStop, me.config.minimumSpinsBeforeStop);\n\n        return revsBeforeStop;\n    }\n\n    /**\n     * Randomly selects from all available sectors angles for itemToStopOn\n     * (for instance, out of 6 options for 0 level on level wheel) and sets it as stopAngle\n     *\n     * @param {number | string} itemToStopOn - value on the sector whe wheel should stop on\n     * @returns {void}\n     */\n    setStoppingAngle (itemToStopOn) {\n        var me = this,\n            targetAngles = me.sectorsAngles[itemToStopOn],\n            targetAnglesCount = targetAngles.length,\n            randomAngleIndex = Math.floor(Math.random() * targetAnglesCount);\n\n        me.stopAngle = targetAngles[randomAngleIndex];\n    }\n\n    getStoppingAngle () {\n        return this.stopAngle;\n    }\n\n    getCurrentStoppingDistance () {\n        return this.stoppingDistance;\n    }\n\n    playGiftAnimation (name, onEndCallback) {\n        var me = this,\n            gift = me.gift,\n            totalSectorsNum = me.sectorItemsList.length,\n            currentItemIndex = Math.round( totalSectorsNum / CIRCLE_DEG * me.stopAngle),\n            currentWheelItem = me.wheelItems[currentItemIndex];\n\n        currentWheelItem.hide();\n\n        gift.texture = currentWheelItem.texture;\n        gift.visible = true;\n\n        gift.animation.onEnd = function () {\n            me._onWinAnimationComplete(gift);\n            onEndCallback();\n        };\n        gift.animation.play();\n\n        me.bgAnimation.state.setAnimation(0, 'win', true);\n    }\n\n    initLogo () {\n        var sprite = new PIXI.Sprite.fromImage(\"assets/images/logo.png\");\n        sprite.anchor.set(0.5, 0.5);\n        sprite.scale.set(0.5);\n        this.addChild(sprite);\n        sprite.position.y = -350;\n\n        return sprite;\n    }\n\n    reset () {\n        var me = this;\n\n        me.stoppingDistance = Infinity;\n        me.finalAngle = Infinity;\n        me.sprite.rotation = 0;\n        me.currentSpeed = 0;\n        me.lastTick = 0;\n    }\n\n    startStopping () {\n        var me = this;\n\n        return new Promise(function (resolve) {\n            me.startDeceleration(0, function () {\n                resolve();\n            })\n        })\n    }\n\n    changeTexture (itemIndex, texture) {\n        this.wheelItems[itemIndex].texture = texture;\n    }\n\n    refresh () {\n        this.spinButton.scale.set(0.5);\n        this.background.scale.set(0.5);\n\n        if(window.innerHeight > window.innerWidth){\n            //portrait\n            this.background.rotation = (Math.PI/2);\n            this.logo.position.set(LOGO_POSITION.portrait.x, LOGO_POSITION.portrait.y);\n        } else {\n            //landscape\n            this.background.rotation = (Math.PI*2);\n            this.logo.position.set(LOGO_POSITION.landscape.x, LOGO_POSITION.landscape.y);\n        }\n\n    }\n\n}","const CONFIG = {\n    x: 10,\n    y: 10\n};\n\nexport class OpenCloseButton extends PIXI.Sprite{\n\n    constructor (config) {\n        super();\n\n        this.position.set(CONFIG.x, CONFIG.y);\n        this.interactive = true;\n        this.buttonMode = true;\n        this.on('pointerdown', this.onButtonClick.bind(this));\n        this.openCallback = config.openCallback;\n        this.closeCallback = config.closeCallback;\n\n        this.currentState = \"closed\";\n        this.setClosedTexture();\n    }\n\n    onButtonClick () {\n        if(this.currentState === \"closed\"){\n            this.currentState = \"opened\";\n            this.setOpenedTexture();\n            this.openCallback();\n        } else if (this.currentState === \"opened\"){\n            this.currentState = \"closed\";\n            this.setClosedTexture();\n            this.closeCallback();\n        } else {\n            console.error(\"Check for error, current state is \", this.currentState);\n        }\n    }\n\n    setClosedTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/settings.png\")\n    }\n\n    setOpenedTexture () {\n        this.texture = new PIXI.Texture.from(\"assets/images/buttons/error.png\")\n    }\n\n    onForseClosed () {\n        this.currentState = \"closed\";\n        this.setClosedTexture();\n        this.closeCallback();\n    }\n}","const OFFSET = 10;\nconst TOP_OFFSET = 80;\n\nexport class Menu extends PIXI.Container{\n    constructor (config) {\n        super();\n\n        this.onItemImgChange = config.onItemImgChange;\n        this.onCountChange = config.onCountChange;\n\n        const input = document.createElement('input');\n        input.accept = \"image/*\";\n        input.id = \"inpt\";\n        input.type = \"file\";\n        input.onchange = this.updateImageLocally.bind(this);\n\n        document.body.appendChild(input);\n\n        const itemsListContainer = new PIXI.Container();\n        itemsListContainer.position.y = TOP_OFFSET;\n\n        const itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\"));\n        this.itemGroups = this.createItemsListInterface(itemsList, itemsListContainer);\n        this.addChild(itemsListContainer);\n\n        this.hideMenu();\n    }\n\n    onStorageUpdated () {\n        console.log(\"updating the storage\");\n        const itemsList = JSON.parse(window.localStorage.getItem(\"itemsList\"));\n        this.itemGroups.forEach(function (item, index) {\n            item.countText.text = itemsList[index].count;\n        });\n\n    }\n\n    showMenu () {\n        this.visible = true;\n    }\n\n    hideMenu () {\n        this.visible = false;\n    }\n\n    createItemsListInterface (itemsList, parentContainer) {\n        var me = this,\n            itemGroup, itemGroups = [];\n\n        PIXI.loader\n            .load(\n                itemsList.forEach(function (item, itemIndex) {\n                    itemGroup = me.createItemContainer(parentContainer, item, itemIndex);\n                    itemGroups[itemIndex] = itemGroup;\n                })\n            );\n\n        return itemGroups;\n    }\n\n    createItemContainer (parentContainer, item, itemIndex) {\n        const itemContainer = new PIXI.Container();\n        let itemGroup = {};\n\n        itemGroup.button = this.addButton(itemContainer, item.name, itemIndex);\n        itemGroup.countText = this.addTxt(itemContainer, item.count);\n        itemGroup.buttons = this.addPlusMinusButtons(itemContainer, itemIndex, item.count);\n        itemContainer.position.set(OFFSET, (OFFSET * itemIndex) + (itemIndex * itemContainer.height));\n\n        this.addItemsListBg(itemContainer);\n\n        parentContainer.addChild(itemContainer);\n        return itemGroup;\n    }\n\n    addItemsListBg (container) {\n        var graphics = new PIXI.Graphics();\n\n        graphics.beginFill(0x3d5c5c);\n        graphics.lineStyle(2, 0xDE3249, 1);\n        graphics.drawRect(0, 0, container.width, container.height);\n        graphics.endFill();\n        graphics.blendMode = 2;\n\n        container.addChildAt(graphics, 0);\n    }\n\n    addButton (parentContainer, name, itemIndex) {\n        const me = this;\n        const texture = new PIXI.Texture.from(\"assets/images/prizes/\" + name + \".png\");\n        const itemImage = new PIXI.Sprite(texture);\n\n        itemImage.height = 50;\n        itemImage.width = 50;\n\n        itemImage.interactive = true;\n        itemImage.buttonMode = true;\n        itemImage.on('pointerdown', me.onItemClick.bind(me, itemImage, itemIndex));\n\n        parentContainer.addChild(itemImage);\n    }\n\n    addTxt (parentContainer, count) {\n        const style = new PIXI.TextStyle({\n                fill: '#d8df75',\n                fontSize: 15,\n                fontFamily: 'Arial'\n            }),\n            txt = new PIXI.Text(count, style);\n\n        txt.anchor.set(0.5);\n        txt.position.set(100, parentContainer.width / 2);\n\n        parentContainer.addChild(txt);\n        return txt;\n    }\n\n    addPlusMinusButtons (parentContainer, itemIndex) {\n        const me = this;\n        let buttons = {};\n\n        buttons.plusButton = me.initIncrementButton(\n            {\n                x: 160,\n                y: 0,\n                width: 20,\n                height: 20,\n                texture: new PIXI.Texture.from(\"assets/images/buttons/plus.png\"),\n                callback: me.onPlusButtonClick.bind(me, itemIndex),\n                parentContainer: parentContainer\n            });\n\n        buttons.minusButton = me.initIncrementButton(\n            {\n                x: 160,\n                y: 30,\n                width: 20,\n                height: 20,\n                texture: new PIXI.Texture.from(\"assets/images/buttons/minus.png\"),\n                callback: me.onMinusButtonClick.bind(me, itemIndex),\n                parentContainer: parentContainer\n            });\n\n        return buttons;\n    }\n\n    initIncrementButton (config) {\n        let button = new PIXI.Sprite(config.texture);\n\n        button.position.set(config.x, config.y);\n        button.interactive = true;\n        button.buttonMode = true;\n        button.width = config.width;\n        button.height = config.height;\n        button.on(\"pointerdown\", config.callback);\n        config.parentContainer.addChild(button);\n\n        return button;\n    }\n\n    onPlusButtonClick (itemIndex) {\n        let newCount = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count + 1;\n\n        this.onCountChange(itemIndex, newCount);\n        this.updateCountText(itemIndex, newCount);\n    }\n\n    onMinusButtonClick (itemIndex) {\n        const currentCount = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count;\n        let newCount;\n\n        if((currentCount - 1) <= 0){\n            newCount = 0;\n        } else {\n            newCount = currentCount - 1 ;\n        }\n\n        this.onCountChange(itemIndex, newCount);\n        this.updateCountText(itemIndex, newCount);\n    }\n\n    updateCountText (itemIndex, newCount) {\n        if(!newCount){\n            this.itemGroups[itemIndex].countText.text = JSON.parse(window.localStorage.getItem(\"itemsList\"))[itemIndex].count;\n            return;\n        }\n        this.itemGroups[itemIndex].countText.text = newCount;\n    }\n\n    onItemClick (targetSprite, itemIndex) {\n        document.getElementById(\"inpt\").click();\n        this.targetSprite = targetSprite;\n        this.itemIndex = itemIndex;\n    }\n\n    updateImageLocally () {\n        var me = this,\n            file = document.getElementById(\"inpt\").files[0],\n            reader = new FileReader();\n\n        reader.onload = function () {\n            me.targetSprite.setTexture(new PIXI.Texture.from(reader.result));\n            me.onItemImgChange(me.itemIndex, new PIXI.Texture.from(reader.result));\n        };\n\n        if (file) {\n            reader.readAsDataURL(file);\n        }\n\n    }\n\n\n}","import {SoundButton} from \"./SoundButton\";\nimport {FullScreenButton} from \"./FullScreenButton\";\nimport {ScrollContainer} from \"./ScrollContainer\";\nimport {StorageManager} from \"./StorageItemsManager\";\nimport {BonusWheel} from \"./BonusWheel\";\nimport {OpenCloseButton} from \"./OpenCloseButton\";\nimport {Menu} from \"./Menu\";\n\nexport const animationBuffer = [];\n\nvar app = new PIXI.Application(window.innerWidth, window.innerHeight, {backgroundColor : 0x000000});\ndocument.body.appendChild(app.view);\n\nconst soundButton = new SoundButton();\n\nvar docEl = document.documentElement;\nvar requestFullScreen = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen ||  docEl.msRequestFullscreen;\nvar exitFullscreen = docEl.exitFullscreen || docEl.webkitExitFullscreen || docEl.mozExitFullScreen ||  docEl.msExitFullscreen;\n\nconst fullScreenButton = new FullScreenButton({\n    enterFullscreenMode: function () {\n        requestFullScreen();\n    },\n    exitFullscreenMode: function () {\n        exitFullscreen();\n    }\n});\n\nvar scrollContainer = new ScrollContainer(0, 0, 500, 1000, 1500);\n\nvar prerenderCallbacks = [animate],\n    lastTimeStepOccured = 0,\n    currentStepTime = 0,\n    currentTime = 0;\n\nlastTimeStepOccured = updateTime();\n\nif(!window.localStorage.getItem(\"itemsList\")){\n    StorageManager.initStorage();\n}\n\nvar wheel = new BonusWheel({\n    name: \"freespins\",\n    spineSlot: \"1st_back\",\n    highlightSlot: \"1st_back2\",\n    sectors: [0,1,2,3,4,5,6,7,8,9,10,11],\n    maxSpeed: 16,\n    minSpeed: 0.15,\n    accelerationDuration: 1800,\n    minimumSpinsBeforeStop: 3,\n    sectorItemsList: StorageManager.getSectorItemsList(),\n    image: \"SYM8\"\n}, function () {\n    menu.onStorageUpdated();\n}, app);\nwindow.wheel = wheel;\n\n// move the sprite to the center of the screen\nwheel.position.set(app.screen.width / 2, app.screen.height / 2);\n\nwindow.addEventListener(\"resize\", function() {\n    app.renderer.resize(window.innerWidth, window.innerHeight);\n    wheel.position.set(window.innerWidth / 2, window.innerHeight / 2);\n});\n\n// Listen for animate update\napp.ticker.add(function(delta) {\n    prerenderCallbacks.forEach(function(cb) {\n        cb();\n    });\n    scrollContainer.hideOffscreenElements();\n});\n\nfunction animate(){\n    animationBuffer.forEach(function(holder){\n        if ( holder.running ){\n            holder.run({\n                timeStep: currentStepTime,\n                time: currentTime\n            });\n        }\n    });\n}\n\nfunction updateTime() {\n    var now = Date.now(),\n        diff = now - lastTimeStepOccured;\n\n    // Check if more time than allowed has passed since the last frame\n    if (diff > 250) {\n        diff = 1000 / 60;\n    }\n\n    currentStepTime = diff | 0;\n    currentTime += currentStepTime;\n\n    return now;\n}\n\napp.stage.addChild(wheel);\n\nvar openCloseButton = new OpenCloseButton({\n    openCallback: function () {\n        menu.showMenu();\n    },\n    closeCallback: function () {\n        menu.hideMenu();\n    }\n});\n\nvar menu = new Menu({\n    onItemImgChange: function (index, texture) {\n        wheel.changeTexture(index, texture);\n    },\n    onCountChange: function (index, count) {\n        StorageManager.setItemCount(index, count);\n    }\n});\n\n//app.stage.addChild(menu);\nscrollContainer.addChild(menu);\napp.stage.addChild(scrollContainer);\napp.stage.addChild(soundButton);\napp.stage.addChild(fullScreenButton);\napp.stage.addChild(openCloseButton);\n\ndocument.documentElement.webkitRequestFullscreen();\n\n\nwindow.addEventListener(\"resize\", refresh);\nfunction refresh() {\n    wheel.refresh();\n}\n\nwindow.storageManager = StorageManager;\n","export class ScrollContainer extends PIXI.Container{\n    constructor(x, y, width, height, itemHeight) {\n        super();\n\n        this.po = new PIXI.Container();\n        this.scrollContainer = new PIXI.Container();\n        this.po.addChild(this.scrollContainer);\n        this.items = [];\n        this.x = x;\n        this.y = y;\n\n        this.scrollContainer.x = x;\n        this.scrollContainer.y = y;\n        this.height = height;\n        this.itemHeight = itemHeight;\n\n        this.mask = new PIXI.Graphics();\n        this.mask\n            .beginFill(0xFFFFFF)\n            .drawRect(x, y, width, height)\n            .endFill();\n\n        this.po.addChild(this.mask);\n        this.scrollContainer.mask = this.mask;\n\n        this.mousedown = false;\n        this.lastPos = null;\n        this.lastDiff = null;\n        this.scrollTween = null;\n\n        this.po.interactive = true;\n        this.po.mousemove = e => this.onmousemove(e);\n        this.po.mousedown = e => this.onmousedown(e);\n        this.po.mouseup = e => this.onmouseup(e);\n        this.po.mouseupoutside = e => this.onmouseup(e);\n        this.po.touchmove = e => this.onmousemove(e);\n        this.po.touchstart = e => this.onmousedown(e);\n        this.po.touchend = e => this.onmouseup(e);\n        this.po.touchendoutside = e => this.onmouseup(e);\n    }\n\n    onmousemove(e) {\n        const { originalEvent } = e.data;\n        var clientY = !originalEvent.touches ? originalEvent.clientY : originalEvent.touches[0].clientY;\n\n        if (this.mousedown) {\n            this.lastDiff = clientY - this.lastPos.y;\n            this.lastPos.y = clientY;\n\n            if (-this.scrollContainer.y < 0) {\n                this.scrollContainer.y += this.lastDiff / 2;\n            } else {\n                this.scrollContainer.y += this.lastDiff;\n            }\n        }\n    }\n\n    onmousedown(e) {\n        const { originalEvent } = e.data;\n        const clientY = !originalEvent.touches ? originalEvent.clientY : originalEvent.touches[0].clientY;\n        this.mousedown = true;\n        if (this.scrollTween) {\n            this.scrollTween.kill();\n        }\n        this.lastPos = {\n            y: clientY\n        };\n    }\n\n    onmouseup() {\n        if (this.lastDiff) {\n            let goY = this.scrollContainer.y + this.lastDiff * 10;\n            let ease = Quad.easeOut;\n            let time = Math.abs(this.lastDiff / 150);\n            if (goY < -this.items.length * this.itemHeight + this.height + this.y) {\n                goY = -this.items.length * this.itemHeight + this.height + this.y;\n                ease = Back.easeOut;\n                time = 0.1 + Math.abs(this.lastDiff / 150);\n            }\n            if (goY > this.y) {\n                goY = this.y;\n                ease = Back.easeOut;\n                time = 0.1 + Math.abs(this.lastDiff / 150);\n            }\n\n            if (this.scrollContainer.y > 0) {\n                time = 1 + this.scrollContainer.y / 500;\n                ease = Elastic.easeOut;\n            }\n            if (this.scrollContainer.y < -this.items.length * this.itemHeight + this.height) {\n                time = 1 + (this.items.length * this.itemHeight + this.height + this.scrollContainer.y) / 500;\n                ease = Elastic.easeOut;\n            }\n\n            this.scrollTween = TweenMax.to(this.scrollContainer, time, {\n                y: goY,\n                ease\n            });\n        }\n\n        this.mousedown = false;\n        this.lastPos = null;\n        this.lastDiff = null;\n    }\n\n    // This should be called every tick. Use only for scrolling containers with lots of elements for performance.\n    hideOffscreenElements() {\n        const startIndex = Math.floor(-(this.scrollContainer.y - this.y) / this.itemHeight);\n        const endIndex = Math.floor(startIndex + (this.height / this.itemHeight));\n        for (let i = 0; i < this.items.length; i++) {\n            const item = this.items[i];\n            item.visible = false;\n            if (i >= startIndex && i <= endIndex + 1) {\n                item.visible = true;\n            }\n        }\n    }\n\n    addItem(item) {\n        this.scrollContainer.addChild(item);\n        this.items.push(item);\n        item.y = (this.items.length - 1) * this.itemHeight;\n    }\n}"],"sourceRoot":""}